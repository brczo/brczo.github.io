<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="linux高性能编程,">










<meta name="description" content="tcp&amp;amp;ip 数据链路层数据链路层的两个常用协议是ARP协议（Address Resolve Protocol）地址解析协议和RARP（Reverse Address Resolve Protocol）逆地址解析协议。实现IP地址与机器物理地址之间的相互转换。 网络层网络层实现数据包的选路和转发。网络层最核心的协议是IP协议。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能">
<meta name="keywords" content="linux高性能编程">
<meta property="og:type" content="article">
<meta property="og:title" content="linux高性能编程">
<meta property="og:url" content="brczo.github.io/2019/04/10/linux高性能服务器编程/index.html">
<meta property="og:site_name" content="进化">
<meta property="og:description" content="tcp&amp;amp;ip 数据链路层数据链路层的两个常用协议是ARP协议（Address Resolve Protocol）地址解析协议和RARP（Reverse Address Resolve Protocol）逆地址解析协议。实现IP地址与机器物理地址之间的相互转换。 网络层网络层实现数据包的选路和转发。网络层最核心的协议是IP协议。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/images/TCP:IP协议族体系结构及主要协议.png">
<meta property="og:image" content="/images/网络层与传输层的区别%0A.png">
<meta property="og:image" content="/images/socketOption.png">
<meta property="og:updated_time" content="2019-12-04T12:50:32.560Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="linux高性能编程">
<meta name="twitter:description" content="tcp&amp;amp;ip 数据链路层数据链路层的两个常用协议是ARP协议（Address Resolve Protocol）地址解析协议和RARP（Reverse Address Resolve Protocol）逆地址解析协议。实现IP地址与机器物理地址之间的相互转换。 网络层网络层实现数据包的选路和转发。网络层最核心的协议是IP协议。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能">
<meta name="twitter:image" content="/images/TCP:IP协议族体系结构及主要协议.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="brczo.github.io/2019/04/10/linux高性能服务器编程/">





  <title>linux高性能编程 | 进化</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">进化</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/10/linux高性能服务器编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">linux高性能编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T14:03:13+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="tcp-amp-ip"><a href="#tcp-amp-ip" class="headerlink" title="tcp&amp;ip"></a>tcp&amp;ip</h2><p><img src="/images/TCP:IP协议族体系结构及主要协议.png" alt="TCP/IP协议族体系结构及主要协议"></p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层的两个常用协议是ARP协议（Address Resolve Protocol）地址解析协议和RARP（Reverse Address Resolve Protocol）逆地址解析协议。实现IP地址与机器物理地址之间的相互转换。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层实现数据包的选路和转发。网络层最核心的协议是<strong>IP协议</strong>。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接投递给目标主机，那么IP协议就为它寻找下一个合适的下一跳路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或者发送失败而丢弃。<br>网络层的另一重要协议是ICMP协议，主要用于检测网络连接。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层为两台主机上的应用提供端到端的通信，只关心通信的起始端和目的端，而不在乎数据包的中转过程。<br><img src="/images/网络层与传输层的区别
.png" alt="网络层与传输层的区别"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层负责处理应用程序逻辑。</p>
<h3 id="socket和tcp-ip协议族的关系"><a href="#socket和tcp-ip协议族的关系" class="headerlink" title="socket和tcp/ip协议族的关系"></a>socket和tcp/ip协议族的关系</h3><p>数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能访问这些协议提供的服务。实现这些系统调用的api主要是socket。<br>由socket定义的这一组API提供以下两点功能：</p>
<ul>
<li>一是将应用程序数据从用户缓冲区中复制到TCP/IP内核发送缓冲区，以交付内核来发送数据，或者从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区，以读取数据。</li>
<li>二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细的控制底层通信行为。比如可以通过setsockopt函数来设置IP数据报在网络上的存活时间。</li>
</ul>
<hr>
<h2 id="socket地址结构"><a href="#socket地址结构" class="headerlink" title="socket地址结构"></a>socket地址结构</h2><h3 id="socket地址api"><a href="#socket地址api" class="headerlink" title="socket地址api"></a>socket地址api</h3><h4 id="大端字节序与小端字节序"><a href="#大端字节序与小端字节序" class="headerlink" title="大端字节序与小端字节序"></a>大端字节序与小端字节序</h4><p>大端字节序的高位字节在前，低位字节在后。人类读数值的顺序。<br>小端字节序高位字节在后，低位字节在前。计算机处理速度快。<br>网络字节是大端字节序<br>小端字节序也叫主机字节序</p>
<h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr &#123;</span><br><span class="line">    sa_family_t sa_family; </span><br><span class="line">    char sa_data[14];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sa_family是地址族类型（sa_family_t)的变量。地址族类型通常与协议族类型对应。</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址族</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP/IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP/IPv6协议族</td>
</tr>
</tbody>
</table>
<p>sa_data用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址值含义和长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>PF_UNIX</td>
<td>文件的路径名，长度可达108字节</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16bit端口号和32bitIPv4地址，共6字节</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>16bit端口号，32bit流标识，128bitIPv6地址，32bit范围ID，共26字节</td>
</tr>
</tbody>
</table>
<p>由于sa_data的14字节已不能满足需求，linux新定义了一个新的通用socket地址结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_storage&#123;</span><br><span class="line">    sa_family_t sa_family;</span><br><span class="line">    unsigned long int __ss_align;</span><br><span class="line">    char __ss_padding[128-sizeof(__ss_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><p>UNIX本地域协议族专用socket地址结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line">struct sockaddr_un&#123;</span><br><span class="line">    sa_family_t sin_family; /* 地址族：AF_UNIX */</span><br><span class="line">    char sun_path[108]; /* 文件路径名 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>IPv4专用socket地址结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t sin_family; /* 地址族：AF_INET */</span><br><span class="line">    u_int16_t sin_port; /* 端口号，要用网络字节序表示 */</span><br><span class="line">    struct in_addr sin_addr; /* IPv4地址结构体 */</span><br><span class="line">&#125;;</span><br><span class="line">struct in_addr&#123;</span><br><span class="line">    u_int32_t s_addr; /* IPv4地址，要用网络字节序 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>IPv6专用socket地址结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in6&#123;</span><br><span class="line">    sa_family_t sin6_family; /* 地址族：AF_INET6 */</span><br><span class="line">    u_int16_t sin6_port; /* 端口号，要用网络字节序表示 */</span><br><span class="line">    u_int32_t sin6_flowauto; /* 流信息，应设置为0 */</span><br><span class="line">    struct in6_addr sin6_addr; /* IPv6地址结构体 */</span><br><span class="line">    u_int32_t sin6_scope_id; /* scope ID， 尚处于实验阶段 */</span><br><span class="line">&#125;;</span><br><span class="line">struct in6_addr &#123;</span><br><span class="line">    unsigned char sa_addr[16]; /* IPv6地址，要用网络字节序表示 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>所有专用socket地址类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可）</strong></p>
<hr>
<h2 id="socket-创建-命名…"><a href="#socket-创建-命名…" class="headerlink" title="socket 创建 命名…"></a>socket 创建 命名…</h2><h3 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param domain 协议族 包括PF_INET（IPv4）、PF_INET6（IPv6）或PF_UNIX</span><br><span class="line">    @param type 服务类型 包括流服务（SOCK_STREAM）、数据包服务（SOCK_DGRAM）、</span><br><span class="line">    SOCK_NONBLOCK和SOCK_CLOEXEC。后两者表示将新创建的socket设为非阻塞的，以及用</span><br><span class="line">    fork调用创建子进程时在子进程中关闭socket。</span><br><span class="line">    @param protocol 选择子协议 默认为0</span><br><span class="line">    @return socket文件描述符|-1并设置errno</span><br><span class="line">**/</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>
<h3 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h3><p>创建socket时，指定了地址族，但是并未指定使用该地址族中的哪个具体的socket地址。将一个socket与socket地址绑定称为命名。<br>在服务器端通常需要命名socket，客户端通常不需要，而是采用匿名的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket文件描述符</span><br><span class="line">    @param addr socket地址</span><br><span class="line">    @param addrlen 指定地址长度</span><br><span class="line">    @return 0 成功|-1 并设置errno。其中两种常见的errno是EACCES和EADDRINUSE</span><br><span class="line">    EACCES 被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket</span><br><span class="line">    绑定到知名服务端口（端口号为0~1023）上时，bind将返回EACCES错误</span><br><span class="line">    EADDRINUSE 被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT</span><br><span class="line">    状态的socket地址。</span><br><span class="line">**/</span><br><span class="line">int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<h3 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h3><p>socket被命名后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket文件描述符</span><br><span class="line">    @param backlog 提示内核监听队列的最大长度 监听队列的长度如果超过最大长度</span><br><span class="line">    服务器将不受理新的客户连接。客户端也将收到ECONNREFUSED</span><br><span class="line">    @return 0|-1</span><br><span class="line">**/</span><br><span class="line">int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure></p>
<h3 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h3><p>从listen监听队列中接受一个连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd 执行过listen系统调用的监听socket。</span><br><span class="line">    @param addr 用来获取被接受连接的远程socket地址</span><br><span class="line">    @param addrlen socket地址的长度</span><br><span class="line">    @return socket 该socket唯一的标识了被接收的这个连接|-1</span><br><span class="line">**/</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure></p>
<p><strong>accept只是从监听队列中取出连接，而不论连接处于何种状态，更不关心任何网络状况的变化。</strong></p>
<h3 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h3><p>主动与服务器建立连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket系统调用返回一个socket。</span><br><span class="line">    @param serv_addr 服务器监听的socket地址</span><br><span class="line">    @param addrlen 指定地址长度</span><br><span class="line">    @return 0|-1 并设置errno </span><br><span class="line">    ECONNREFUSED 目标端口不存在，连接被拒绝</span><br><span class="line">    ETIMEOUT 连接超时</span><br><span class="line">**/</span><br><span class="line">int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure></p>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param fd 待关闭的socket</span><br><span class="line">**/</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="socket-数据读写"><a href="#socket-数据读写" class="headerlink" title="socket 数据读写"></a>socket 数据读写</h2><h3 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket文件描述符</span><br><span class="line">    @param buf 读/写缓冲区的位置</span><br><span class="line">    @param len 读缓冲区的大小</span><br><span class="line">    @param flags 通常设置为0</span><br><span class="line">    @return 0 | -1</span><br><span class="line">**/</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>
<h3 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);</span><br><span class="line">ssize_t sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<h3 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);</span><br><span class="line">ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);</span><br><span class="line"></span><br><span class="line">struct msghdr&#123;</span><br><span class="line">    void* msg_name;  /* socket地址 */</span><br><span class="line">    socklen_t msg_namelen; /*socket地址的长度*/</span><br><span class="line">    struct iovec* msg_iov; /*分散的内存块*/</span><br><span class="line">    int msg_iovlen; /*分散内存块的数量*/</span><br><span class="line">    void* msg_control; /*指向辅助数据的起始位置*/</span><br><span class="line">    socklen_t msg_controllen; /*辅助数据的大小*/</span><br><span class="line">    int msg_flags; /*复制函数中的flags参数，并在调用过程中更新*/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct iovec&#123;</span><br><span class="line">    void *iov_base; /* 内存起始地址 */</span><br><span class="line">    size_t iov_len; /* 这块内存的长度 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="地址信息函数-socket选项"><a href="#地址信息函数-socket选项" class="headerlink" title="地址信息函数 socket选项"></a>地址信息函数 socket选项</h2><h3 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    获取sockfd对应的本端socket地址，并将其存储于address参数指定的内存中</span><br><span class="line">    @param sockfd socket文件描述符</span><br><span class="line">    @param address socket地址</span><br><span class="line">    @param address_len socket地址长度</span><br><span class="line">    @return -1 | 0</span><br><span class="line">**/</span><br><span class="line">int getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len);</span><br><span class="line">/**</span><br><span class="line">    获取sockfd对应的远端socket地址，其参数及返回值的含义与getsockname的参数及返回值相同</span><br><span class="line">**/</span><br><span class="line">int getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);</span><br></pre></td></tr></table></figure>
<h3 id="socket-选项"><a href="#socket-选项" class="headerlink" title="socket 选项"></a>socket 选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#inclde &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket描述符</span><br><span class="line">    @param level 指定要操作协议的选项 比如 IPv4 IPv6</span><br><span class="line">    @param option_name参数则指定选项的名字</span><br><span class="line">    @param option_value 被操作选项的值</span><br><span class="line">    @param option_len 被操作选项的长度</span><br><span class="line">    @return -1 | 0</span><br><span class="line">**/</span><br><span class="line">int getsockopt(int sockfd, int level, int option_name, void* option_value,</span><br><span class="line">               socklen_t* restrict option_len);</span><br><span class="line">int setsockopt(int sockfd, int level, int option_name, const void* option_value,</span><br><span class="line">               socklen_t option_len);</span><br></pre></td></tr></table></figure>
<p>socket 常用选项<br><img src="/images/socketOption.png" alt></p>
<hr>
<h2 id="网络信息API-06"><a href="#网络信息API-06" class="headerlink" title="网络信息API 06"></a>网络信息API 06</h2><p>socket地址的两个要素, 即IP地址和端口号,都是用数值表示.</p>
<h3 id="gethostbyname-和-gethostbyaddr"><a href="#gethostbyname-和-gethostbyaddr" class="headerlink" title="gethostbyname 和 gethostbyaddr"></a>gethostbyname 和 gethostbyaddr</h3><p>gethostbyname函数根据主机名称获取主机的完整信息, gethostbyaddr函数根据IP地址获取主机的完整信息. gethostbyname函数通常先在本地的/etc/hosts配置文件中查找主机.如果没有找到, 再去访问DNS服务器.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    @param name 指定目标主机的主机名</span><br><span class="line">    @param addr 指定目标主机的ip地址    </span><br><span class="line">    @param len 指定addr所指ip地址的长度</span><br><span class="line">    @param type 指定addr所指IP地址的类型, 其合法取值包括AF_INET和AF_INET6</span><br><span class="line">**/</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct hostent* gethostbyname(const char* name);</span><br><span class="line">struct hostent* gethostbyname(const void* addr, size_t len, int type);</span><br><span class="line"></span><br><span class="line">这两个函数返回的都是hostent结构体类型的指针, hostent结构体的定义如下</span><br><span class="line"></span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct hostent &#123;</span><br><span class="line">    char* h_name; //主机名</span><br><span class="line">    char** h_aliases; // 主机别名列表</span><br><span class="line">    int h_addrtype; // 地址类型</span><br><span class="line">    int h_length; //地址长度</span><br><span class="line">    char** h_addr_list; // 按网络字节序列出的主机IP地址列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="getservbyname-和-getservbyport"><a href="#getservbyname-和-getservbyport" class="headerlink" title="getservbyname 和 getservbyport"></a>getservbyname 和 getservbyport</h3><p>getservbyname函数根据名称获取某个服务的完整信息, getservbyport函数根据端口号获取某个服务的完整信息.它们实际上都是通过读取/etcservices文件来获取服务的信息的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    @param name 指定目标服务的名字</span><br><span class="line">    @param port 指定目标服务对应的端口号</span><br><span class="line">    @param proto 指定服务类型 给它传递tcp表示流服务, 给它传递udp表示流服务, 给它传递NULL则表示所有获取类型的服务</span><br><span class="line">**/</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct servent* getservbyname(const char *name, const char * proto);</span><br><span class="line">struct servent* getservbyport(int port, const char * proto);</span><br><span class="line"></span><br><span class="line">两个函数返回的都是servent结构体类型的指针, 结构servent的定义如下</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct servent &#123;</span><br><span class="line">    char* s_name; //服务名称</span><br><span class="line">    char** s_aliases; // 服务的别名列表</span><br><span class="line">    int s_port; // 端口号</span><br><span class="line">    char* s_proto; // 服务类型, 通常是tcp或udp</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过主机名和服务名访问目标服务器上的daytime服务, 以获取该机器的系统时间.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    assert(argc == 2);</span><br><span class="line">    char *host = argv[1];</span><br><span class="line">    /* 获取主机地址信息 */</span><br><span class="line">    struct hostent* hostinfo = gethostbyname(host);</span><br><span class="line">    assert(hostinfo);</span><br><span class="line">    /* 获取daytime服务信息 */</span><br><span class="line">    struct servent* servinfo = getservbyname(&quot;daytime&quot;, &quot;tcp&quot;);</span><br><span class="line">    assert(servinfo);</span><br><span class="line">    printf(&quot;daytime port is %d\n&quot;, ntohs(servinfo-&gt;s_port));</span><br><span class="line">    struct sockaddr_in address;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = servinfo-&gt;s_port;</span><br><span class="line">    /* 注意下面的代码, 因为h_addr_list本身是使用网络字节序的地址列表, 所以使用其中的IP地址时, 无须对目标IP转换字节序.</span><br><span class="line">    address.sin_addr = *(struct in_addr*) *hostinfo-&gt;h_addr_list;</span><br><span class="line">    int sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    int result = connect(sockfd, (struct sockaddr*)&amp;address, sizeof(address));</span><br><span class="line">    assert(result != -1);</span><br><span class="line"></span><br><span class="line">    char buffer[128];</span><br><span class="line">    result = read(sockfd, buffer, sizeof(buffer));</span><br><span class="line">    assert(result &gt; 0);</span><br><span class="line">    buffer[result] = &apos;\0&apos;;</span><br><span class="line">    printf(&quot;the daytime is: %s&quot;, buffer);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">需要支出的是, 上面讨论的4个函数都是不可重入的, 即非线程安全的. 不过netdb.h头文件给出了它们的可重入版本.正如linux下所有  其他函数的可重入版本的命名规则那样, 这些函数的函数名是在原函数名尾部加上_r(re-entrantj)</span><br></pre></td></tr></table></figure></p>
<h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p>getaddrinfo 函数既能通过主机名获取IP地址(内部使用的是gethostbyname函数),也能通过服务名获取端口号(内部使用的是getservbyname函数).它是否可重入取决于内部调用的gethostbyname和getservbyname函数是否是他们的可重入版本. 该函数的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    @param hostname 可以接受主机名,也可以接收字符串表示的IP地址(IPv4采用点分十进制字符串, IPv6采用16进制字符串)</span><br><span class="line">    @param service 参数可以接受服务名也可以接受字符串表示的十进制端口号.hints参数是应用程序给getaddrinfo的一个提示,以对getaddrinfo的输出进行更精确的控制. hints参数可以被设置为NULL, 表示允许getaddrinfo反馈任何可用的结果.result参数指向一个链表, 该链表用于存储getaddrinfo反馈的结果.</span><br><span class="line">    getaddrinfo反馈的每一条结果都是addrinfo结构体类型的对象,结构体addrinfo的定义如下:</span><br><span class="line">    struct addrinfo &#123;</span><br><span class="line">        int ai_flags; //j</span><br><span class="line">        int ai_family //地址族</span><br><span class="line">        int ai_socktype; // 服务类型: SOCK_STREAM 或 SOCK_DGRAMj</span><br><span class="line">        int ai_protocol; // </span><br><span class="line">        socklen_t ai_addrlen; //socket地址 ai_addr的长度</span><br><span class="line">        char* ai_canonname;  //主机的别名</span><br><span class="line">        struct sockaddr* ai_addr; //指向socket地址</span><br><span class="line">        struct addrinfo* ai_next;  //指向下一个sockinfo结构的对象</span><br><span class="line">    &#125;;</span><br><span class="line">**/</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">int getaddrinfo(const char* hostname, const char* service, const struct addrinfo* hints, struct addrinfo** result);</span><br></pre></td></tr></table></figure></p>
<h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p>getnameinfo函数通过socket地址获取以字符串表示的主机名(内部使用的是gethostbyaddr)和服务名(内部使用getservbyport函数).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">int getnameinfo(const struct sockaddr* sockaddr, socklen_t addrlen, char* host, socklen_t hostlen, char* serv, socklen_t servlen, int flags);</span><br><span class="line">getnameinfo将返回的主机名存储在host参数指向的缓存中, 将服务名存储在serv参数指向的缓存中, hostlen和servlen参数分别指定这两块缓存的长度.</span><br><span class="line">flags参数控制getnameinfo的行为.</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="高级I-O函数"><a href="#高级I-O函数" class="headerlink" title="高级I/O函数"></a>高级I/O函数</h2><h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p>pipe函数用于创建管道, 以实现进程间通信.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pipe函数的参数是一个包含两个int型整数的数组指针. 该函数成功时返回0, 并将一对打开的文件描述符值填入其参数指向的数组. 如果失败, 则返回-1并设置errno.</span><br><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux高性能编程/" rel="tag"># linux高性能编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/07/写给大家看的设计书/" rel="next" title="写给大家看的设计书">
                <i class="fa fa-chevron-left"></i> 写给大家看的设计书
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/12/CMake简单教程/" rel="prev" title="CMake简单教程">
                CMake简单教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">brczo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-amp-ip"><span class="nav-text">tcp&amp;ip</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据链路层"><span class="nav-text">数据链路层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络层"><span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传输层"><span class="nav-text">传输层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用层"><span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket和tcp-ip协议族的关系"><span class="nav-text">socket和tcp/ip协议族的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket地址结构"><span class="nav-text">socket地址结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket地址api"><span class="nav-text">socket地址api</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#大端字节序与小端字节序"><span class="nav-text">大端字节序与小端字节序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通用socket地址"><span class="nav-text">通用socket地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#专用socket地址"><span class="nav-text">专用socket地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket-创建-命名…"><span class="nav-text">socket 创建 命名…</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建socket"><span class="nav-text">创建socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名socket"><span class="nav-text">命名socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#监听socket"><span class="nav-text">监听socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收连接"><span class="nav-text">接收连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发起连接"><span class="nav-text">发起连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭连接"><span class="nav-text">关闭连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket-数据读写"><span class="nav-text">socket 数据读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP数据读写"><span class="nav-text">TCP数据读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP数据读写"><span class="nav-text">UDP数据读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用数据读写函数"><span class="nav-text">通用数据读写函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址信息函数-socket选项"><span class="nav-text">地址信息函数 socket选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#地址信息函数"><span class="nav-text">地址信息函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-选项"><span class="nav-text">socket 选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络信息API-06"><span class="nav-text">网络信息API 06</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gethostbyname-和-gethostbyaddr"><span class="nav-text">gethostbyname 和 gethostbyaddr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getservbyname-和-getservbyport"><span class="nav-text">getservbyname 和 getservbyport</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getaddrinfo"><span class="nav-text">getaddrinfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getnameinfo"><span class="nav-text">getnameinfo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级I-O函数"><span class="nav-text">高级I/O函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pipe函数"><span class="nav-text">pipe函数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">brczo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
