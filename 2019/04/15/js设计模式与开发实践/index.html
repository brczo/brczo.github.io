<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="js设计模式与开发实践,">










<meta name="description" content="封装封装的目的是将信息隐藏，包括隐藏数据、实现细节、设计细节以及对象的类型。 封装数据js依赖变量的作用域来实现封装特性，而且只能模拟出public和private两种封装性12345678910var obj = (function()&amp;#123;    let _name = &amp;apos;jack&amp;apos;; // 私有（private）变量    return &amp;#123;">
<meta name="keywords" content="js设计模式与开发实践">
<meta property="og:type" content="article">
<meta property="og:title" content="js设计模式与开发实践">
<meta property="og:url" content="brczo.github.io/2019/04/15/js设计模式与开发实践/index.html">
<meta property="og:site_name" content="进化">
<meta property="og:description" content="封装封装的目的是将信息隐藏，包括隐藏数据、实现细节、设计细节以及对象的类型。 封装数据js依赖变量的作用域来实现封装特性，而且只能模拟出public和private两种封装性12345678910var obj = (function()&amp;#123;    let _name = &amp;apos;jack&amp;apos;; // 私有（private）变量    return &amp;#123;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/images/组合模式.png">
<meta property="og:image" content="/images/对象与对象之间紧耦合.png">
<meta property="og:image" content="/images/中介者模式.png">
<meta property="og:updated_time" content="2019-12-04T12:36:19.703Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js设计模式与开发实践">
<meta name="twitter:description" content="封装封装的目的是将信息隐藏，包括隐藏数据、实现细节、设计细节以及对象的类型。 封装数据js依赖变量的作用域来实现封装特性，而且只能模拟出public和private两种封装性12345678910var obj = (function()&amp;#123;    let _name = &amp;apos;jack&amp;apos;; // 私有（private）变量    return &amp;#123;">
<meta name="twitter:image" content="/images/组合模式.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="brczo.github.io/2019/04/15/js设计模式与开发实践/">





  <title>js设计模式与开发实践 | 进化</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">进化</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/15/js设计模式与开发实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js设计模式与开发实践</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T11:04:50+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装的目的是将信息隐藏，包括隐藏数据、实现细节、设计细节以及对象的类型。</p>
<h3 id="封装数据"><a href="#封装数据" class="headerlink" title="封装数据"></a>封装数据</h3><p>js依赖变量的作用域来实现封装特性，而且只能模拟出public和private两种封装性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = (function()&#123;</span><br><span class="line">    let _name = &apos;jack&apos;; // 私有（private）变量</span><br><span class="line">    return &#123;</span><br><span class="line">        getName: function()&#123;  // 公开（public）方法</span><br><span class="line">            return _name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(obj.getName()); //输出：jack</span><br><span class="line">console.log(obj._name); // 输出：undefined</span><br></pre></td></tr></table></figure></p>
<h3 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h3><p>封装实现使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对他自己的行为负责。其他对象或用户不关心它的内部实现。</p>
<h3 id="封装类型"><a href="#封装类型" class="headerlink" title="封装类型"></a>封装类型</h3><p>封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口 来进行的1。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象 的行为。在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生 5 的原因之一。比如工厂方法模式、组合模式等。</p>
<h3 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h3><p>从设计模式 的角度出发，封装在更重要的层面体现为封装变化。设计模式可分为：</p>
<ul>
<li>创建型模式 目的是封装创建对象的变化</li>
<li>结构型模式 封装对象之间的组合关系</li>
<li>行为型模式 封装对象的行为变化</li>
</ul>
<h2 id="原型模式与基于原型的继承"><a href="#原型模式与基于原型的继承" class="headerlink" title="原型模式与基于原型的继承"></a>原型模式与基于原型的继承</h2><h3 id="原型编程思想"><a href="#原型编程思想" class="headerlink" title="原型编程思想"></a>原型编程思想</h3><p>在以类为中心的面向对象编程语言中，类和对象关系可以想象成铸模与铸件的关系，对象总是从类中创建而来。而在原型编程思想中，类不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。<br>原型模式不单是一种设计模式，也被称为一种编程范型。</p>
<h3 id="使用克隆的原型模式"><a href="#使用克隆的原型模式" class="headerlink" title="使用克隆的原型模式"></a>使用克隆的原型模式</h3><p>ECMAScript5使用了Object.create方法，可以用来克隆对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Plane = function()&#123;</span><br><span class="line">    this.blood = 100;</span><br><span class="line">    this.attackLevel = 1;</span><br><span class="line">    this.defenseLevel = 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var plane = new Plane();</span><br><span class="line">plane.blood = 500;</span><br><span class="line">plane.attackLevel = 10;</span><br><span class="line">plane.defenseLevel = 7;</span><br><span class="line"></span><br><span class="line">var clonePlane = Object.create(plane); //克隆对象</span><br></pre></td></tr></table></figure></p>
<h3 id="克隆是创建对象的手段"><a href="#克隆是创建对象的手段" class="headerlink" title="克隆是创建对象的手段"></a>克隆是创建对象的手段</h3><h4 id="体验io语言"><a href="#体验io语言" class="headerlink" title="体验io语言"></a>体验io语言</h4><p>原型不仅仅是一种设计模式还是一种编程范型。js就是使用原型模式来搭建整个面向对象的系统的。<br>基于根对象，创建一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io&gt; Animal := Object clone;</span><br><span class="line">Animal makeSound := method(&quot;animal makeSound&quot; print);</span><br></pre></td></tr></table></figure></p>
<p>基于Animal对象创建一个Dog对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io&gt; Dog := Animal clone;</span><br><span class="line">Dog eat := method(&quot;dog eat&quot; printf);</span><br></pre></td></tr></table></figure></p>
<p>原型链<br>Object是Animal的原型，而Animal是Dog的原型，他们之间构成一条原型链。</p>
<h3 id="js中的原型继承"><a href="#js中的原型继承" class="headerlink" title="js中的原型继承"></a>js中的原型继承</h3><p><strong>所有数据都是对象。</strong>按照js设计者的本意， 除了undefined之外，js中一切都是对象。js中的根对象是Object.prototype。Object.prototype是一个空对象。我们遇到的每个对象其实都是从Object.prototype对象克隆而来。Object.prototype对象就是他们的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = &#123;&#125;;</span><br><span class="line">console.log(Object.getPrototypeOf(obj1) === Object.prototype ); //输出： true</span><br><span class="line">console.log(Object.getPrototypeOf(obj2) === Object.prototype ); //输出： true</span><br></pre></td></tr></table></figure>
<p><strong>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = new Person(&quot;jack&quot;);</span><br><span class="line">console.log(a.name); //输出jack</span><br><span class="line">console.log(a.getName); //输出jack</span><br><span class="line">console.log(Object.getPrototypeOf(a) === Person.prototype); //输出：true</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，<strong>Person不是类，而是函数构造</strong>，js中的函数既可以作为普通函数使用，也可以作为构造器被调用。用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype对象，在进行额外的操作。<strong>对象会记住它的原型</strong>。js给对象提供了一个名为<strong>proto</strong>的隐藏属性，某个对象的<strong>proto</strong>属性默认会指向它的构造器的原型对象。在Chrome中，<strong>proto</strong>会被公开出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = new Object();</span><br><span class="line">console.log(a.__proto__ === Object.prototype); 输出 true</span><br></pre></td></tr></table></figure></p>
<p><strong>如果某个对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</strong>这条是原型继承的精髓。原型继承方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name: &apos;jack&apos;&#125;;</span><br><span class="line">var A = function()&#123;&#125;;</span><br><span class="line">A.prototype = obj;</span><br><span class="line"></span><br><span class="line">var a = new A();</span><br><span class="line">console.log(a.name); //输出： jack</span><br></pre></td></tr></table></figure></p>
<p>以上代码中，引擎做了哪些：</p>
<ul>
<li>首先尝试遍历对象a中的所有属性，但没有找到name这个属性</li>
<li>查找name属性的这个请求被委托给对象a的构造器的原型，它被a.<strong>proto</strong>记录着，指向A.protype,而A.prototype被设置为对象obj</li>
<li>在obj对象中找到了name属性，并返回它的值。</li>
</ul>
<h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><h3 id="this的种类"><a href="#this的种类" class="headerlink" title="this的种类"></a>this的种类</h3><ul>
<li>作为对象的方法调用</li>
<li>作为普通的函数调用</li>
<li>构造器调用</li>
<li>Function.prototype.call 或 Function.prototype.apply调用</li>
</ul>
<h3 id="作为对象的调用"><a href="#作为对象的调用" class="headerlink" title="作为对象的调用"></a>作为对象的调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    getA: function()&#123;</span><br><span class="line">        console.log(this === obj); //输出true</span><br><span class="line">        console.log(this.a); //输出1</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure>
<h3 id="作为普通函数的调用"><a href="#作为普通函数的调用" class="headerlink" title="作为普通函数的调用"></a>作为普通函数的调用</h3><p>执行getName函数时，函数内没有那么属性，js引擎沿着作用域链向上查找name属性，直到最顶端的window对象，有则输出，无则输出undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.name = &apos;globalName&apos;;</span><br><span class="line">var getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(getName()); //输出globalName</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.name = &apos;globalName&apos;;</span><br><span class="line">var myObj = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var getName = myObj.getName; </span><br><span class="line">console.log(getName()); //输出：globalName</span><br></pre></td></tr></table></figure></p>
<p>有时，我们会遇到一些困扰，比如在div节点的事件函数内部，有一个局部的callback方法，callback被作为普通函数调用时，callback内部的this指向了window，但我们往往是想让它指向该div节点，见如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;div1&quot;&gt;我是一个div&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.id = &apos;window&apos;;</span><br><span class="line">        document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">            console.log(this.id); //输出：&apos;div1&apos;</span><br><span class="line">            var callback = function()&#123;</span><br><span class="line">                console.log(this.id);  //输出：window</span><br><span class="line">            &#125;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>解决方法是通过闭包将节点保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">    console.log(this.id); //输出：&apos;div1&apos;</span><br><span class="line">    var _self = this;</span><br><span class="line">    var callback = function()&#123;</span><br><span class="line">        console.log(_self.id);  //输出：window</span><br><span class="line">    &#125;</span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在严格模式下（”use strict”），这种情况下this是undefined</p>
<h3 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myClass = function()&#123;</span><br><span class="line">    this.name = &apos;jack&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var obj = new myClass();</span><br><span class="line">console.log(obj.name); //输出 jack</span><br></pre></td></tr></table></figure>
<p>用new调用构造器需注意一个问题，如果构造器显式的返回一个obj类型，那么此次运行结果最终会返回这个对象，而不是我们之前期待的this：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myClass = function()&#123;</span><br><span class="line">    this.name = &apos;jack&apos;;</span><br><span class="line">    return &#123; //显示的返回一个对象</span><br><span class="line">        name: &apos;marry&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var obj = new myClass();</span><br><span class="line">console.log(obj.name); //输出：marry</span><br></pre></td></tr></table></figure></p>
<h3 id="all或apply调用"><a href="#all或apply调用" class="headerlink" title="all或apply调用"></a>all或apply调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    name: &apos;marry&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj1.getName()); //输出：Jack</span><br><span class="line">console.log(obj1.getName.call(obj2)); //输出 marry</span><br></pre></td></tr></table></figure>
<h3 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    myName: &apos;jack&apos;,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        return this.myName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.getName()); //输出：jack</span><br><span class="line">var getName2 = obj.getName;</span><br><span class="line">console.log(getName2()); //输出 undefined</span><br></pre></td></tr></table></figure>
<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Function.prototype.call和Function.prototype.apply都是非常常用的方法。它们的作用一模一样，区别在于传入参数形式的不同。<br>apply接受两个参数，第一个指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，zpply方法把这个集合中的元素作为参数传递给被调用函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a, b ,c)&#123;</span><br><span class="line">    alert([a,b,c]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.apply(null, [1,2,3]);</span><br></pre></td></tr></table></figure></p>
<p>call传入的参数不固定，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a,b,c)&#123;</span><br><span class="line">    alert([a,b,c]);</span><br><span class="line">&#125;</span><br><span class="line">func.call(null, 1, 2, 3);</span><br></pre></td></tr></table></figure></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul>
<li><p>改变this的指向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    name: &apos;amme&apos;</span><br><span class="line">&#125;;</span><br><span class="line">window.name = &apos;window&apos;;</span><br><span class="line">var getName = function()&#123;</span><br><span class="line">    alter(this.name);</span><br><span class="line">&#125;</span><br><span class="line">getName(); // 输出window</span><br><span class="line">getName.call(obj1);//输出 jack</span><br><span class="line">getName.call(obj2);//输出 amme</span><br></pre></td></tr></table></figure>
</li>
<li><p>修正this的指向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">    alert(this.id); //输出 div1</span><br><span class="line">    var func = function()&#123;</span><br><span class="line">        alert(this.id); //输出：undefined</span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在事件内部调用func函数时，func函数体内的this指向了window，而不是我们预期的div，这时候我们要用call或apply修正<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">    alert(this.id); //输出 div1</span><br><span class="line">    var func = function()&#123;</span><br><span class="line">        alert(this.id); //输出：undefined</span><br><span class="line">    &#125;</span><br><span class="line">    func.call(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h3><p>大部分高级浏览器都实现了内置的Function.prototype.bind，用来指定函数内部的this指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context) &#123;</span><br><span class="line">    var self = this; //保存原函数</span><br><span class="line">    return function()&#123; //返回一个新的函数</span><br><span class="line">        return self.apply(context, arguments); //执行新的函数的时候，会把之前传入的context当作新函数体内的this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;jack&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var func = function()&#123;</span><br><span class="line">    alert(this.name); //输出： jack</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p>
<h3 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h3><p>借用构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var A = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = function()&#123;</span><br><span class="line">    A.apply(this, arguments);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.prototype.getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var b = new B(&apos;jack&apos;);</span><br><span class="line">console.log(b.getName()); //输出 ‘jack&apos;</span><br></pre></td></tr></table></figure></p>
<p>使用Array.prototype.push.call<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    Array.prototype.push.call(arguments, 3);</span><br><span class="line">    console.log(arguments); //输出 【1, 2, 3]</span><br><span class="line">&#125;)(1,2)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>变量有作用域和生存周期，如果函数内的变量在函数执行完后没有被销毁，这就产生了闭包 </p>
<ul>
<li>变量的作用域。变量的作用域指的是变量的有效范围</li>
<li>变量的生存周期。全局变量，局部变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function()&#123;</span><br><span class="line">    var a = 1; //退出函数后局部变量a将被销毁</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var func = function()&#123; //闭包，函数执行完后变量未被销毁</span><br><span class="line">		var a = 1;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        a++;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var f = func();</span><br><span class="line">f(); //输出：2</span><br><span class="line">f(); //输出：3</span><br><span class="line">f(); //输出：4÷</span><br></pre></td></tr></table></figure>
<p>经典应用，js的onclick事件是异步的，是在for循环后执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;3&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;4&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var nodes = document.getElementsByTagName(&apos;div&apos;);</span><br><span class="line">        //不使用闭包</span><br><span class="line">        for(var i = 0, len = nodes.length; i &lt; len; i ++)&#123;</span><br><span class="line">            nodes[i].onclick = function()&#123;</span><br><span class="line">                console.log(i); //全部输出5</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用闭包</span><br><span class="line">        for(var i = 0, len = nodes.length; i &lt; len; i ++)&#123;</span><br><span class="line">            (funcion(i)&#123;</span><br><span class="line">                nodes[i].onclick = function()&#123;</span><br><span class="line">                    console.log(i); //全部输出 0,1,2,3,4</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="封装变量"><a href="#封装变量" class="headerlink" title="封装变量"></a>封装变量</h3><p>闭包可以把一些不需要暴露在全局的变量封装成私有变量，假设有一个计算乘积的简单函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var mult = function()&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; 1; i++)&#123;</span><br><span class="line">        a = a * arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>mult函数接受一些number类型的参数，并返回这些参数类型的乘积。现在我们觉得对于那么相同的参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var cache = &#123;&#125;;</span><br><span class="line">var mult = function()&#123;</span><br><span class="line">    var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">    if(cache[args])&#123;</span><br><span class="line">        return cache[args];</span><br><span class="line">    &#125;</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">        a = a * arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return cache[args] = a;</span><br><span class="line">&#125;;</span><br><span class="line">alert(mult(1,2,3)); //输出6</span><br><span class="line">alert(mult(1,2,3)); //输出6</span><br></pre></td></tr></table></figure></p>
<p>我们看到这个变量仅仅在mult函数中被使用，我们可以通过使用闭包将变量放到函数内部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var mult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        var a = 1;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            a = a * arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>提炼函数是代码重构中的一种常见技巧。如果在一个大函数中，有一些代码能够独立出来，我们常常把这些代码封装在独立的小函数里面。独立出来的小函数有利于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把他们用闭包封闭起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var mult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    var calculate = function()&#123; //封闭calculate函数÷</span><br><span class="line">        var a = 1;</span><br><span class="line">        for (var i = 0, l = arguments.length; i &lt; l; i ++) &#123;</span><br><span class="line">            a = a * arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = calculate.apply(null, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h3 id="延续局部变量的寿命"><a href="#延续局部变量的寿命" class="headerlink" title="延续局部变量的寿命"></a>延续局部变量的寿命</h3><p>img对象经常用于进行数据上报，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var report = function(src) &#123;</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">&#125;;</span><br><span class="line">report( &apos;http://xxx.com/getUserInfo&apos; );</span><br></pre></td></tr></table></figure></p>
<p>但是有些情况下，report函数并不是每一次都成功发起了http请求。丢失数据的原因是img是report函数的局部变量，当report调用结束后，img局部变量随即被销毁，而此时或许还没来得及发出http请求。现在我们把img变量用闭包封闭起来，便能解决请求丢失的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var report = (function()&#123;</span><br><span class="line">    var imgs = [];</span><br><span class="line">    return function(src)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        imgs.push(img);</span><br><span class="line">        imgs.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包和面向对象设计"><a href="#闭包和面向对象设计" class="headerlink" title="闭包和面向对象设计"></a>闭包和面向对象设计</h3><p>过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var extent = function()&#123;</span><br><span class="line">    var value = 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        call: function()&#123;</span><br><span class="line">            value++;</span><br><span class="line">            console.log(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var extent = extent();</span><br><span class="line">extent.call(); //输出 1</span><br><span class="line">extent.call(); //输出 2</span><br></pre></td></tr></table></figure></p>
<p>如果换成面向对象的写法，就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var extent = &#123;</span><br><span class="line">    value: 0,</span><br><span class="line">    call: function()&#123;</span><br><span class="line">        this.value ++;</span><br><span class="line">        console.log(this.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var extent = function()&#123;</span><br><span class="line">    this.value = 0;</span><br><span class="line">&#125;;</span><br><span class="line">extent.prototype.call = function()&#123;</span><br><span class="line">    this.value ++;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">var extent = new extent();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br></pre></td></tr></table></figure></p>
<h3 id="用闭包实现命令模式"><a href="#用闭包实现命令模式" class="headerlink" title="用闭包实现命令模式"></a>用闭包实现命令模式</h3><p>命令模式的意思是把请求封装为对象，从而分离请求的发起者和请求的接受者（执行者）之间的耦合关系。在命令执行前，可以预先往命令对象植入命令的接受者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button id=&quot;execute&quot;&gt;点击我执行命令&lt;/button&gt;</span><br><span class="line">        &lt;button id=&quot;undo&quot;&gt;点击我执行命令&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var Tv = &#123;</span><br><span class="line">            open: function()&#123;</span><br><span class="line">                console.log(&apos;打开电视机&apos;);</span><br><span class="line">            &#125;,</span><br><span class="line">            close: function()&#123;</span><br><span class="line">                console.log(&apos;关上电视机&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        var openTvCommand = function(receiver)&#123;</span><br><span class="line">            this.receiver = receiver;</span><br><span class="line">        &#125;;</span><br><span class="line">        openTvCommand.prototype.execute = function()&#123;</span><br><span class="line">            this.receiver.open(); //执行命令， 打开电视机</span><br><span class="line">        &#125;;</span><br><span class="line">        openTvCommand.prototype.undo = function()&#123;</span><br><span class="line">            this.receiver.close();//撤销命令，关闭电视机</span><br><span class="line">        &#125;;</span><br><span class="line">        var setCommand = function(command)&#123;</span><br><span class="line">            document.getElementById(&apos;execute&apos;).onclick = function()&#123;</span><br><span class="line">                command.execute(); //输出：打开电视机</span><br><span class="line">            &#125;;</span><br><span class="line">            document.getElementById(&apos;undo&apos;).onclick = function()&#123;</span><br><span class="line">                command.undo();  //关闭电视机 </span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        setCommand(new openTvCommand(Tv));</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h3><p>闭包与内存泄漏的关系是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏。但这本省并非必报的问题，也并非js的问题。在IE浏览器中，由于BOM和DOM的对象是使用c++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null 即可。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运 行时，就会删除这些值并回收它们占用的内存。<br>不如，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function handle()&#123;</span><br><span class="line">    var element = document.getElementById(&apos;div&apos;);</span><br><span class="line">    element.onclick = function()&#123;</span><br><span class="line">        console.log(element.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数中给element的onclick属性赋值了一个闭包，闭包要访问element的id属性。闭包在js中也是对象，函数即对象。闭包会持有外部传入的变量，因此闭包持有了element对象，而element对象通过onclick属性持有了闭包，因此两个对象相互持有，造成内存泄漏。</p>
<p>解决方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function handle()&#123;</span><br><span class="line">    var element = document.getElementById(&apos;div&apos;);</span><br><span class="line">    var id = element.id;</span><br><span class="line">    element.onclick = function()&#123;</span><br><span class="line">        console.log(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时element对象持有id，不再是element。</p>
<h2 id="高阶函数的概念和应用"><a href="#高阶函数的概念和应用" class="headerlink" title="高阶函数的概念和应用"></a>高阶函数的概念和应用</h2><p>高阶函数是至少满足下列条件之一的函数：</p>
<ul>
<li>函数可以作为参数被传递</li>
<li>函数可以作为返回值输出</li>
</ul>
<h3 id="函数最为参数传递"><a href="#函数最为参数传递" class="headerlink" title="函数最为参数传递"></a>函数最为参数传递</h3><p>把函数作为参数传递，这代表我们可以抽离一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个常见的重要的应用场景是常见的回掉函数。</p>
<h3 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h3><h4 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h4><p>AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来后，再通过“动态织入”的方式掺入业务逻辑模块中。这样的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。<br>通常，在js中实现AOP，都是指把一个函数“动态织入”到另一个函数之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before = function(beforefn)&#123;</span><br><span class="line">    var _self = this; //保存原函数的引用</span><br><span class="line">    return function() &#123;</span><br><span class="line">        beforefn.apply(this, arguments); //执行新函数，修正this 防止this丢失</span><br><span class="line">        return _self.apply(this, arguments); // 执行原函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Function.prototype.after = function(afterfn)&#123;</span><br><span class="line">    var _self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var ret = _self.apply(this, arguments);</span><br><span class="line">        afterfn.apply(this, arguments);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func = function() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func = func.before(function()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;).after(function()&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>curring又称部分求值。一个curring的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。<br>编写一个计算每月开销的函数。在每天结束之前，我们都要记录今天花掉了多少钱。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var monthlyCost = 0;</span><br><span class="line">var cost = function(money)&#123;</span><br><span class="line">    monthlyCost += money;</span><br><span class="line">&#125;;</span><br><span class="line">cost(100); //第一天开销</span><br><span class="line">cost(200); //第二天开销</span><br><span class="line">cost(300); //第三天开销</span><br><span class="line">console.log(monthlyCost);// 输出：600</span><br></pre></td></tr></table></figure></p>
<p>上面的代码计算了今天为止花了多少钱。但我们只想知道月底花了多少钱。也就是说，只需在月底计算一次。如果在每个月的前29天，我们都只是保存好当天的开销，知道第30天才进行求值计算。虽然下面的函数还不是currying函数的完整实现，但有助于我们了解其思想：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var cost = (function()&#123;</span><br><span class="line">    var args = [];</span><br><span class="line">    return = function()&#123;</span><br><span class="line">        if(arguments.length === 0)&#123;</span><br><span class="line">            var money = 0;</span><br><span class="line">            for(var i = 0, l = args.length; i &lt; l; i++)&#123;</span><br><span class="line">                money += args[i];</span><br><span class="line">            &#125;</span><br><span class="line">            return money;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            [].push.apply(args, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line">cost(200); //未真正求值</span><br><span class="line">cost(300); //未真正求值</span><br><span class="line">console.log(cost()); //求值并输出：600</span><br></pre></td></tr></table></figure></p>
<p>编写一个通用的currying函数，它接受一个参数，即将要被curring的函数。在这个例子里，这个函数的作用遍历本月每天的开销并求出它们的总和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var curring = function(fn)&#123;</span><br><span class="line">    var args = [];</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(arguments.length === 0)&#123;</span><br><span class="line">            return fn.apply(this, args);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            [].push.apply(args, arguments);</span><br><span class="line">            return arguments.callee;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var cost = (function()&#123;</span><br><span class="line">    var money = 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            money += arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">var cost = currying(cost);  //转化成currying函数</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line"></span><br><span class="line">console.log(cost()); //求值并输出：600</span><br></pre></td></tr></table></figure></p>
<h3 id="函数节流-分时函数"><a href="#函数节流-分时函数" class="headerlink" title="函数节流 分时函数"></a>函数节流 分时函数</h3><h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><p>函数在有些情况下不是被用户主动频繁调用</p>
<ul>
<li>window.onresize事件</li>
<li>mousemove事件</li>
<li>上传进度。</li>
</ul>
<p>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(fn, interval)&#123;</span><br><span class="line">    var _self = fn, //保存需要被延迟执行的函数引用 </span><br><span class="line">        timer, //定时器</span><br><span class="line">        firstTime = true; //是否是第一次调用 </span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = arguments,</span><br><span class="line">            _me = this;</span><br><span class="line">        if(firstTime)&#123;  //如果是第一次调用，不需要延迟执行</span><br><span class="line">            _self.apply(_me, args);</span><br><span class="line">            return firstTime = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(timer) &#123;  //如果定时器还在，说明前一次延迟执行还没有完成</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(function()&#123; //延迟一段时间执行</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = null;</span><br><span class="line">            _self.apply(_me, args);</span><br><span class="line">        &#125;, interval || 500);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">window.onresize = throttle(function()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;, 500);</span><br></pre></td></tr></table></figure></p>
<h4 id="分时函数"><a href="#分时函数" class="headerlink" title="分时函数"></a>分时函数</h4><p>函数是用户主动调用的，函数影响了页面性能<br>比如创建WebQQ的QQ好友列表。列表中通常会有成百上千个好友，如果一个好友用一个节点来表示，当我们在页面中渲染这个列表的时候，可能要一次性往页面中创建成败上千个节点。这样做和可能造成浏览器卡顿。代码如下 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for(var i = 1; i &lt;= 1000; i++)&#123;</span><br><span class="line">    arr.push(i); //假设arr装载了1000个好友的数据</span><br><span class="line">&#125;</span><br><span class="line">var renderFriendList = function(data)&#123;</span><br><span class="line">    for(var i = 0, l = data.length; i &lt; l; i++)&#123;</span><br><span class="line">        var div = document.createElement(&apos;div&apos;);</span><br><span class="line">        div.innerHTML = i;</span><br><span class="line">        document.body.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">rederFriendList(arr);</span><br></pre></td></tr></table></figure>
<p>解决方案一： 使用timeChunk函数让创建节点的工作分批进行，比如把1秒钟创建1000个节点，改为每隔200毫秒创建8个节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">第一个参数是创建节点时需要用到的数据，第二个参数是封装了创建节点逻辑的函数</span><br><span class="line">，第三个参数表示每一批创建的节点数量。</span><br><span class="line">var timeChunk = function(arr, fn, count)&#123;</span><br><span class="line">    var obj,</span><br><span class="line">        t;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var start = function()&#123;</span><br><span class="line">        for(var i = 0; i &lt; Math.min(count || 1, arr.length); i++;)&#123;</span><br><span class="line">            var obj = arr.shift();</span><br><span class="line">            fn(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        t = setInterval(function()&#123;</span><br><span class="line">            if(arr.length === 0)&#123; //如果全部节点都已经被创建好</span><br><span class="line">                return clearInterval(t);</span><br><span class="line">            &#125;</span><br><span class="line">            start();</span><br><span class="line">        &#125;, 200); //分批执行的时间间隔</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用timeChunk函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for(var i = 1; i &lt;= 1000; i++)&#123;</span><br><span class="line">    arr.push(i);</span><br><span class="line">&#125;</span><br><span class="line">var renderFriendList = timeChunk(arr, function(n)&#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = n;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;, 8)</span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例只有一个对象，支持全局访问。</p>
<h3 id="不透明的单例模式"><a href="#不透明的单例模式" class="headerlink" title="不透明的单例模式"></a>不透明的单例模式</h3><p>Singleton 类的使用者必须知道这是一个单例类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var Singleton = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.instance = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton.prototype = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = function(name) &#123;</span><br><span class="line">    if(!this.instance) &#123;</span><br><span class="line">        this.instance = new Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    return this.instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = Singleton.getInstance(&apos;jack1&apos;);</span><br><span class="line">var b = Singleton.getInstance(&apos;jack2&apos;);</span><br><span class="line"></span><br><span class="line">console.log(a === b);</span><br></pre></td></tr></table></figure>
<p>或者,使用闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Singleton = function(name)&#123; //相当于构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton.prototype.getInstance = (function()&#123;</span><br><span class="line">    var instance = null;</span><br><span class="line">    return function(name)&#123;</span><br><span class="line">        if(!instance)&#123;</span><br><span class="line">            instance = new Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="透明的单例模式"><a href="#透明的单例模式" class="headerlink" title="透明的单例模式"></a>透明的单例模式</h3><p>使用CreateDiv单例类，作用是在页面中创建唯一的div节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var CreateDiv = (function()&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    var CreateDiv = function(html)&#123;</span><br><span class="line">        if(instance)&#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">        this.html = html;</span><br><span class="line">        this.init();</span><br><span class="line">        return instance = this;</span><br><span class="line">    &#125;</span><br><span class="line">    CreateDiv.prototype.init = function()&#123;</span><br><span class="line">        var div = document.createElement(&apos;div&apos;);</span><br><span class="line">        div.innerHTML = this.html;</span><br><span class="line">        document.body.appendChild(div);</span><br><span class="line">    &#125;;</span><br><span class="line">    return CreateDiv;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a = new CreateDiv(&apos;jack1&apos;);</span><br><span class="line">var b = new CreateDiv(&apos;jack2&apos;);</span><br><span class="line">console.log(a === b); //true</span><br></pre></td></tr></table></figure>
<p>用代理模式实现单例 把负责管理单例的代码移除出去，使它成为一个普通的创建div的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var createDiv = function(html)&#123;</span><br><span class="line">    this.html = html;</span><br><span class="line">    this.init();</span><br><span class="line">&#125;;</span><br><span class="line">createDiv.prototype.init = function()&#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;;</span><br><span class="line">var ProxySingletonCreateDiv = (function()&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    return funtion(html)&#123;</span><br><span class="line">        if(!instance)&#123;</span><br><span class="line">            instance = new CreateDiv(html);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;)();</span><br><span class="line">var a = new ProxySingletonCreateDiv(&apos;jack1&apos;);</span><br><span class="line">var b = new ProxySingletonCreateDiv(&apos;jack2&apos;);</span><br><span class="line">console.log(a === b);</span><br></pre></td></tr></table></figure></p>
<p>有时候我们会使用全局变量来实现单例。但是考虑到命名污染，我们需要采取措施避免：</p>
<ol>
<li>使用命名空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var namespace = &#123;</span><br><span class="line">    a: function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    b: function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用闭包封装私有变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user = (function()&#123;</span><br><span class="line">    var _name = &apos;sven&apos;,</span><br><span class="line">        _age = 29;</span><br><span class="line">    return &#123;</span><br><span class="line">        getUserInfo: function()&#123;</span><br><span class="line">            return _name + &apos;-&apos; + _age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我们用下划线来约定私有变量_name和_age，它们被封装在闭包产生的作用域中，这就避免了全局污染。</p>
<h2 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h2><p>惰性单例是指在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用，有用的程度超出我们的想象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button id=&quot;login&quot;&gt;登陆&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var createDiv = function()&#123;</span><br><span class="line">        var div;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            if(!div)&#123;</span><br><span class="line">                div = document.createElement(&apos;div&apos;);</span><br><span class="line">                div.innerHTML = &apos;我是浮框&apos;;</span><br><span class="line">                document.body.appendChild(div);</span><br><span class="line">                return div;</span><br><span class="line">            &#125;</span><br><span class="line">            return div;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    document.getELementById(&apos;login&apos;).onclick = function()&#123;</span><br><span class="line">        var div = createDiv();</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="通用惰性加载"><a href="#通用惰性加载" class="headerlink" title="通用惰性加载"></a>通用惰性加载</h3><p>上面的代码有以下问题：</p>
<blockquote>
<p>这段代码仍然违反单一职责原则，创建对象和管理单例的逻辑都放在createDiv对象内<br>如果我们下次需要创建页面中唯一的iframe，或者script标签，用来跨域请求数据，就必须得如法炮制，把createDiv几乎抄一遍。<br>我们可以把不变的部分隔离出来，先不考虑创建一个div和创建一个iframe有多少差异，管理单例的逻辑其实是完全可以抽象出来的，这个逻辑始终是一样的：用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj;</span><br><span class="line">if(!ob) &#123;</span><br><span class="line">    obj = xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>现在我们就把如何管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在getSingle函数内部，创建对象的方法fn被当成参数动态传入getSingle函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var getSingle = function(fn)&#123;</span><br><span class="line">    var result;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return result || (result = fn.apply(this.arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来将用于创建div的方法用参数fn的形式闯入getSingle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var createDiv = function() &#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = &apos;我是div&apos;;</span><br><span class="line">    return div;</span><br><span class="line">&#125;;</span><br><span class="line">var createSingleDiv =  getSingle(createDiv);</span><br><span class="line">document.getElementById(&apos;login&apos;).onclick = function()&#123;</span><br><span class="line">    var login = createSingleDiv();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种单例模式远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定click事件，如果是通过ajax动态往列表里追加数据，在使用事件代理的前提下，click事件实际上只需要在第一次渲染列表的时候被绑定一次，但是我们不想去判断当前是否是第一次渲染列表，如果借助于jq，我们通常选择给节点绑定one事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var bindEvent = function()&#123;</span><br><span class="line">//one 事件： 处理函数在每个元素上每种事件类型最多执行一次</span><br><span class="line">    $(&apos;div&apos;).one(&apos;click&apos;, function()&#123; </span><br><span class="line">        console.log(&apos;click&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var render = function()&#123;</span><br><span class="line">    console.log(&apos;开始);</span><br><span class="line">    bindEvent();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render();</span><br><span class="line">render();</span><br><span class="line">render();</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="使用策略模式计算奖金"><a href="#使用策略模式计算奖金" class="headerlink" title="使用策略模式计算奖金"></a>使用策略模式计算奖金</h3><p>绩效为S的年终奖有4倍工资，绩效为A的3倍工资，绩效为B的2倍工资。</p>
<ul>
<li>最初的实现代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var calculateBonus = function(performanceLevel, salary)&#123;</span><br><span class="line">    if(performanceLevel === &apos;S&apos;)&#123;</span><br><span class="line">        return salary * 4;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;A&apos;)&#123;</span><br><span class="line">        return salary * 3;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;B&apos;)&#123;</span><br><span class="line">        return salary * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculateBonus(&apos;B&apos;, 20000); //输出： 40000</span><br><span class="line">calculateBonus(&apos;S&apos;, 6000); //输出： 24000</span><br></pre></td></tr></table></figure>
<p>calculateBonus函数的缺点：</p>
<blockquote>
<p>calculateBonus函数比较庞大，包含了很多if-else语句，这些语句需要覆盖所有的逻辑分支。<br>calculateBonus函数缺乏弹性，如果增加了一种新的绩效等级C，或者想把绩效S的奖金系数改为5，<br>那么我们必须深入calculateBonus函数的内部实现，这是违反开放-封闭原则的。<br>算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们只有粘贴复制</p>
</blockquote>
<ul>
<li>使用组合函数重构代码  缺点： 函数依据很庞大</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var performanceS = function()&#123;</span><br><span class="line">    return salary * 4;</span><br><span class="line">&#125;;</span><br><span class="line">var performanceA = function()&#123;</span><br><span class="line">    return salary * 3;</span><br><span class="line">&#125;;</span><br><span class="line">var performanceB = function(salary)&#123;</span><br><span class="line">    return salary * 2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var calculateBonus = function(performanceLevel, salary)&#123;</span><br><span class="line">    if(performanceLevel === &apos;S&apos;)&#123;</span><br><span class="line">        return performanceS(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;A&apos;)&#123;</span><br><span class="line">        return performanceA(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;B&apos;)&#123;</span><br><span class="line">        return performanceB(salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculateBonus(&apos;A&apos;, 1000); // 3000</span><br></pre></td></tr></table></figure>
<ul>
<li>使用策略模式重构代码，一个基于策略模式的程序至少由两部分组成：</li>
</ul>
<blockquote>
<p>第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。<br>第二个部分是环境类Context，Context接受客户的请求，随后将请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。</p>
</blockquote>
<ul>
<li>版本一： 用传统的面向对象语言的方式，把每种绩效的计算规则都封装在对应的策略类里面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var performanceS = function()&#123;&#125;;</span><br><span class="line">performanceS.prototype.calculate = function(salary)&#123;</span><br><span class="line">    return salary * 4;</span><br><span class="line">&#125;;</span><br><span class="line">var performanceA = function()&#123;&#125;;</span><br><span class="line">performanceA.prototype.calculate = function(salary)&#123;</span><br><span class="line">    return salary * 3;</span><br><span class="line">&#125;;</span><br><span class="line">var performanceB = function()&#123;&#125;;</span><br><span class="line">performanceB.prototype.calculate = function(salary)&#123;</span><br><span class="line">    return salary * 2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来定义奖金类Bonus：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var Bonus = function()&#123;</span><br><span class="line">    this.salary = null; //原始工资</span><br><span class="line">    this.strategy = null; //绩效等级对应的策略对象</span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setSalary = function(salary)&#123;</span><br><span class="line">    this.salary = salary; //设置员工的原始工资</span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setStrategy = function(strategy) &#123;</span><br><span class="line">    this.strategy = strategy; //设置员工绩效等级对应的策略对象</span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.getBonus = function()&#123; //取得奖金数额 </span><br><span class="line">    return this.strategy.calculate(this.salary); //把计算奖金的操作委托给对应的策略对象</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bonus = new Bonus;</span><br><span class="line">bonus.setSalary(1000);</span><br><span class="line">bonus.setStrategy(new PerfomanceA());</span><br><span class="line">console.log(bonus.getBonus); //输出 3000</span><br></pre></td></tr></table></figure></p>
<ul>
<li>版本二：js版本的策略模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var strategies = &#123;</span><br><span class="line">    &apos;S&apos;: function(salary)&#123;</span><br><span class="line">        return salary * 4;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;A&apos;: function(salary)&#123;</span><br><span class="line">        return salary * 3;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;B&apos;: function(salary)&#123;</span><br><span class="line">        return salary * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var calculateBonus = function(level, salary)&#123;</span><br><span class="line">    return strategies[level](salary);</span><br><span class="line">&#125;;</span><br><span class="line">console.log(calculateBonus(&apos;S&apos;, 20000)); //80000</span><br></pre></td></tr></table></figure>
<h3 id="多态在策略模式中的体现"><a href="#多态在策略模式中的体现" class="headerlink" title="多态在策略模式中的体现"></a>多态在策略模式中的体现</h3><p>先记录一些有用的信息</p>
<ul>
<li>动画开始时，小球所在的原始位置</li>
<li>小球移动的目标位置</li>
<li>动画开始时的准确时间点</li>
<li>小球运动持续的时间</li>
</ul>
<p>用setInterval创建一个定时器，定时器每隔19ms循环一次。在定时器的每一帧里，我们会把动画已消失的时间、小球的原始位置、小球目标位置和动画持续的总时间等传入缓动算法。该算法通过这几个参数，计算出小球当前应该所在的位置。最后再更新该div对应的css属性，小球就能顺利地运动起来了。</p>
<h4 id="让小球运动起来"><a href="#让小球运动起来" class="headerlink" title="让小球运动起来"></a>让小球运动起来</h4><p><strong>常见缓动算法</strong>。4个参数分别为动画已消耗的时间、小球原始位置、小球目标位置、动画持续的总时间；返回的值则是动画元素应该处在的当前位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var tween = &#123;</span><br><span class="line">    linear: function(t, b, c, d)&#123;</span><br><span class="line">        return c*t/d + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    easeIn: function(t, b, c, d)&#123;</span><br><span class="line">        return c*(t/=d)*t + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    strongEaseIn: function(t, b, c, d)&#123;</span><br><span class="line">        return c*(t/=d)*t*t*t*t + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    strongEaseOut: function(t, b, c, d)&#123;</span><br><span class="line">        return c * ((t = t/ d - 1)*t*t*t*t + 1) + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    sineaseIn: function(t,b,c,d)&#123;</span><br><span class="line">        return c * (t/=d) * t*t + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    sineaseOut: function(t,b,c,d)&#123;</span><br><span class="line">        return c*((t = t/d - 1)*t*t + 1) + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div style=&quot;position:absolute;background:blue;&quot; id=&apos;div&apos;&gt;div&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>Animate类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var Animal = function(dom)&#123;</span><br><span class="line">    this.dom = dom;  //进行运动的dom节点</span><br><span class="line">    this.startTime = 0; //动画开始时间</span><br><span class="line">    this.startPos = 0; //动画开始是，dom节点的位置，即dom的初始位置</span><br><span class="line">    this.endPos = 0; //动画结束时，dom节点的位置，即dom的目标位置</span><br><span class="line">    this.propertyName = null; // dom节点需要被改变的css属性名</span><br><span class="line">    this.easing = null; //缓动算法</span><br><span class="line">    this.duration = null; //动画持续时间</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param propertyName: 要改变的CSS属性名，比如left，top，分别表示左右移动和上下移动。</span><br><span class="line"> * @param endPos: 小球运动的目标位置</span><br><span class="line"> * @param duration: 动画持续时间</span><br><span class="line"> * @param easing：缓动算法</span><br><span class="line"> **/</span><br><span class="line">Animal.prototype.start = function(propertyName, endPos, duration, easing) &#123;</span><br><span class="line">    this.startTime = new Date; //动画启动时间</span><br><span class="line">    this.startPos = this.dom.getBoundingClientRect()[propertyName]; //dom节点初始位置</span><br><span class="line">    this.propertyName = propertyName; //dom节点需要被改变的css属性名</span><br><span class="line">    this.endPos = endPos; //dom节点目标位置</span><br><span class="line">    this.duration = duration; //动画持续事件</span><br><span class="line">    this.easing = tween[easing]; //缓动算法</span><br><span class="line">    var self = this;</span><br><span class="line">    var timeId = setInterval(function()&#123; //启动定时器，开始执行动画</span><br><span class="line">        if(self.step() === false)&#123; //如果动画已结束，则清楚定时器</span><br><span class="line">            clearInterval(timeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 19);</span><br><span class="line">&#125;;</span><br><span class="line">//定义小球的每一帧都要做的事情</span><br><span class="line">Animal.prototype.step = function()&#123;</span><br><span class="line">    var t = new Date; //取得当前时间</span><br><span class="line">    if(t &gt;= this.startTime + this.duration) &#123; //(1)</span><br><span class="line">        this.update(this.endPos); //更新小球的CSS属性值</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var pos = this.easing(t - this.startTime, this.startPos,</span><br><span class="line">        this.endPos - this.startPos, this.duration);</span><br><span class="line">    //pos为小球当前位置</span><br><span class="line">    this.update(pos); //更新小球的CSS属性值</span><br><span class="line">&#125;;</span><br><span class="line">Animal.prototype.update = function(pos)&#123;</span><br><span class="line">    this.dom.style[this.propertyName] = pos + &apos;px&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var div = document.getElementById(&apos;div&apos;);</span><br><span class="line">var animate = new Animate(div);</span><br><span class="line">animate.start(&apos;left&apos;, 500, 1000, &apos;strongEaseOut&apos;);</span><br></pre></td></tr></table></figure></p>
<p>(1)处的意思是，如果当前时间大于动画开始时间加上动画持续时间只和，说明动画已经结束，此时要修正小球的位置。因为在这一帧开始之后，小球的位置已经接近了目标位置，但很可能不完全等于目标位置。此时我们要主动修正小球的当前位置为最终的目标位置。此外让Animal.prototype.step方法返回false，可以同志animate.prorotype.start方法清楚定时器。</p>
<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form action=&quot;#&quot; id=&quot;registerForm&quot; method=&quot;post&quot;&gt;</span><br><span class="line">            请输入用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;</span><br><span class="line">            请输入密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;</span><br><span class="line">            请输入手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot; /&gt;</span><br><span class="line">            &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var registerForm = document.getElementById(&apos;registerForm&apos;);</span><br><span class="line">        registerForm.onsubmit = function()&#123;</span><br><span class="line">            if(registerForm.userName.value === &apos;&apos;)&#123;</span><br><span class="line">                console.log(&apos;用户名不能为空&apos;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(registerForm.password.value.length &lt; 6)&#123;</span><br><span class="line">                console.log(&apos;密码长度不能少于6位&apos;);</span><br><span class="line">                return fasle;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!/(1[358])[0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)&#123;</span><br><span class="line">                console.log(&apos;手机号码格式不正确&apos;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>代码编写方式的缺点：</p>
<blockquote>
<p>函数庞大<br>缺乏弹性<br>算法复用性差</p>
</blockquote>
<p>用策略模式重构表单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var strategies = &#123;</span><br><span class="line">    isNonEmpty: function(value, errorMsg)&#123; //不为空</span><br><span class="line">        if(value === &apos;&apos;)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    minLength: function(value, errorMsg)&#123; //限制最小长度</span><br><span class="line">        if(value.length &lt; 6)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    isPhoneNumber: function(value, errorMsg)&#123; //判断是否为正确的手机号</span><br><span class="line">        if(!/(^1[358][0-9]&#123;9&#125;$)/.test(value)) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var validateFunc = function()&#123;</span><br><span class="line">    var validator = new Validator();  //创建一个validator对象</span><br><span class="line">    /************* 添加一些校验规则 ***************/</span><br><span class="line">    validator.add(registerForm.userName,&apos;isNonEmpty&apos;, &apos;用户名不能为空&apos;);</span><br><span class="line">    validator.add(registerForm.password,&apos;minLength:6&apos;, &apos;密码长度不能少于6位&apos;);</span><br><span class="line">    validator.add(registerForm.phoneNumber,&apos;isPhoneNumber&apos;, &apos;手机号码格式不正确&apos;);</span><br><span class="line">    </span><br><span class="line">    var errorMsg = validator.start(); //获得校验结果</span><br><span class="line">    return errorMsg; //返回校验结果</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var registerForm = document.getELementById(&apos;registerFrom&apos;);</span><br><span class="line">registerForm.onsubmit = function()&#123;</span><br><span class="line">    var errorMsg = validatorFunc(); //如果errorMsg有确切的返回值，说明未通过校验</span><br><span class="line">    if(errorMsg) &#123;</span><br><span class="line">        console.log(errorMsg);</span><br><span class="line">        return false; //组织表单提交</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Validator = function()&#123;</span><br><span class="line">    this.cache = []; //保存校验规则</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.add = function(dom, rule, errorMsg) &#123;</span><br><span class="line">    var arr = rule.split(&apos;:&apos;); //把strategy和参数分开</span><br><span class="line">    this.cache.push(function()&#123; //把校验的步骤用空函数包装起来，并且放入cache</span><br><span class="line">        var strategy = arr.shift(); //用户挑选的strategy</span><br><span class="line">        arr.unshift(dom.value); //把input的value添加进参数列表</span><br><span class="line">        arr.push(errorMsg); // 把errorMsg添加进参数列表</span><br><span class="line">        return strategies[strategy].apply(dom, arr);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.start = function()&#123;</span><br><span class="line">    for(var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123;</span><br><span class="line">        var msg = validatorFunc(); //开始校验，并取得校验后的返回信息</span><br><span class="line">        if(msg)&#123; //如果有确切的返回值，说明校验没有通过</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。代理模式的关键是，当客户不方便直接访问一个对象或不满足需要的时候，提供一个替身来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转给本体对象。</p>
<p>在四月一个晴朗的早晨，小明遇见了他的百分百女孩，我们暂且叫小明的女神为A。两天后，小明决定给A送一束花来表白。刚好小明打听到A和他有一个共同好友B，于是内向的小明决定让B来代替自己完成送花这件事。虽然小明的故事必将以悲剧收场，因为追MM更好的方式是送她一辆宝马。</p>
<p>不用代理的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var flower = function()&#123;&#125;;</span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    sendFlower: function(target) &#123;</span><br><span class="line">        var flower = new Flower();</span><br><span class="line">        target.receiveFlower(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var A = &#123;</span><br><span class="line">    receiveFlower: function(flower) &#123;</span><br><span class="line">        console.log(&apos;收到花&apos; + flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.sendFlower(A);</span><br></pre></td></tr></table></figure></p>
<p>使用代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var Flower = function()&#123;&#125;;</span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    sendFlower: function(target)&#123;</span><br><span class="line">        var flower = new Flower();</span><br><span class="line">        target.receiveFlower(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = &#123;</span><br><span class="line">    receiveFlower: function(flower) &#123;</span><br><span class="line">        A.receiveFlower(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var A = &#123;</span><br><span class="line">    receiveFlower: function(flower) &#123;</span><br><span class="line">        console.log(&apos;收到花&apos; + flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.sendFlower(B);</span><br></pre></td></tr></table></figure></p>
<p>B会监听A的心情，在A心情好的时候将花交给A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var Flower = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    sendFlower: function(target)&#123;</span><br><span class="line">        var flower = new Flower();</span><br><span class="line">        target.recerveFlower(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = &#123;</span><br><span class="line">    recerveFlower: function(flower) &#123;</span><br><span class="line">        A.listenGoodMood(function()&#123; //监听A的好心情</span><br><span class="line">            A.receiveFlower(flower); </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var A = &#123;</span><br><span class="line">    receiveFlower: function(flower) &#123;</span><br><span class="line">        console.log(&apos;收到花&apos; + flower);</span><br><span class="line">    &#125;,</span><br><span class="line">    listenGoodMood: function(fn) &#123;</span><br><span class="line">        setTimeout(function()&#123;  //假设10秒后A的心情变好</span><br><span class="line">            fn();</span><br><span class="line">        &#125;, 10000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.sendFlower(B);</span><br></pre></td></tr></table></figure></p>
<h4 id="保护代理和虚拟代理"><a href="#保护代理和虚拟代理" class="headerlink" title="保护代理和虚拟代理"></a>保护代理和虚拟代理</h4><p>代理B可以帮助A过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理B处被处理掉。这种代理叫做保护代理。A和B一个充当白脸，一个充当黑脸。白脸A继续保持良好的女神形象，不希望拒绝任何人，于是找到了黑脸B来控制对A的访问。<br>另外，假设现实中的花价格不菲，导致在程序世界里，new Flower也是一个代价昂贵的操作，那么我们可以把new Flower的操作交给代理B去执行，代理B会在A心情好的时候再执行new Flower，这是代理模式的另一种形式，叫做虚拟代理。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var B = &#123;</span><br><span class="line">    receiveFlower: function()&#123;</span><br><span class="line">        A.listenGoodMood(function()&#123; //监听A的好心情</span><br><span class="line">            var flower = new Flower(); //延迟创建flower对象</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="虚拟代理实现图片预加载"><a href="#虚拟代理实现图片预加载" class="headerlink" title="虚拟代理实现图片预加载"></a>虚拟代理实现图片预加载</h3><p>在web开发中，图片预加载是一种常用的技术，如果直接给某个img标签节点设置src属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张loading图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到img节点里，这种场景就很是时候使用虚拟代理。</p>
<p>创建一个普通的本体对象，这个对象负责往页面创建一个img标签，并且提供一个对外的serSrc接口，便可以给该image标签设置src属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var MyImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.apppendChild(imgNode);</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function(src)&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">myImage.serSrc(&apos;http://picture.jpg&apos;);</span><br></pre></td></tr></table></figure></p>
<p>引入代理对象proxyImage，通过这个代理对象，在图片被真正加载好之前，页面中将出现一张占位的菊花图loading.gif，来提示用户图片正在加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function(src) &#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var proxyImage = (function()&#123;</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        myImage.serSrc(this.src);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function(src) &#123;</span><br><span class="line">            imImage.setSrc(&apos;loading.gif&apos;);</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyImage.setSrc(&apos;http://someone.jpg&apos;);</span><br></pre></td></tr></table></figure></p>
<h4 id="代理的意义"><a href="#代理的意义" class="headerlink" title="代理的意义"></a>代理的意义</h4><p>不用代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.appendChild(&apos;imgNode&apos;);</span><br><span class="line">    var img = new Image;</span><br><span class="line"></span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        imgNode.src = img.src;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function()&#123;</span><br><span class="line">            imgNode.src = &apos;loading.gif&apos;;</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">myImage.setSrc(&apos;picture.jpg&apos;);</span><br></pre></td></tr></table></figure></p>
<p>为了说明代理的意义，我们引入面向对象设计的原则—单一职责原则。<br>单一指责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多想职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承当的责任过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。</p>
<h4 id="代理和本体接口的一致性"><a href="#代理和本体接口的一致性" class="headerlink" title="代理和本体接口的一致性"></a>代理和本体接口的一致性</h4><p>如果我们有一天不需要预加载，那么就不再需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了setSrc方法，在客户看来，代理对象和本体是一致的，代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这样做的好处。</p>
<blockquote>
<p>用户可以放心的请求代理，他只关心是否能得到想要的结果。<br>在任何使用本体的地方都可以替换成使用代理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line"></span><br><span class="line">    return function(src)&#123;</span><br><span class="line">        imgNode.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var proxyImage = (function()&#123;</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        myImage(this.src);</span><br><span class="line">    &#125;</span><br><span class="line">    return function(src) &#123;</span><br><span class="line">        myImage(&apos;loading.src&apos;);</span><br><span class="line">        img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="虚拟代理合并HTTP请求"><a href="#虚拟代理合并HTTP请求" class="headerlink" title="虚拟代理合并HTTP请求"></a>虚拟代理合并HTTP请求</h3><p>点一下checkbox发送一次请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;1&quot;/&gt;1</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;2&quot;/&gt;2</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;3&quot;/&gt;3</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;4&quot;/&gt;4</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;5&quot;/&gt;5</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;6&quot;/&gt;6</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;7&quot;/&gt;7</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var synchronousFile = function(id)&#123;</span><br><span class="line">        console.log(&apos;开始同步文件，id为：&apos; + id);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var checkbox = document.getElementByTagName(&apos;input&apos;);</span><br><span class="line">    for(var i = 0, c; c = checkbox(i++);)&#123;</span><br><span class="line">        c.onclick = function()&#123;</span><br><span class="line">            if(this.checked === true)&#123;</span><br><span class="line">                synchronousFile(this.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>为了减轻服务器压力，我们可以将2秒内的请求一次性发送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var synchronousFile = function(id) &#123;</span><br><span class="line">    console.log(&apos;开始同步文件&apos; + id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxySynchronousFile = (function()&#123;</span><br><span class="line">    var cache = [], //保存一段时间内需要同步的ID</span><br><span class="line">        timer;  //定时器</span><br><span class="line">    return function(id) &#123;</span><br><span class="line">        cache.push(id);</span><br><span class="line">        if(timer) &#123; //保证不会覆盖已经启动的定时器</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(function()&#123;</span><br><span class="line">            synchronousFile(cache.join(&apos;,&apos;)); //2秒后向本体发送需要同步的ID集合</span><br><span class="line">            clearTimeOut(timer); //清空定时器</span><br><span class="line">            timer = null;</span><br><span class="line">            cache.length = 0; //晴空ID集合</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var checkbox = document.getElementsByTagName(&apos;input&apos;);</span><br><span class="line"></span><br><span class="line">for(var i = 0, c; c = checkbox[i++]) &#123;</span><br><span class="line">    c.onclick = function()&#123;</span><br><span class="line">        if(this.checked === true) &#123;</span><br><span class="line">            proxySynchronousFile(this.id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h3><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前的一致，则可以直接返回千面存储的运算结果</p>
<h4 id="计算乘积"><a href="#计算乘积" class="headerlink" title="计算乘积"></a>计算乘积</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var mult = function()&#123;</span><br><span class="line">    console.log(&apos;开始计算乘积&apos;);</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">        a = a * arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mult(2,3); </span><br><span class="line">mult(2,3,4);</span><br></pre></td></tr></table></figure>
<p>加入缓存代理函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var proxyMult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache) &#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = mult.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyMult(2,3);</span><br><span class="line">proxyMult(2,3); //这里会使用缓存</span><br></pre></td></tr></table></figure></p>
<h4 id="缓存代理用于ajax异步请求数据"><a href="#缓存代理用于ajax异步请求数据" class="headerlink" title="缓存代理用于ajax异步请求数据"></a>缓存代理用于ajax异步请求数据</h4><p>我们常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉去一次，这些已经拉取的数据在某个地方缓存之后，下次再请求同一页的时候，便可以直接食用之前的数据。</p>
<h4 id="用高阶函数动态创建代理"><a href="#用高阶函数动态创建代理" class="headerlink" title="用高阶函数动态创建代理"></a>用高阶函数动态创建代理</h4><p>通过传入高阶函数这种更加灵活的方式，可以为各种计算方法创建缓存代理。现在这些计算方法被当作参数传入一个专门用于创建缓存代理的工厂中，这样以来我们就可以为乘法、加法、减法等创建缓存代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/************** 计算乘积 *****************/</span><br><span class="line">var mult = function()&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">        a *= argumens[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/************ 计算和 *****************/</span><br><span class="line">var plus = function()&#123;</span><br><span class="line">    var a = 0;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">        a += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/************ 创建缓存代理工厂 *********/</span><br><span class="line">var createProxyFactory = function(fn) &#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = fn.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var proxyMult = createProxyFactory(mult);</span><br><span class="line">var proxyPlus = createProxyFactory(plus);</span><br><span class="line"></span><br><span class="line">console.log(proxyMult(1,2,3,4));</span><br><span class="line">console.log(proxyMult(1,2,3,4));</span><br><span class="line">console.log(proxyPlus(1,2,3,4));</span><br><span class="line">console.log(proxyPlus(1,2,3,4));</span><br></pre></td></tr></table></figure></p>
<p>策略模式 + 缓存代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var strategies = &#123;</span><br><span class="line">    mult: function()&#123;</span><br><span class="line">        var a = 1;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            a *= arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;,</span><br><span class="line">    plus: function()&#123;</span><br><span class="line">        var a = 1;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            a += arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var createProxyFactory = function(fn)&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments. &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = fn.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxyMult = createProxyFactory(strategies.mult);</span><br><span class="line">var proxyMult = createProxyFactory(strategies.plus);</span><br></pre></td></tr></table></figure></p>
<h4 id="其他代理模式"><a href="#其他代理模式" class="headerlink" title="其他代理模式"></a>其他代理模式</h4><ul>
<li>防火墙代理： 控制网络资源的访问，保护主题不让“坏人接近“。</li>
<li>远程代理：为一个对象在不同的地址空间提供局部代表。</li>
<li>保护代理： 用于对象应该有不同访问权限的情况</li>
<li>智能引用代理： 取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。</li>
<li>写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体。DLL（操作系统中的动态链接库）是其典型运用场景。</li>
</ul>
<p>尽管代理模式有用，但我们在编写业务代码时，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p>
<h3 id="实现自己的迭代器"><a href="#实现自己的迭代器" class="headerlink" title="实现自己的迭代器"></a>实现自己的迭代器</h3><p>实现一个each函数，each函数接受2个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回掉函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var each = function(arr, callback) &#123;</span><br><span class="line">    for(var i = 0, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        callback.call(arr[i], i, arr[i]); //把下标和元素当作参数传给callback函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">each([1,2,3], function(i, n)&#123;</span><br><span class="line">    console.log([i,n]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="内部迭代器和外部迭代器"><a href="#内部迭代器和外部迭代器" class="headerlink" title="内部迭代器和外部迭代器"></a>内部迭代器和外部迭代器</h3><h4 id="内部迭代器"><a href="#内部迭代器" class="headerlink" title="内部迭代器"></a>内部迭代器</h4><p>上面编写的each函数就是内部迭代器，each函数的内部已经定义好了迭代规则，它完全接受整个迭代过程，外部只需要一次初始调用。由于内部迭代器被提前定义了规则，上面的each函数就无法同时迭代2个数组了。比如现在有个需求，要判断2个数组里元素的值是否完全相等，如果不该写each函数本身的代码，我们能够入手的地方似乎只有each的回掉函数了，代码如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var compare = function(arr1, arr2)&#123;</span><br><span class="line">    if(arr1.length !== arr2.length)&#123;</span><br><span class="line">        throw new Error(&apos;arr1和arr2不想等&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    each(arr1, function(i, n)&#123;</span><br><span class="line">        if(n !== arr2[i])&#123;</span><br><span class="line">            throw new Error(&apos;arr1和arr2不想等&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&apos;arr1和arr2相等&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> 说实话，这个compare函数一点都算不上好看，我们目前能够顺利完成需求，还要感谢在js里可以把函数当作参数传递的特性，但在其他语言中未必能够实现。</p>
<h4 id="外部迭代器"><a href="#外部迭代器" class="headerlink" title="外部迭代器"></a>外部迭代器</h4><p> 外部迭代器必须显式地请求迭代下一个元素。外部迭代器增加了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var Iterator = function(ob) &#123;</span><br><span class="line">    var current = 0;</span><br><span class="line"></span><br><span class="line">    var next = function() &#123;</span><br><span class="line">        current += 1;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var isDone = function()&#123;</span><br><span class="line">        return current &gt;= obj.length;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var getCurrItem = function()&#123;</span><br><span class="line">        return obj[current];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var getLength = function()&#123;</span><br><span class="line">        return obj.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        next: next,</span><br><span class="line">        isDone: isDone,</span><br><span class="line">        getCurrItem: getCurrItem,</span><br><span class="line">        getLength: getLength</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var compare = function(iterator1, iterator2) &#123;</span><br><span class="line">    if(iterator1.getLength !== iterator2.getLength)</span><br><span class="line">        throw new Error(&apos;iterator1与iterator2不相等&apos;);</span><br><span class="line">    while(!iterator1.isDone() &amp;&amp; !iterator2.isDone()) &#123;</span><br><span class="line">        if(iterator1.getCurrItem() !== iterator2.getCurrItem()) &#123;</span><br><span class="line">            throw new Error(&apos;iterator1与iterator2不相等&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator1.next();</span><br><span class="line">        iterator2.next();</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;iterator1与iterator2相等&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var iterator1 = iterator([1,2,3]);</span><br><span class="line">var iterator2 = iterator([1,2,3]);</span><br><span class="line">compare(iterator1, iterator2);</span><br></pre></td></tr></table></figure></p>
<p> 外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。</p>
<h3 id="迭代类数组对象和字面量对象"><a href="#迭代类数组对象和字面量对象" class="headerlink" title="迭代类数组对象和字面量对象"></a>迭代类数组对象和字面量对象</h3><p> 迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象。比如arguments、{“0”:’a’,”1”:’b’}等。通过上面的代码观察到，无论是内部迭代器还是外部迭代器，只要迭代的聚合对象拥有length属性，而且可以用下表访问，那它就可以被迭代。<br> 在js中，for in语句可以用来迭代普通字面量对象的属性。jq中提供了$.each来封装各种迭代行为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$.each = function(obj, callback)&#123;</span><br><span class="line">    var value,</span><br><span class="line">        i = 0,</span><br><span class="line">        length = obj.length,</span><br><span class="line">        isArray = isArraylike(obj); //isArraylist 是jq中的函数</span><br><span class="line">        if(isArray) &#123; //迭代类数组</span><br><span class="line">           for(; i &lt; length; i++)&#123;</span><br><span class="line">               value = callback.call(obj[i], i, obj[i]);</span><br><span class="line">               if(value === false)&#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for(i in obj) &#123; //迭代object对象</span><br><span class="line">               value = callback.call(obj[i], i obj[i]);</span><br><span class="line">               if(value === false)&#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="倒序迭代器"><a href="#倒序迭代器" class="headerlink" title="倒序迭代器"></a>倒序迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reverseEach = function(arr, callback)&#123;</span><br><span class="line">    for(var l = arr.length - 1; l &gt;=0; l--)&#123;</span><br><span class="line">        callback(l, arr[l]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">reverseEach([1,2,3], function(i, n)&#123;</span><br><span class="line">    console.log(n);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="中止迭代器"><a href="#中止迭代器" class="headerlink" title="中止迭代器"></a>中止迭代器</h3><p>迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。jq中的each函数里有这样一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(value === false)&#123;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这句代码的意思是，约定如果回掉函数的执行结果返回false，则提前终止循环。下面我们把之前的each函数改写以下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var each = function(arr, callback)&#123;</span><br><span class="line">    for(var i = 0, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        if(callback(i, arr[i]) === false) &#123; //callback的执行结果返回false，提前终止迭代</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">each([1,2,3,4,5], function(i, n)&#123;</span><br><span class="line">    if(n &gt; 3) return false;</span><br><span class="line">    console.log(n);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器模式的应用举例"><a href="#迭代器模式的应用举例" class="headerlink" title="迭代器模式的应用举例"></a>迭代器模式的应用举例</h3><p>2013年的一天， 当我在重构某个项目中文件上传模块的代码时，发现了下面这段代码，它的目的是根据不同的浏览器获取相应的上传组件对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var getUploadObj = function()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        return new ActiveXObject(&quot;TXFTNActiveX.FTNUpload&quot;); //IE上传控件</span><br><span class="line">    &#125;catch(e) &#123;</span><br><span class="line">        if(supportFlash()) &#123;</span><br><span class="line">            var str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</span><br><span class="line">            return $(str).appendTo($(&apos;body&apos;));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            var str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot;/&gt;&quot;; //表单上传</span><br><span class="line">            return $(str).appendTo($(&apos;body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码第一很难阅读，第二是严重违反开闭原则。在开发和调试中，我们需要来回切换不同的上传方式，每次改动都相当痛苦。后来我们还增加支持了一些另外的上传方式，比如HTML5上传，这时候唯一的办法是继续往getUplaodObj函数里增加条件分支。<br>现在来梳理以下问题，目前一共有三种上传方式，我们不知道目前正在使用的浏览器支持哪种。我们可以把每种获取upload对象的方法封装在各自的函数里，然后使用一个迭代器，迭代获取这些upload对象，直到获取到一个可用的为止：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var getActiveUploadObj = function()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        return new ActiveXObject(&apos;TXFTNActiveX.FTNUpload&apos;); //IE上传控件 </span><br><span class="line">    &#125;catch(e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var getFlashUploadObj = function()&#123; </span><br><span class="line">    if(supportFlash()) &#123; //supportFlash函数未提供</span><br><span class="line">        var str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</span><br><span class="line">        return $(str).appendTo($(&apos;body&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var getFormUploadObj = function()&#123;</span><br><span class="line">    var str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot; class=&quot;ui-file&quot;/&gt;&apos;; //表单上传</span><br><span class="line">    return $(str).appendTo($(&apos;body&apos;));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var iteratorUploadObj = function()&#123;</span><br><span class="line">    for(var i = 0, fn; fn = arguments[i++];) &#123;</span><br><span class="line">        var uploadObj = fn();</span><br><span class="line">        if(uploadObj !== false) &#123;</span><br><span class="line">            return uploadObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iteratorUploadObj(getActiveUploadObj, getFlashUploadObj, getHtml5UploadOb);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p>发布-订阅模式又称观察者模式，它定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在js中，我们一般用事件模型来替代传统的发布-订阅模式。</p>
<p>发布-订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅ajax请求的error、succ等事件。或者如果想在动画的每一帧完成后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布-订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。</p>
<p>发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显示地调用另一个对象的某个接口。发布-订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这并不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</p>
<h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这里需要监控用户点击document.body的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅document.body上的click事件，当body节点被点击时，body节点便会向订阅者发布这个消息。<br>我们还可以随意增加或删除订阅者，增加任何订阅者都不会影响发布者代码的编写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.body.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.body.click(); //模拟用户点击</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>除了DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布-订阅模式可以用于任何js代码中。<br>现在看看如何一步步实现发布-订阅模式：</p>
<ul>
<li>首先要指定好谁充当发布者；</li>
<li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者；</li>
<li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数。</li>
</ul>
<p>另外，我们还可以往回调函数里填入一些参数，订阅者可以接受这些参数，订阅者接受到这些参数后可以进行各自的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;; //定义售楼处</span><br><span class="line">salesOffices.clientList = []; //缓存列表，存放订阅者的回调函数</span><br><span class="line">salesOffices.listen = function(fn)&#123; //增加订阅者</span><br><span class="line">    this.clientList.push(fn); //订阅的消息添加进缓存列表</span><br><span class="line">&#125;；</span><br><span class="line">salesOffices.trigger = function()&#123; //发布消息</span><br><span class="line">    for(var i = 0, fn; fn = this.clientList[i++];)&#123;</span><br><span class="line">        fn.apply(this, arguments); //(2)//arguments是发布消息时带上的参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.listen(function(price, squareMeter)&#123; //小明订阅消息</span><br><span class="line">    console.log(&apos;价格=&apos; + price);</span><br><span class="line">    console.log(&apos;squareMeter= &apos; + squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(function(price, squareMeter)&#123; //小红订阅消息</span><br><span class="line">    console.log(&apos;价格=&apos; + price);</span><br><span class="line">    console.log(&apos;squareMeter=&apos; + squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(200000, 88); // 小明订阅88平米房子的消息</span><br><span class="line">salesOffices.trigger(300000, 110);// 小红订阅110平米房子的消息</span><br></pre></td></tr></table></figure></p>
<p>至此，我们已经实现了最简单的发布-订阅模式，但这里还存在一些问题。我们看到订阅者接收到了发布者发布的每个消息，虽然小明只想买88平米的房子，但是发布者把110平米的信息也发给了小明，这对小明是不必要的困扰。所以我们有必要增加一个标示key，让订阅者只订阅自己感兴趣的消息。改写后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;; //定义售楼处</span><br><span class="line">salesOffices.clientList = &#123;&#125;; //缓存列表，存放订阅者的回调函数</span><br><span class="line">salesOffices.listen = function(key, fn)&#123;</span><br><span class="line">    if(!this.clientList[key])&#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表</span><br><span class="line">        this.clientList[key] = []; </span><br><span class="line">    &#125;</span><br><span class="line">    this.clienList[key].push(fn); //订阅的消息添加进消息缓存列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.trigger = function()&#123; //发布消息</span><br><span class="line">    var key = Array.prototype.shift.call(arguments), //取出消息类型</span><br><span class="line">        fns = this.clientList[key]; //取出该消息类型下的回调函数集合</span><br><span class="line">        if(!fns || fns.length === 0)&#123; //如果没有订阅该消息， 则返回</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    for(var i = 0, fn; fn = fns[i++];)&#123;</span><br><span class="line">        fn.apply(this, arguments); //arguments是发布消息时附送的参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter88&apos;,function(price)&#123; //小明订阅88平米房子的消息</span><br><span class="line">    console.log(price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter110&apos;, function(price)&#123; //小红订阅110平米房子消息</span><br><span class="line">    console.log(price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffice.trigger(&apos;squareMeter88&apos;, 2000000);</span><br><span class="line">salesOffice.trigger(&apos;squareMeter110&apos;, 2000000);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="发布-订阅模式的通用实现"><a href="#发布-订阅模式的通用实现" class="headerlink" title="发布-订阅模式的通用实现"></a>发布-订阅模式的通用实现</h3><p>把发布-订阅的功能提取出来，放在一个单独的对象内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var event = &#123;</span><br><span class="line">    clientList: &#123;&#125;,</span><br><span class="line">    listen: function(key, fn)&#123;</span><br><span class="line">        if(!this.clientList[key])</span><br><span class="line">            this.clientList[key] = [];</span><br><span class="line">        this.clientList[key].push(fn); //订阅的消息添加进缓存列表</span><br><span class="line">    &#125;,</span><br><span class="line">    trigger: function()&#123;</span><br><span class="line">        var key = Array.prototype.shift.call(arguments), </span><br><span class="line">            fns = this.clientList[key];</span><br><span class="line">        if(!fns || fns.length === 0)</span><br><span class="line">            return false;</span><br><span class="line">        for(var i = 0, fn; fn = fns[i++];)&#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在定义一个installEvent函数， 这个函数可以给所有的对象都动态安装发布-订阅功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var installEvent = function(obj)&#123;</span><br><span class="line">    for(var i in event) &#123;</span><br><span class="line">        obj[i] = event[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再来测试一番，我们给售楼处salesOffices动态添加发布-订阅功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;;</span><br><span class="line">installEvent(salesOffices);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter88&apos;, function(price)&#123; //小明订阅消息</span><br><span class="line">    console.log(&apos;价格=&apos; + price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter110&apos;, function(price)&#123; //小红订阅消息</span><br><span class="line">    console.log(&apos;价格=&apos; + price):</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(&apos;squareMeter88&apos;, 2000000);</span><br><span class="line">salesOffices.trigger(&apos;squareMeter100&apos;, 3000000);</span><br></pre></td></tr></table></figure></p>
<p>取消订阅事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">event.remove = function(key, fn)&#123;</span><br><span class="line">    var fns = this.clientList[key];</span><br><span class="line">    if(!fns)&#123; //如果key对应的消息没有被人订阅，则直接返回</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!fn) &#123; //如果没有传入具体的回调参数，表示需要取消key对应消息的所有订阅</span><br><span class="line">        fns &amp;&amp; (fns.length = 0);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(var l = fns.length - 1; l &gt;= 0; l --)&#123; //反向遍历订阅的回调函数</span><br><span class="line">                var _fn = fns[l];</span><br><span class="line">                if(_fn === fn)&#123;</span><br><span class="line">                    fns.splice(l, 1); //删除订阅者的回调函数</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="网站登陆"><a href="#网站登陆" class="headerlink" title="网站登陆"></a>网站登陆</h3><p>假如我们正在开发一个商城网站，网站里有header头部、nav导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用ajax异步请求获取用户的登陆信息。但是现在还不足以说服我们在此使用发布-订阅模式，因为异步的问题通常也可以用回调函数来解决。更重要的一点是，我们不知道除了header头部、nav导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">login.succ(function(data)&#123;</span><br><span class="line">    header.setAvatar(data.avatar); //设置header模块的头像</span><br><span class="line">    nav.setAvatar(data.avatar); //设置导航模块的头像</span><br><span class="line">    message.refresh(); //刷新消息列表</span><br><span class="line">    cart.refresh(); //刷新购物车列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>现在登陆模块是我们负责编写的，但我们还必须了解header模块里设置头像的方法叫setAvatar、购物车模块里刷新的方法叫refresh，这种耦合性会使程序变得僵硬，header模块不能随意再改变setAvatar的方法名，它自身的名字也不能被改为header1，header2。这是针对具体实现编程的典型例子，针对具体实现编程是不被赞同的。<br>等到有一天，项目中🈶️新增了一个收获地址管理的模块，这个模块本来是另一个同时所写的，而此时你正在马来西亚度假，但是他却不得不给你打电话：“hi 登陆之后麻烦刷新一下收获地址“。于是你又翻开你3个月前写的登陆模块，在最后部分加上这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">login.succ(function(data)&#123;</span><br><span class="line">    header.setAvatar(data.avatar);</span><br><span class="line">    nav.setAvatar(data.avatar);</span><br><span class="line">    message.refresh();</span><br><span class="line">    cart.refresh();</span><br><span class="line">    address.refresh(); // 增加这行代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们就会越来越疲于应付这些突如其来的业务要求，要么跳槽了事，要么必须来重构这些代码。<br>用发布-订阅模式重写后，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解它们的内部细节。改善后的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&apos;http...&apos;, function(data)&#123; //登录成功</span><br><span class="line">    login.trigger(&apos;loginSucc&apos;, data); //发布登陆成功的消息</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>各模块监听登陆成功的消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var header = (function()&#123; //header模块</span><br><span class="line">    login.listen(&apos;loginSucc&apos;, function(data)&#123;</span><br><span class="line">        header.setAvatar(data.avatar);</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">        setAvatar: function(data) &#123;</span><br><span class="line">            console.log(&apos;设置header模块的头像&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var nav = (function()&#123; //nav 模块</span><br><span class="line">    login.listen(&apos;loginSucc&apos;, function(data)&#123;</span><br><span class="line">        nav.setAvatar(data.avatar);</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">        setAvatar: function(avatar)&#123;</span><br><span class="line">            console.log(&apos;设置nav模块的头像&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>如上所述，我们随时可以把setAvatar的方法名改成其他。如果有一天在登录完成之后，又增加一个刷新收货地址列表的行为，那么只要在收获地址模块里加上监听消息的方法即可，而这可以让开发该模块的同事自己完成，你作为登录模块的开发者，永远不用关心这些行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var address = (function()&#123; //nav模块</span><br><span class="line">    login.listen(&apos;loginSucc&apos;, function(obj)&#123;</span><br><span class="line">        address.refresh(obj);</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">        refresh: function(avatar) &#123;</span><br><span class="line">            console.log(&apos;刷新收获地址&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="全局的发布-订阅对象"><a href="#全局的发布-订阅对象" class="headerlink" title="全局的发布-订阅对象"></a>全局的发布-订阅对象</h3><p>回想下刚刚实现的发布-订阅模式，我们给售楼处对象和登录都添加了订阅和发布的功能，这里还存在两个小问题。</p>
<ul>
<li>我们给每个发布者对象都添加了listen和trigger方法，以及一个缓存列表，这其实是一种资源浪费。</li>
<li>小明跟售楼处对象还是存在一定的耦合性，小明至少要知道售楼处对象的名字是salesOffices，才能顺利的订阅到事件。见如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salesOffices.listen(&apos;squareMeter100&apos;, function(price)&#123; //小明订阅消息j</span><br><span class="line">    console.log(&apos;价格= &apos;+price);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果小明还关心300平米的房子，而这套房子的卖家是salesOffice2，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salesOffices2.listen(&apos;squareMeter300&apos;, function(price)&#123;</span><br><span class="line">    console.log(&apos;价格= &apos;+price);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>引入中介<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var event = (function()&#123;</span><br><span class="line">    var clientList = &#123;&#125;,</span><br><span class="line">        listen,</span><br><span class="line">        trigger,</span><br><span class="line">        remove;</span><br><span class="line">    listen = function(key, fn)&#123;</span><br><span class="line">        if(!clientList[key]) &#123;</span><br><span class="line">            clientList[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        clientList[key].push(fn);</span><br><span class="line">    &#125;;</span><br><span class="line">    trigger = function()&#123;</span><br><span class="line">        var key = Array.prototype.shift.call(arguments),</span><br><span class="line">            fns = clientList[key];</span><br><span class="line">            if(!fns || fns.length === 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            for(var i = 0, fn; fn = fns[i++];)&#123;</span><br><span class="line">                fn.apply(this, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    remove = function(key, fn)&#123;</span><br><span class="line">        var fns = clientList[key];</span><br><span class="line">        if(!fns)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!fn)&#123;</span><br><span class="line">            fns &amp;&amp; (fns.length = 0);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(var l = fns.length - 1; l &gt;= 0; l --)&#123;</span><br><span class="line">                var _fn = fns[l];</span><br><span class="line">                if(_fn === fn)&#123;</span><br><span class="line">                    fns.splice(l, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        listen: listen,</span><br><span class="line">        trigger: trigger,</span><br><span class="line">        remove: remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Event.listen(&apos;squareMeter88&apos;, function(price)&#123; //小红订阅消息</span><br><span class="line">    console.log(price);</span><br><span class="line">&#125;);</span><br><span class="line">Event.trigger(&apos;squareMeter88&apos;, 2000000); //售楼处发布消息</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式是最简单和优雅的模式之一，命令模式中的命令指的是一个执行某些特定事情的指令。<br>命令模式最常见的<strong>应用场景是</strong>：有时候需要向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道被请求的操作是什么。此时需要用一种松耦合的方法来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。<br>拿餐厅来说，客人需要向厨师发送请求，但是完全不知道这些厨师的名字和联系方式，也不知道厨师炒菜的方式和步骤。命令模式把客人订餐的请求封装成command对象，也就是订餐中的订单对象。这个对象可以在程序中被四处传递，就像订单可以从服务员手中传到厨师的手中。这样一来，客人不需要知道厨师的名字，从而解开了请求调用者和请求接收者之间的耦合。<br>另外，相对于过程化的请求调用，command对象拥有<strong>更长的生命周期</strong>。对象的生命周期是跟初始请求无关的，因为这个请求已经封装在了command对象的方法中，成为了这个对象的行为。<br><strong>设计模式的主题总是把不变的事物和变化的事物分离开来。</strong></p>
<h3 id="命令模式的例子-菜单程序"><a href="#命令模式的例子-菜单程序" class="headerlink" title="命令模式的例子  菜单程序"></a>命令模式的例子  菜单程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;button1&quot;&gt;点击按钮1&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;button2&quot;&gt;点击按钮2&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;button3&quot;&gt;点击按钮3&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var button1 = document.getElementById(&apos;button1&apos;);</span><br><span class="line">    var button2 = document.getElementById(&apos;button2&apos;);</span><br><span class="line">    var button3 = document.getElementById(&apos;button3&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>接下来定义setCommand函数，setCommand函数负责往按钮上面安装命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var setCommand = function(button, command)&#123;</span><br><span class="line">    button.onclick = function()&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>命令接受者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var MenuBar = &#123;</span><br><span class="line">    refresh: function()&#123;</span><br><span class="line">        console.log(&quot;刷新菜单目录&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var SubMenu = &#123;</span><br><span class="line">    add: function()&#123;</span><br><span class="line">        console.log(&apos;增加子菜单&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    del: function()&#123;</span><br><span class="line">        console.log(&apos;删除子菜单&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在让button变得有用之前，我们先把行为都封装在命令类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var RefreshMenuBarCommand = function(receiver)&#123;</span><br><span class="line">    this.receiver = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">refreshMenuCommand.prototype.execute = function()&#123;</span><br><span class="line">    this.receiver.refresh();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var AddSubMenuCommand = function(receiver)&#123;</span><br><span class="line">    this.receiver = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AddSubMenuCommand.prototype.execute = function()&#123;</span><br><span class="line">    this.receiver.add();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var DelSubMenuCommand = function(receiver)&#123;</span><br><span class="line">    this.receiver = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DelSubMenuCommand.prototype.execute = function()&#123;</span><br><span class="line">    console.log(&apos;删除子菜单&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>最后把命令接受者传入到command对象中，并且把command对象安装到button上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);</span><br><span class="line">var addSubMenuCommand = new AddSubMenuCommand(SubMenu);</span><br><span class="line">var delSubMenuCommand = new DelSubMenuCommand(SubMenu);</span><br><span class="line"></span><br><span class="line">setCommand(button1, refreshMenuBarCommand);</span><br><span class="line">setCommand(button2, addSubMenuCommand);</span><br><span class="line">setCommand(button3, delSubMenuCommand);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>在js中，函数是一等对象。可以用回调函数实现命令模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var setCommand = function(button, command)&#123;</span><br><span class="line">    button.onclick = function()&#123;</span><br><span class="line">        commmand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var MenuBar = &#123;</span><br><span class="line">    refresh: function()&#123;</span><br><span class="line">        console.log(&apos;刷新菜单界面&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var RefreshMenuBarCommand = function(receiver)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        execute: function()&#123;</span><br><span class="line">            receiver.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);</span><br><span class="line">setCommand(button1, refreshMenuBarCommand);</span><br></pre></td></tr></table></figure></p>
<h3 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h3><p>宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var closeDoorCommand = &#123;</span><br><span class="line">    execute: function()&#123;</span><br><span class="line">        console.log(&apos;关门&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var openPcCommand = &#123;</span><br><span class="line">    execute: function()&#123;</span><br><span class="line">        console.log(&apos;开电脑&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var openQQCommand = &#123;</span><br><span class="line">    execute: function()&#123;</span><br><span class="line">        console.log(&apos;登录QQ&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义宏命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var MacroCommand = function()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        commandsList: [],</span><br><span class="line">        add: function(command)&#123;</span><br><span class="line">            this.commandsList.push(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        execute: function()&#123;</span><br><span class="line">            for(var i = 0, command; command = this.commandsList[i++];)&#123;</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var macroCommand = MacroCommand();</span><br><span class="line"></span><br><span class="line">macroCommand.add(closeDoorCommand);</span><br><span class="line">macroCommand.add(openPcCommand);</span><br><span class="line">macroCommand.add(openQQCommand);</span><br><span class="line"></span><br><span class="line">macroCommand.execute();</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式就是用小的对象来构建更大的对象，而这些小的子对象本身也许是由更小的孙对象构成的。<br><img src="/images/组合模式.png" alt="组合模式中的对象由一个或多个叶对象组成"></p>
<h4 id="更加强大的宏命令"><a href="#更加强大的宏命令" class="headerlink" title="更加强大的宏命令"></a>更加强大的宏命令</h4><p>要实现的功能</p>
<ul>
<li>打开空调</li>
<li>打开电视和音响</li>
<li>关门、开电脑、登录QQ<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button id=&quot;button&quot;&gt;按我&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var MacroCommand = function()&#123; //工厂模式</span><br><span class="line">            return &#123;</span><br><span class="line">                commandsList: [],</span><br><span class="line">                add: function(command)&#123;</span><br><span class="line">                    this.commandsList.push(command)</span><br><span class="line">                &#125;,</span><br><span class="line">                execute: function()&#123;</span><br><span class="line">                    for(var i = 0, command; command = this.commandsList[i++];)&#123;</span><br><span class="line">                        command.execute();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var openAcCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;打开空调&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    //电视和音响连在一起</span><br><span class="line">        var openTvCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;打开电视&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var openSoundCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;打开音响&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var macroCommand1 = MacroCommand();</span><br><span class="line">        macroCommand1.add(openTvCommand);</span><br><span class="line">        macroCommand1.add(openSoundCommand);</span><br><span class="line"></span><br><span class="line">    //关闭、打开电脑和登陆QQ的命令</span><br><span class="line">        var closeDoorCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;关门&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var openPcCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;开电脑&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var openQQCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;登陆QQ&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var macroCommand2 = MacroCommand();</span><br><span class="line">        macroCommand2.add(closeDoorCommand);</span><br><span class="line">        macroCommand2.add(openPcCommand);</span><br><span class="line">        macroCommand2.add(openQQCommand);</span><br><span class="line">    //现在把所有命令组合成一个超级命令</span><br><span class="line">        var macroCommand = MacroCommand();</span><br><span class="line">        macroCommand.add(openAcCommand);</span><br><span class="line">        macroCommand.add(macroCommand1);</span><br><span class="line">        macroCommand.add(macroCommand2);</span><br><span class="line">    //最后给遥控器绑定“超级命令”</span><br><span class="line">        var setCommand = (function(command)&#123;</span><br><span class="line">            ducoment.getElementById(&apos;button&apos;).onclick = function()&#123;</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(macroCommand):</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由上面的例子可以看出，基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，这样不断递归下去，这棵树的结构可以支持任意多的复杂度。</p>
<hr>
<h3 id="透明性带来的安全问题"><a href="#透明性带来的安全问题" class="headerlink" title="透明性带来的安全问题"></a>透明性带来的安全问题</h3><p>组合模式使得不用去区分具体的对象，这就是组合模式的透明性。<br>组合对象可以拥有子节点，叶对象下面就没有子节点，所以我们也许会发生一些误操作，比如试图往叶对象中添加子节点。解决方案通常也是给叶对象增加add方法，并且在调用这个方法时，抛出一个异常来及时提醒客户，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var MacroCommand = function()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        commandsList: [],</span><br><span class="line">        add: function(command)&#123;</span><br><span class="line">            this.commandsList.push(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        execute: function()&#123;</span><br><span class="line">            for(var i = 0, command; command = this.commandsList[i++];)&#123;</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var openTvCommand = &#123;</span><br><span class="line">    execute: function()&#123;</span><br><span class="line">        console.log(&apos;打开电视&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    add: function()&#123;</span><br><span class="line">        throw new Error(&apos;叶对象不能添加子节点&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add(openTvCommand);</span><br><span class="line">openTvCommand.add(macroCommand); //叶对象不能添加子节点</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="例子–扫描文件夹"><a href="#例子–扫描文件夹" class="headerlink" title="例子–扫描文件夹"></a>例子–扫描文件夹</h3><p>文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树，组合模式在文件夹的应用中有以下两层好处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***************** Folder *******************/</span><br><span class="line">var Folder = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.files = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.add = function(file)&#123;</span><br><span class="line">    this.files.push(file);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.scan = function()&#123;</span><br><span class="line">    console.log(&apos;开始扫描文件夹：&apos; + this.name);</span><br><span class="line">    for(var i = 0, file, files = this.files; file = files[i++];)&#123;</span><br><span class="line">        file.scan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/********************* File *****************/</span><br><span class="line">var File = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.add = function()&#123;</span><br><span class="line">    throw new Error(&apos;文件下面不能再添加文件&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.scan = function()&#123;</span><br><span class="line">    console.log(&apos;开始扫描文件&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来创建一些文件夹和文件对象，并且让他们组合成一棵树，这棵树就是我们F盘里的现有文件目录结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var folder = new Folder(&apos;学习资料&apos;);</span><br><span class="line">var folder1 = new Folder(&apos;Javascript&apos;);</span><br><span class="line">var folder2 = new Folder(&apos;JQuery&apos;);</span><br><span class="line"></span><br><span class="line">var file = new File(&apos;JS设计模式与开发实践&apos;);</span><br><span class="line">var file1 = new File(&apos;精通JQuery&apos;);</span><br><span class="line">var file2 = new File(&apos;重构与模式&apos;);</span><br><span class="line"></span><br><span class="line">folder1.add(file1);</span><br><span class="line">folder1.add(file);</span><br><span class="line">folder2.add(file2);</span><br><span class="line"></span><br><span class="line">folder.add(folder1);</span><br><span class="line">folder.add(folder2);</span><br><span class="line">folder.add(file3);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="引用父对象"><a href="#引用父对象" class="headerlink" title="引用父对象"></a>引用父对象</h3><p>组合对象保存了它下面的子节点的引用，这是组合模式的特点，此时树结构是从上至下的。但有时候我们需要在子节点上保持对父节点的引用，比如在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当我们删除某个文件时，实际上是从这个文件所在的上层文件夹中删除该文件的。</p>
<p>改写folder类和file类，在两个类的构造函数中，增加this.parent属性，并且在调用add方法时，正确设置文件或文件夹的父节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">var Folder = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.parent = null; //增加this.parent属性</span><br><span class="line">    this.files = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.add = function(file)&#123;</span><br><span class="line">    file.parent = this; //设置父对象</span><br><span class="line">    this.files.push(file);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.scan = function()&#123;</span><br><span class="line">    console.log(&apos;开始扫描文件夹：&apos;+this.name);</span><br><span class="line">    for(var i , file files = this.files; file = files[i++];)&#123;</span><br><span class="line">        file.scan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.remove = function()&#123;</span><br><span class="line">    if(!this.parent)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var files = this.parent, l = files.length;l &gt;= 0; l --)&#123;</span><br><span class="line">        var file = files[l];</span><br><span class="line">        if(file === this)&#123;</span><br><span class="line">            files.splice(l, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var File = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.parent = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.add = function()&#123;</span><br><span class="line">    throw new Error(&apos;不能添加文件在下面&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.scan = function()&#123;</span><br><span class="line">    console.log(&apos;开始扫描文件：&apos;+this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.remove = function()&#123;</span><br><span class="line">    if(!this.parent)&#123; //跟节点或者树外的游离节点</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var files = this.parent.files, l = files.length; l &gt;= 0; l --)&#123;</span><br><span class="line">        if(file === this)&#123;</span><br><span class="line">            files.splice(l, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var folder = new Folder(&apos;math&apos;);</span><br><span class="line">var file = new File(&apos;高等数学&apos;);</span><br><span class="line">folder.add(file);</span><br><span class="line">folder.scan();</span><br><span class="line"></span><br><span class="line">file.remove();</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h2><p>在js开发中用到继承的场景其实并不多，很多时候我们都喜欢用mix-in的方式给对象扩展属性。但这不代表继承在js中没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。</p>
<h3 id="模板方法模式的定义和组成"><a href="#模板方法模式的定义和组成" class="headerlink" title="模板方法模式的定义和组成"></a>模板方法模式的定义和组成</h3><p>模板方法模式是一种只需要使用继承就可以实现的非常简单的模式。<br>模板方法由两部分组成：</p>
<ul>
<li>第一部分是抽象父类</li>
<li>第二部分是具体的实现子类<br>通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</li>
</ul>
<h3 id="coffee-or-tea"><a href="#coffee-or-tea" class="headerlink" title="coffee or tea"></a>coffee or tea</h3><p>泡一杯咖啡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var Coffee = function()&#123;&#125;;</span><br><span class="line">Coffee.prototype.boilWater = function()&#123;</span><br><span class="line">    console.log(&apos;把水煮沸&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Coffee.prototype.brewCoffeeGriends = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水冲泡咖啡&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Coffee.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把咖啡倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Coffee.prototype.addSugarAndMilk = function()&#123;</span><br><span class="line">    console.log(&apos;加糖和牛奶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Coffee.prototype.init = function()&#123;</span><br><span class="line">    this.boilWater();</span><br><span class="line">    this.brewCoffeeGriends();</span><br><span class="line">    this.pourInCup();</span><br><span class="line">    this.addSugarAndMilk();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var coffee = new Coffee();</span><br><span class="line"></span><br><span class="line">coffee.init();</span><br></pre></td></tr></table></figure></p>
<p>泡一壶茶<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var Tea = function()&#123;&#125;;</span><br><span class="line">Tea.prototype.boilWater = function()&#123;</span><br><span class="line">    console.log(&apos;把水煮沸&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tea.prototype.steepTeaBag = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水浸泡茶叶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tea.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把茶水倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tea.prototype.addLemon = function()&#123;</span><br><span class="line">    console.log(&apos;加柠檬&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tea.prototype.init() = function()&#123;</span><br><span class="line">    this.boilWater();</span><br><span class="line">    this.steepTeaBag();</span><br><span class="line">    this.pourInCup();</span><br><span class="line">    this.addLemon();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var tea = new Tea();</span><br><span class="line">tea.init();</span><br></pre></td></tr></table></figure></p>
<p>抽出共同点后</p>
<ul>
<li>把水煮沸</li>
<li>用沸水冲泡饮料</li>
<li>把饮料倒进杯子</li>
<li>加调料</li>
</ul>
<p>Beverage 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Beverage = function()&#123;&#125;;</span><br><span class="line">Beverage.prototype.boilWater = function()&#123;</span><br><span class="line">    console.log(&apos;把水煮沸&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.brew = function()&#123;&#125;; //空方法， 由子类重写</span><br><span class="line">Beverage.prototype.pourInCup = function()&#123;&#125;; //空方法， 应该由子类重写</span><br><span class="line">Beverage.prototype.addCondiments = function()&#123;&#125;; //空方法，由子类实现</span><br><span class="line">Beverage.prototype.init = function()&#123;</span><br><span class="line">    this.boilWater();</span><br><span class="line">    this.brew();</span><br><span class="line">    this.pourInCup();</span><br><span class="line">    this.addCondiments();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建Coffee子类和Tea子类"><a href="#创建Coffee子类和Tea子类" class="headerlink" title="创建Coffee子类和Tea子类"></a>创建Coffee子类和Tea子类</h3><p>Coffee子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Coffee = function()&#123;&#125;;</span><br><span class="line">Coffee.prototype = new Beverage(); //继承Beverage类</span><br><span class="line">Coffee.prototype.brew = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水冲泡咖啡&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把咖啡倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.addCondiments = function()&#123;</span><br><span class="line">    console.log(&apos;加糖和牛奶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">var Coffee = new Coffee();</span><br><span class="line">Coffee.init();</span><br></pre></td></tr></table></figure></p>
<p>Tea子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Tea = function()&#123;&#125;;</span><br><span class="line">Tea.prototype = new Beverage();</span><br><span class="line">Tea.prototype.brew = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水浸泡茶叶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">Tea.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把茶倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">Tea.prototype.addCondiments = function()&#123;</span><br><span class="line">    console.log(&apos;加柠檬&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">var tea = new Tea();</span><br><span class="line">tea.init();</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="模版方法的使用场景"><a href="#模版方法的使用场景" class="headerlink" title="模版方法的使用场景"></a>模版方法的使用场景</h3><p>从大的方面讲，模板方法常被架构师用于搭建项目的框架，架构师定义好了框架的骨架，程序员继承框架的结构之后，负责往里面填空，比如java程序员大多使用过httpservlet技术来开发项目。<br>一个HttpServlet的程序包含7个生命周期，这7个生命周期分别对应一个do方法。</p>
<ul>
<li>doGet()</li>
<li>doHead()</li>
<li>doPost()</li>
<li>doPut()</li>
<li>doDelete()</li>
<li>doOption()</li>
<li>doTrace()</li>
</ul>
<p>HttpServle类还提供了一个service方法， 它就是这里的模板方法，service规定了这些do方法的执行顺序，而这些do方法的具体实现则需要HttpServet的子类来提供</p>
<hr>
<h3 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h3><p>通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法在正常状态下是适用于大多数子类的，但如果有一些特别“个性”的子类呢？使用钩子方法让子类不受父类约束。在父类中容易变化的地方放置钩子，钩子有一个默认的实现，究竟要不要挂钩，由子类自行决定。钩子方法返回的结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就有了变化的可能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var Beverage = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.boilWater = function()&#123;</span><br><span class="line">    console.log(&apos;把水烧开&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.brew = function()&#123;</span><br><span class="line">    throw new Error(&apos;子类必须重写brew方法&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.pourInCup = function()&#123;</span><br><span class="line">    throw new Error(&apos;子类必须重写pourInCup方法&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.customerWantsCondiments = function()&#123;</span><br><span class="line">    return true; //默认需要调料</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.init = function()&#123;</span><br><span class="line">    this.boilWater();</span><br><span class="line">    this.brew();</span><br><span class="line">    this.pourInCup();</span><br><span class="line">    if(this.customerWantsCondiments())&#123; //如果挂钩返回true，则需要调料</span><br><span class="line">        this.addCondiments(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var CoffeeWithHook = function()&#123;&#125;;</span><br><span class="line">CoffeeWithHook.prototype = new Beverage();</span><br><span class="line">CoffeeWithHook.prototype.brew = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水冲泡咖啡&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">CoffeeWithHook.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把咖啡倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">CoffeeWithHook.prototype.addCondiments = function()&#123;</span><br><span class="line">    console.log(&apos;加🥣和牛奶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">CoffeeWIthHook.prototype.customerWantsCondiments = function()&#123;</span><br><span class="line">    return window.confirm(&apos;请问需要调料吗?&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">var coffeeWithHook = new CoffeeWithHook();</span><br><span class="line">coffeeWithHook.init();</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h3><p>好莱坞原则：允许底层将自己挂钩到高层上，而高层组件会决定什么时候，以何种方式去使用这些底层组件。<br>模板方法模式是好莱坞原则的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法在什么时候被调用。最为子类，只负责提供一些设计上的细节。<br>除此之外，好莱坞原则还常应用于其他模式和场景，例如发布-订阅模式和回调函数</p>
<hr>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式是一种用于性能优化的模式。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。<br>如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常游泳了。在js中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事。</p>
<h3 id="初识享元模式"><a href="#初识享元模式" class="headerlink" title="初识享元模式"></a>初识享元模式</h3><p>不用享元模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var Model = function(sex, underwear)&#123;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">    this.underwear = underwear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Model.prototype.takePhoto = function()&#123;</span><br><span class="line">    console.log(&apos;sex= &apos; + this.sex + &apos; underwear=&apos; + this.underwear);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(var i = 1; i &lt;= 50; i++)&#123;</span><br><span class="line">    var maleModel = new Model(&apos;male&apos;, &apos;underwear&apos; + i);</span><br><span class="line">    maleModel.takePhoto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var j = 1; j &lt;= 50; j++)&#123;</span><br><span class="line">    var femaleModel = new Model(&apos;female&apos;, &apos;underwear&apos; + j);</span><br><span class="line">    femaleModel.takePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用享元模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var Model = function(sex)&#123;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Model.prototype.takePhoto = function()&#123;</span><br><span class="line">    console.log(&apos;sex= &apos; + this.sex + &apos; underwear=&apos; + this.underwear);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var maleModel = new Model(&apos;male&apos;);</span><br><span class="line">var femaleModel = new Model(&apos;female&apos;);</span><br><span class="line"></span><br><span class="line">//共享一个对象</span><br><span class="line">for(var i = 1; i &lt;= 50; i++)&#123;</span><br><span class="line">    maleModel.underwear = &apos;underwear&apos; + i;</span><br><span class="line">    maleModel.takePhoto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var j = 1; j &lt;= 50; j++)&#123;</span><br><span class="line">    femaleModel.underwear = &apos;underwear&apos; + j;</span><br><span class="line">    femaleModel.tablePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="对象爆炸"><a href="#对象爆炸" class="headerlink" title="对象爆炸"></a>对象爆炸</h4><p>微云的文件上传功能虽然可以选择依照队列，一个一个地排队上传，但也支持同时选择2000个文件。每一个文件都对应着一个js上传对象的创建，在第一版的开发中，的确往程序里同时new了2000个upload对象，结果可想而知，Chrome中还勉强能够支撑，IE下直接进入假死状态。<br>微云支持好几种上传方式，比如浏览器插件、flash和表单上传等，为了简化例子，我们先假设只有插件和Flash这两种。不论是插件上传，还是Flash上传，原理都是一样的，当用户选择了文件之后，插件和Flash都回调用window下的一个全局js函数，它的名字叫startUpload，用户选择的文件列表被组合成一个数组files塞进该函数的参数列表里，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var id = 0;</span><br><span class="line">window.startUpload = function(uploadType, files)&#123; //uploadType区分是控件还是flash</span><br><span class="line">    for(var i = 0, file; file = files[i++];)&#123;</span><br><span class="line">        var uploadObj = new Upload(uploadType, file.fileName, file.fileSize);</span><br><span class="line">        uploadObj.init(id++); //给upload对象设置一个唯一的id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义upload构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var Upload = function(uploadType, fileName, fileSize)&#123;</span><br><span class="line">    this.uploadType = uploadType;</span><br><span class="line">    this.fileName = fileName;</span><br><span class="line">    this.fileSize = fileSize;</span><br><span class="line">    this.dom = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Upload.prototype.init = function(id)&#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    this.id = id; </span><br><span class="line">    this.dom = document.createElement(&apos;div&apos;);</span><br><span class="line">    this.dom.innerHTML = &apos;&lt;span&gt;文件名称：&apos;+this.fileName+&apos;,文件大小：&apos;+this.fileSize+&apos;&lt;/span&gt;&apos;+&apos;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;&apos;;</span><br><span class="line">    this.dom.querySelector(&apos;.delFile&apos;).onclick = function()&#123;</span><br><span class="line">        that.delFile();</span><br><span class="line">    &#125;</span><br><span class="line">    document.body.appendChild(this.dom);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>删除文件逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.delFile = function()&#123;</span><br><span class="line">    if(this.fileSize &lt; 3000)&#123;</span><br><span class="line">        return this.dom.parentNode.removeChild(this.dom);</span><br><span class="line">    &#125;</span><br><span class="line">    if(window.confirm(&apos;确定要删除该文件吗？&apos;+this.fileName))&#123;</span><br><span class="line">        return this.dom.parentNode.removeChild(this.dom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来创建3个插件上传对象和3个Flash上传对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">startUpload(&apos;plugin&apos;, [</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;1.txt&apos;,</span><br><span class="line">        fileSize: 1000</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;2.html&apos;,</span><br><span class="line">        fileSize: 3000</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;3.txt&apos;,</span><br><span class="line">        fileSize: 5000</span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">startUpload(&apos;flash&apos;, [</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;4.txt&apos;,</span><br><span class="line">        fileSize: 1000</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;5.html&apos;,</span><br><span class="line">        fileSize: 3000</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;6.txt&apos;,</span><br><span class="line">        fileSize: 5000</span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p>
<h4 id="使用享元模式重构"><a href="#使用享元模式重构" class="headerlink" title="使用享元模式重构"></a>使用享元模式重构</h4><p>先确认内部状态，内、外部状态划分依据：</p>
<ul>
<li>内部状态存储于对象内部。</li>
<li>内部状态可以被一些对象共享</li>
<li>内部状态独立于具体的场景，通常不会改变</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li>
</ul>
<h4 id="剥离外部状态"><a href="#剥离外部状态" class="headerlink" title="剥离外部状态"></a>剥离外部状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Upload = function(uploadType)&#123;</span><br><span class="line">    this.uploadType = uploadType;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.delFile = function(id)&#123;</span><br><span class="line">    uploadManager.setExternalState(id, this); </span><br><span class="line">    if(this.fileSize &lt; 3000)&#123;</span><br><span class="line">        return this.dom.parentNode.removeChild(this.dom);</span><br><span class="line">    &#125;</span><br><span class="line">    if(window.confirm(&apos;确定要删除该文件吗？&apos; + this.fileName))&#123;</span><br><span class="line">        return this.dom.parentNode.removeChild(this.dom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="工厂进行对象实例化"><a href="#工厂进行对象实例化" class="headerlink" title="工厂进行对象实例化"></a>工厂进行对象实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var UploadFactory = (function()&#123;</span><br><span class="line">    var createdFlyWeightObjs = &#123;&#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        create: function(uploadType)&#123;</span><br><span class="line">            if(createdFlyWeightObjs[uploadType])&#123;</span><br><span class="line">                return createdFlyWeightObjs[uploadType];</span><br><span class="line">            &#125;</span><br><span class="line">            return createdFlyWeightObjs[uploadType] = new Upload(uploadType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="管理器封装外部状态"><a href="#管理器封装外部状态" class="headerlink" title="管理器封装外部状态"></a>管理器封装外部状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var uploadManager = (function()&#123;</span><br><span class="line">    var uploadDatabase = &#123;&#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        add: function(id, uploadType, fileName, fileSize)&#123;</span><br><span class="line">            var flyWeightObj = UploadFactory.create(uploadType)</span><br><span class="line">            var dom = document.createElement(&apos;div&apos;);</span><br><span class="line">            dom.innerHTML = &apos;&lt;span&gt;文件名称：&apos;+fileName+&apos;,文件大小：&apos;+fileSize+&apos;&lt;/span&gt;&apos;+&apos;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;&apos;;</span><br><span class="line">            dom.querySelector(&apos;.delFile&apos;).onclick = function()&#123;</span><br><span class="line">                flyWeightObj.delFile(id);</span><br><span class="line">            &#125;</span><br><span class="line">            document.body.appendChild(dom);</span><br><span class="line">            uploadDatabase[id] = &#123;</span><br><span class="line">                fileName: fileName,</span><br><span class="line">                fileSize: fileSize,</span><br><span class="line">                dom: dom</span><br><span class="line">            &#125;;</span><br><span class="line">            return flyWeightObj;</span><br><span class="line">        &#125;,</span><br><span class="line">        setExternalState: function(id, flyWeightOb)&#123;</span><br><span class="line">            var uploadData = uploadDatabase[id];</span><br><span class="line">            for(var i in uploadData)&#123;</span><br><span class="line">                flyWeightObj[i] = uploadData[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">window.startUpload = function(uploadType, files)&#123;</span><br><span class="line">    for(var i = 0, file; file = files[i++];)&#123;</span><br><span class="line">        var uploadObj = uploadManager.add(++id , uploadType, file.fileName, file.fileSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>职责链的定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对西那个练成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。</p>
<h3 id="实际开发中的职责链模式"><a href="#实际开发中的职责链模式" class="headerlink" title="实际开发中的职责链模式"></a>实际开发中的职责链模式</h3><p>假设我们负责一个售卖手机的电商网站，经过分别交纳500元定金和200元定金的两轮预定后（订单已在此时产生），现在已经到了正式购买的阶段。公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过500元定金的用户会收到100元的商城优惠券，200元定金的用户可以收到50元的优惠券，而之前没有支付定金的用户只能进入普通模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。<br>我们的订单页面是PHP吐出的模版，在页面加载之初，PHP会传递给页面几个字段。<br>orderType：表示订单类型（定金用户或普通购买用户），code的值为1的时候是500元定金用户，为2的时候是200元定金用户，为3时为普通用户。<br>pay：表示用户是否已经支付过定金，值为true或者false，虽然用户已经下过500元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。<br>stock： 表示当前用于普通购买的手机库存数量，已经支付过500元或者200元定金的用户不受限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var order = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(orderType === 1)&#123;</span><br><span class="line">        if(pay === true)&#123;</span><br><span class="line">            console.log(&apos;500元定金预购，得到100优惠券&apos;);</span><br><span class="line">        &#125;else&#123; </span><br><span class="line">            if(stock &gt; 0)&#123;</span><br><span class="line">                console.log(&apos;普通购买，无优惠券&apos;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                console.log(&apos;手机库存不足&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(orderType === 2)&#123;</span><br><span class="line">        if(par === true)&#123;</span><br><span class="line">            console.log(&apos;200元定金预购，得到50优惠券&apos;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(stock &gt; 0)&#123;</span><br><span class="line">                console.log(&apos;普通购买，无优惠券&apos;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                console.log(&apos;手机库存不足&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;elseif(orderType === 3)&#123;</span><br><span class="line">        if(stock &gt; 0)&#123;</span><br><span class="line">            console.log(&apos;普通购买，无优惠券&apos;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&apos;手机库存不足&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">order(1,true,500);</span><br></pre></td></tr></table></figure>
<p>虽然我们得到了意料中的运行结果，但这远远算不上一段值得夸奖的代码。order函数不仅巨大到难以阅读，而且需要经常进行修改。虽然目前项目能正常运行，但接下来的维护工作无疑是个梦魇。恐怕只有最新手的程序员才会写出这样的代码。</p>
<h3 id="用职责链模式重构代码"><a href="#用职责链模式重构代码" class="headerlink" title="用职责链模式重构代码"></a>用职责链模式重构代码</h3><p>现在我们采用职责链模式重构这段代码，先把500元订单、200元订单以及普通购买分成3个函数。接下来把orderType、pay、stock这3个字段当作参数传递给500元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的200元订单函数，如果200元订单函数依然不能处理该请求，则继续传递请求给普通购买函数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var order500 = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(orderType === 1 &amp;&amp; pay === true)&#123;</span><br><span class="line">        console.log(&apos;500元定金预约，得到100优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        order200(orderType,pay,stock); //将请求传递给200元订单</span><br><span class="line">        //order200 和 order500耦合</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var order200 = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(orderType === 2 &amp;&amp; pay === true)&#123;</span><br><span class="line">        console.log(&apos;200元定金预购，得到50优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        orderNormal(orderType, pay, stock); //将请求传递给普通订单</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var orderNorNamal = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(stock &gt; 0)&#123;</span><br><span class="line">        console.log(&apos;普通购买，无优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&apos;手机库存不足&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上代码虽然有了进步，但依然违反了开放-封闭原则，如果有一天我们要增加300元预定或者去掉200元预定，意味着就必须改动这些业务函数内部。就像一根环环相扣打了死结的链条，如果要增加、拆除或者移动一个节点，就必须砸烂这根链条。</p>
<h3 id="灵活可拆分的职责链节点"><a href="#灵活可拆分的职责链节点" class="headerlink" title="灵活可拆分的职责链节点"></a>灵活可拆分的职责链节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var order500 = function(orderType, pay. stock)&#123;</span><br><span class="line">    if(orderType === 1 &amp;&amp; pay == true)&#123;</span><br><span class="line">        console.log(&apos;500元定金预购，得到100优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return &apos;nextSuccessor&apos;; //我不知道下一个节点是谁，反正把请求往后传递</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var order200 = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(orderType === 2 &amp;&amp; pay === true)&#123;</span><br><span class="line">        console.log(&apos;200元定金预购，得到50元优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return &apos;nextSuccessor&apos;; //我不知道下一个节点是谁，反正把请求往后传递</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var orderNormal = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(stock &gt; 0)&#123;</span><br><span class="line">        console.log(&apos;普通购买， 无优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&apos;手机库存不足&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来需要把函数包进职责链节点，我们定义一个构造函数Chain，在new Chain的时候传递的参数即为需要被包装的函数，同时它还拥有一个实例属性this.successor，表示在链中的下一个节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var Chain = function(fn)&#123;</span><br><span class="line">    this.fn = fn;</span><br><span class="line">    this.successor = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Chain.prototype.setNextSuccessor = function(successor)&#123; //指定在链中的下一个节点</span><br><span class="line">    return this.successor = successor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Chain.prototype.passRequest = function()&#123; //传递请求给某个节点</span><br><span class="line">    var ret = this.fn.apply(this, arguments);</span><br><span class="line">    if(ret === &apos;nextSuccessor&apos;)&#123;</span><br><span class="line">        //递归</span><br><span class="line">        return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在我们把3个订单函数分别包装成职责链的节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var chainOrder500 = new Chain(order500);</span><br><span class="line">var chainOrder200 = new Chain(order200);</span><br><span class="line">var chainOrderNormal = new Chain(orderNormal);</span><br><span class="line">chainOrder500.setNextSuccessor(chainOrder200);</span><br><span class="line">chainOrder200.setNextSuccessor(chainOrderNormal);</span><br><span class="line">chainOrder500.passRequest(1,true,500);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="用AOP实现职责链"><a href="#用AOP实现职责链" class="headerlink" title="用AOP实现职责链"></a>用AOP实现职责链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.after = function(fn)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var ret = self.apply(this, arguments);</span><br><span class="line">        if(ret === &apos;nextSuccessor&apos;)&#123;</span><br><span class="line">            return fn.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var order = order500yuan.after(order200yuan).after(orderNormal);</span><br><span class="line">order(1,true,500);</span><br></pre></td></tr></table></figure>
<p>用AOP来实现职责链既简单又巧妙，但这种把函数叠在一起的方式，同时也叠加了函数的作用域，如果链条太长的话，也会对性能有较大的影响。</p>
<hr>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>在我们生活中，每个人每个物体之间都会产生一些错综复杂的联系。在应用程序也是一样，程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。<br>面向对象设计鼓励将行为分布到各个对象中，把对象分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度的对象激增，又有可能会反过来降低它们的可复用性。<br><img src="/images/对象与对象之间紧耦合.png" alt><br>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个对象后，所有的相关对象都通过中介者对象来通信，而不是相互引用，所以当一个对象发生变化时，只需要通知终结者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br><img src="/images/中介者模式.png" alt></p>
<hr>
<h3 id="用中介者模式改造泡泡堂游戏"><a href="#用中介者模式改造泡泡堂游戏" class="headerlink" title="用中介者模式改造泡泡堂游戏"></a>用中介者模式改造泡泡堂游戏</h3><p>首先仍然是定义Player构造函数和player对象的原型方法，在player对象的这些原型方法中，不再负责具体的执行逻辑，而是把操作转交给中介者对象，我们把中介者对象命名为playerDIrector:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function Player(name, teamColor)&#123;</span><br><span class="line">    this.name = name; //角色名字</span><br><span class="line">    this.teamColor = teamColor; //队伍颜色</span><br><span class="line">    this.state = &apos;alive&apos;; //玩家生存状态</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Player.prototype.win = function()&#123;</span><br><span class="line">    console.log(this.name + &apos; won&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Player.prototype.lose = function()&#123;</span><br><span class="line">    console.log(this.name + &apos; lost&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**************** 玩家死亡 *****************/</span><br><span class="line">Player.prototype.die = function()&#123;</span><br><span class="line">    this.state = &apos;dead&apos;;</span><br><span class="line">    playerDirectory.receiveMessage(&apos;playerDead&apos;, this); // 给中介者发送消息，玩家死亡</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**************** 移除玩家 *****************/</span><br><span class="line">Player.prototype.remove = function()&#123;</span><br><span class="line">    playerDirectory.receiveMessage(&apos;removeDead&apos;, this); // 给中介者发送消息，移除一个玩家</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*************** 玩家换队 ****************/</span><br><span class="line">Player.prototype.changeTeam = function(color)&#123;</span><br><span class="line">    playerDirectory.receiveMessage(&apos;changeTeam&apos;, this, color); //给中介者发送消息，玩家换队</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再继续改写之前创建玩家对象的工厂函数，可以看到，因为工厂函数里不再需要给创建的玩家对象设置队友和敌人，这个工厂函数几乎失去了工厂的意义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var playerFactory = function(name, teamColor)&#123;</span><br><span class="line">    var newPlayer = new Player(name, teamColor); //创建一个新的玩家对象</span><br><span class="line">    playerDirectory.receiveMessage(&apos;addPlayer&apos;, newPlayer); //给中介者发送消息，新增玩家</span><br><span class="line">    return newPlayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们要实现这个中介者playerDirectory对象，一般有以下两种方式。</p>
<ul>
<li>利用发布-订阅模式。将playerDIrectory实现为订阅者，各player作为发布者，一旦player的状态发生改变，便推送消息给playerDirectory，playerDirectory处理消息后将反馈发送给其他player。</li>
<li>在playerDirectory中开放一些接受消息的接口，各player可以直接调用该接口来给playerDIrectory发送消息，player只需传递一个参数给playerDirectory，这个参数的目的是使playerDirectory可以识别发送着。同样，playerDirectory接收到消息后会将处理结果反馈给其他player。<br>这两种方式的实现本质上没什么区别。在这里我们使用第二种方式，playerDirectory开放一个对外暴露的接口receiveMessage，负责接受player对象发送的消息，而player对象发送消息的时候，总是把自身this作为参数发送给playerDirectory，以便playerDirectory识别消息来自于哪个玩家对象，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">var playerDirectory = (function()&#123;</span><br><span class="line">    var players = &#123;&#125;, //保存所有玩家</span><br><span class="line">        operations = &#123;&#125;; //中介者可以执行的操作</span><br><span class="line">    /************ 新增一个玩家 ***************/</span><br><span class="line">    operations.addPlayer = function(player)&#123;</span><br><span class="line">        var teamColor = player.teamColor; //玩家的队伍颜色</span><br><span class="line">        players[teamColor] = players[teamColor] || []; //如果该颜色的玩家还没有成立队伍，则新成立一个队伍</span><br><span class="line">        players[teamColor].push(player); //添加玩家进队伍</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**************** 移除一个玩家 ***********/</span><br><span class="line">    operations.removePlayer = function(player)&#123;</span><br><span class="line">        var teamColor = player.teamColor, //玩家的队伍颜色</span><br><span class="line">            teamPlayers = players[teamColor] || [];//该队伍所有成员</span><br><span class="line">        for(var i = teamPlayers.length - 1; i &gt;= 0; i --)&#123; //遍历删除</span><br><span class="line">            if(teamPlayer[i] === player)&#123;</span><br><span class="line">                teamPlayer.splice(i, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /************* 玩家换队 **************/</span><br><span class="line">    operations.changeTeam = function(player, newTeamColor)&#123; //玩家换队</span><br><span class="line">        operations.removePlayer(player); //从原队伍中删除</span><br><span class="line">        player.teamColor = newTeamColor; //改变队伍颜色</span><br><span class="line">        operations.addPlayer(player); //增加到新队伍中</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    operations.playerDead = function(player)&#123; //玩家死亡</span><br><span class="line">        var teamColor = player.teamColor,</span><br><span class="line">            teamPlayer = players[teamColor]; // 玩家所在队伍</span><br><span class="line">        var all_dead = true;</span><br><span class="line">        for(var i = 0, player; player = teamPlayers[i++];)&#123;</span><br><span class="line">            if(player.state !== &apos;dead&apos;)&#123;</span><br><span class="line">                all_dead = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(all_dead === true)&#123; //全部死亡</span><br><span class="line">            for(var i = 0, player; player = teamPlayers[i++];)&#123;</span><br><span class="line">                player.lose(); //本队所有玩家lose</span><br><span class="line">            &#125;</span><br><span class="line">            for(var color in players)&#123;</span><br><span class="line">                if(color !== teamColor)&#123;</span><br><span class="line">                    var teamPlayers = players[color]; // 其他队伍的玩家</span><br><span class="line">                    for(var i = 0, player; player = teamPlayers[i++];)&#123;</span><br><span class="line">                        player.win(); //其他队伍所有玩家win</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var receiveMessage = function()&#123;</span><br><span class="line">            var message = Array.prototype.shift.call(arguments); //arguments的第一个参数为消名称</span><br><span class="line">            operations[message].apply(this, arguments);</span><br><span class="line">        &#125;;</span><br><span class="line">        return &#123;</span><br><span class="line">            receiveMessage: receiveMessage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">//红队</span><br><span class="line">var player1 = playerFacotory(&apos;皮蛋&apos;, &apos;red&apos;);</span><br><span class="line">    player2 = playerFacotory(&apos;小乖&apos;, &apos;red&apos;);</span><br><span class="line">    player3 = playerFacotory(&apos;宝宝&apos;, &apos;red&apos;);</span><br><span class="line">    player4 = playerFacotory(&apos;小强&apos;, &apos;red&apos;);</span><br><span class="line"></span><br><span class="line">//蓝队</span><br><span class="line">    player5 = playerFacotory(&apos;黑妞&apos;, &apos;blue&apos;);</span><br><span class="line">    player5 = playerFacotory(&apos;葱头&apos;, &apos;blue&apos;);</span><br><span class="line">    player5 = playerFacotory(&apos;胖墩&apos;, &apos;blue&apos;);</span><br><span class="line">    player5 = playerFacotory(&apos;海盗&apos;, &apos;blue&apos;);</span><br><span class="line"></span><br><span class="line">player1.die();</span><br><span class="line">player2.die();</span><br><span class="line">player3.die();</span><br><span class="line">player4.die();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式可以动态的给每个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。<br>再传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，但超类改变时，子类也会随之改变；另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱复用”是相对可见行而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常破坏了分装性。</p>
<h3 id="模拟传统面向对象语言的装饰着模式"><a href="#模拟传统面向对象语言的装饰着模式" class="headerlink" title="模拟传统面向对象语言的装饰着模式"></a>模拟传统面向对象语言的装饰着模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Plane = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Plane.prototype.fire = function()&#123;</span><br><span class="line">    console.log(&apos;发射普通子弹&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//接下来增加两个装饰类，分别是导弹和原子弹：</span><br><span class="line">var MissileDecorator = function(plane)&#123;</span><br><span class="line">    this.plane = plane;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MissleDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plane.fire();</span><br><span class="line">    console.log(&apos;发射导弹&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var AtomDecorator = function(plane)&#123;</span><br><span class="line">    this.plane = plane;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AtomDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plane.fire();</span><br><span class="line">    console.log(&apos;发射原子弹&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="js装饰者"><a href="#js装饰者" class="headerlink" title="js装饰者"></a>js装饰者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var plane = &#123;</span><br><span class="line">    fire: function()&#123;</span><br><span class="line">        console.log(&apos;发射普通子弹&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var missleDecorator = function()&#123;</span><br><span class="line">    console.log(&apos;发射原子弹&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fire1 = plane.fire;</span><br><span class="line">plane.fire = function()&#123;</span><br><span class="line">    fire1();</span><br><span class="line">    missleDecoretor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fire2 = place.fire;</span><br><span class="line">plane.fire = function()&#123;</span><br><span class="line">    fire2();</span><br><span class="line">    atomDecorator();</span><br><span class="line">&#125;</span><br><span class="line">plane.fire();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="第一个例子：-电灯程序"><a href="#第一个例子：-电灯程序" class="headerlink" title="第一个例子： 电灯程序"></a>第一个例子： 电灯程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var Light = function()&#123;</span><br><span class="line">    this.state = &apos;off&apos;; //给电灯设置初始状态off</span><br><span class="line">    this.button = null; // 电灯开关按钮</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">        self = this;</span><br><span class="line">    button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Light.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    if(this.state === &apos;off&apos;)&#123;</span><br><span class="line">        console.log(&apos;开灯j&apos;);</span><br><span class="line">    &#125;else if(this.state === &apos;on&apos;)&#123;</span><br><span class="line">        console.log(&apos;关灯&apos;);</span><br><span class="line">        this.state = &apos;off&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var light = new Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure>
<h3 id="状态模式改进电灯程序"><a href="#状态模式改进电灯程序" class="headerlink" title="状态模式改进电灯程序"></a>状态模式改进电灯程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">var OffLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OffLightState.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    console.log(&apos;弱光&apos;); //offLightState对应的行为</span><br><span class="line">    this.light.setState(this.light.weakLightState); //切换状态到weakLightState </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var WeakLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">WeakLightState.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    console.log(&apos;强光&apos;); //weakLightState对应的行为</span><br><span class="line">    this.light.setState(this.light.strongLightState); //切换状态到strongLightState</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var StrongLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrongLightState.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    console.log(&apos;关灯&apos;); // strongLightState对应的行为</span><br><span class="line">    this.light.setState(this.light.offLightState);// 切换状态到offLightStatej</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Light = function()&#123;</span><br><span class="line">    this.offLightState = new OffLightState(this);</span><br><span class="line">    this.weakLightState = new WeakLightState(this);</span><br><span class="line">    this.strongLightState = new StrongLightState(this);</span><br><span class="line">    this.button = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">        self = this;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.curState = this.offLightState; //设置当前状态</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.curState.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.setState = function(newState)&#123;</span><br><span class="line">    this.curState = newState;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var light = new Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var googleMap = &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">        console.log(&apos;开始渲染谷歌地图&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var baiduMap = &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">        console.log(&apos;开始渲染百度地图&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var renderMap = function(map)&#123;</span><br><span class="line">    if(map.show instanceof Function)&#123;</span><br><span class="line">        map.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">renderMap(googleMap); //输出： 开始渲染谷歌地图</span><br><span class="line">renderMap(baiduMap); //输出： 开始渲染百度地图</span><br></pre></td></tr></table></figure>
<p>这段程序得以运行大关键是googleMap和baiduMap提供了一致的show方法，但第三方的接口方法并不在我们自己的控制范围之内，假如baiduMap提供的显示地图的方法不叫show而叫display呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var googleMap = &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">        console.log(&apos;开始渲染谷歌地图&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var baiduMap = &#123;</span><br><span class="line">    display: function()&#123;</span><br><span class="line">        console.log(&apos;开始渲染百度地图&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var baiduMapAdapter = &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">        return baiduMap.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap(googleMap);</span><br><span class="line">renderMap(baiduMapAdapter);</span><br></pre></td></tr></table></figure>
<p>另一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var getGuangdongCity = function()&#123;</span><br><span class="line">    var guangdongCity = [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &apos;shenzhen&apos;,</span><br><span class="line">            id: 11,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            name: &apos;guangzhou&apos;,</span><br><span class="line">            id: 12,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line">    return guangdongCity;</span><br><span class="line">&#125;;</span><br><span class="line">var render = function(fn)&#123;</span><br><span class="line">    console.log(&apos;开始渲染广东省地图&apos;);</span><br><span class="line">    document.write(JSON.stringify(fn()));</span><br><span class="line">&#125;;</span><br><span class="line">render(getGuangdongCity);</span><br></pre></td></tr></table></figure></p>
<p>利用这些数据，我们编写了真个页面，并且在线上运行了一段时间。后来发现这些数据不太可靠，里面还缺少很多城市。于是我们又在网上找到了另外一些数据资源，这次的数据更加全面，但遗憾的是，数据结构和正在运行项目中的并不一致。新的数据结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var guangdongCity = &#123;</span><br><span class="line">    shenzhen: 11,</span><br><span class="line">    guangzhou: 12,</span><br><span class="line">    zhuhai: 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了大动干戈地改写渲染页面的前端代码之外，另外一种更轻便的解决方案就是新增一个数据格式转换的适配器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var getGuangdongCity = function()&#123;</span><br><span class="line">    var guangdongCity = [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &apos;shenzhen&apos;,</span><br><span class="line">            id: 11</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            name: &apos;guangdong&apos;,</span><br><span class="line">            id: 12</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line">    return guangdongCity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var render = function(fn)&#123;</span><br><span class="line">    console.log(&apos;开始渲染广东省地图&apos;);</span><br><span class="line">    document.write(JSON.stringify(fn()));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var addressAdapter = function(oldAddressfn)&#123;</span><br><span class="line">    var address = &#123;&#125;,</span><br><span class="line">        oldAddress = oldAddressfn();</span><br><span class="line">    for(var i = 0, c; c = oldAddress[i++];)&#123;</span><br><span class="line">        address[c.name] = c.id;</span><br><span class="line">    &#125;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">render(addressAdapter(getGuangdongCity));</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="开发原则"><a href="#开发原则" class="headerlink" title="开发原则"></a>开发原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有连个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。</p>
<h3 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h3><p>最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块‘函数、变量等。<br>下面引用《面向对象设计原理和模式》一书中的例子来解释最少知识原则：</p>
<blockquote>
<p>某军队中的将军需要挖掘一些散兵坑。下面是完成任务的一种方式：将军可以通知上校让他叫来少校，然后让少校找来少尉，并让上尉通知一个军士，最后军士唤来一个士兵，然后命令士兵挖掘一些散兵坑。</p>
</blockquote>
<p>这种方式十分荒谬，不是吗？不过，我们还是先来看一下这个过程的等价代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">general.getColonel(c).getMajor(m).getCaptain(c).getSergeant(s).getPrivate(p).digFoxHole();</span><br></pre></td></tr></table></figure></p>
<p>让代码通过这么长的消息链才能完成一个任务，这就像让将军通过那么多繁琐的步骤才能命令别人挖掘散兵坑一样荒谬！而且，这条链中任何一个对象的改动都会影响整条链的结果。<br>最有可能的是，将军自己根本不会考虑挖散兵坑这样的细节信息。但是如果将军真的考虑了这个问题的话，他一定会通知某个军官：“我不关心这个工作如何完成，但是你得命令人去挖散兵坑”。</p>
<h3 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h3><p>在面向对象的程序设计中，开放封闭原则（OCP）是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放-封闭原则。<br>开放-封闭原则最早由Eiffel语言的设计者Bertrand Meyer在其著作Object-Oriented Software Constructtion中提出。它的定义如下：</p>
<blockquote>
<p>软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js设计模式与开发实践/" rel="tag"># js设计模式与开发实践</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/12/CMake简单教程/" rel="next" title="CMake简单教程">
                <i class="fa fa-chevron-left"></i> CMake简单教程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/18/原则/" rel="prev" title="原则">
                原则 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">brczo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-text">封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#封装数据"><span class="nav-text">封装数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装实现"><span class="nav-text">封装实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装类型"><span class="nav-text">封装类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装变化"><span class="nav-text">封装变化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型模式与基于原型的继承"><span class="nav-text">原型模式与基于原型的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型编程思想"><span class="nav-text">原型编程思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用克隆的原型模式"><span class="nav-text">使用克隆的原型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#克隆是创建对象的手段"><span class="nav-text">克隆是创建对象的手段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#体验io语言"><span class="nav-text">体验io语言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js中的原型继承"><span class="nav-text">js中的原型继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this的指向"><span class="nav-text">this的指向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#this的种类"><span class="nav-text">this的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为对象的调用"><span class="nav-text">作为对象的调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为普通函数的调用"><span class="nav-text">作为普通函数的调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器调用"><span class="nav-text">构造器调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#all或apply调用"><span class="nav-text">all或apply调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#丢失的this"><span class="nav-text">丢失的this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call和apply"><span class="nav-text">call和apply</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#区别"><span class="nav-text">区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用途"><span class="nav-text">用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-prototype-bind"><span class="nav-text">Function.prototype.bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#借用其他对象的方法"><span class="nav-text">借用其他对象的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#封装变量"><span class="nav-text">封装变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延续局部变量的寿命"><span class="nav-text">延续局部变量的寿命</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包和面向对象设计"><span class="nav-text">闭包和面向对象设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用闭包实现命令模式"><span class="nav-text">用闭包实现命令模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包与内存管理"><span class="nav-text">闭包与内存管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶函数的概念和应用"><span class="nav-text">高阶函数的概念和应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数最为参数传递"><span class="nav-text">函数最为参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数作为返回值输出"><span class="nav-text">函数作为返回值输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高阶函数实现AOP"><span class="nav-text">高阶函数实现AOP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数柯里化"><span class="nav-text">函数柯里化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数节流-分时函数"><span class="nav-text">函数节流 分时函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数节流"><span class="nav-text">函数节流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分时函数"><span class="nav-text">分时函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不透明的单例模式"><span class="nav-text">不透明的单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#透明的单例模式"><span class="nav-text">透明的单例模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#惰性单例"><span class="nav-text">惰性单例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通用惰性加载"><span class="nav-text">通用惰性加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略模式"><span class="nav-text">策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用策略模式计算奖金"><span class="nav-text">使用策略模式计算奖金</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态在策略模式中的体现"><span class="nav-text">多态在策略模式中的体现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#让小球运动起来"><span class="nav-text">让小球运动起来</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表单校验"><span class="nav-text">表单校验</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理模式"><span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#保护代理和虚拟代理"><span class="nav-text">保护代理和虚拟代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟代理实现图片预加载"><span class="nav-text">虚拟代理实现图片预加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代理的意义"><span class="nav-text">代理的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理和本体接口的一致性"><span class="nav-text">代理和本体接口的一致性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟代理合并HTTP请求"><span class="nav-text">虚拟代理合并HTTP请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存代理"><span class="nav-text">缓存代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算乘积"><span class="nav-text">计算乘积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存代理用于ajax异步请求数据"><span class="nav-text">缓存代理用于ajax异步请求数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用高阶函数动态创建代理"><span class="nav-text">用高阶函数动态创建代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他代理模式"><span class="nav-text">其他代理模式</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器模式"><span class="nav-text">迭代器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现自己的迭代器"><span class="nav-text">实现自己的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部迭代器和外部迭代器"><span class="nav-text">内部迭代器和外部迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部迭代器"><span class="nav-text">内部迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外部迭代器"><span class="nav-text">外部迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代类数组对象和字面量对象"><span class="nav-text">迭代类数组对象和字面量对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#倒序迭代器"><span class="nav-text">倒序迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中止迭代器"><span class="nav-text">中止迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器模式的应用举例"><span class="nav-text">迭代器模式的应用举例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布-订阅模式"><span class="nav-text">发布-订阅模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM事件"><span class="nav-text">DOM事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义事件"><span class="nav-text">自定义事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布-订阅模式的通用实现"><span class="nav-text">发布-订阅模式的通用实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网站登陆"><span class="nav-text">网站登陆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局的发布-订阅对象"><span class="nav-text">全局的发布-订阅对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令模式"><span class="nav-text">命令模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命令模式的例子-菜单程序"><span class="nav-text">命令模式的例子  菜单程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏命令"><span class="nav-text">宏命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合模式"><span class="nav-text">组合模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更加强大的宏命令"><span class="nav-text">更加强大的宏命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#透明性带来的安全问题"><span class="nav-text">透明性带来的安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子–扫描文件夹"><span class="nav-text">例子–扫描文件夹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用父对象"><span class="nav-text">引用父对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模版方法"><span class="nav-text">模版方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模板方法模式的定义和组成"><span class="nav-text">模板方法模式的定义和组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#coffee-or-tea"><span class="nav-text">coffee or tea</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Coffee子类和Tea子类"><span class="nav-text">创建Coffee子类和Tea子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模版方法的使用场景"><span class="nav-text">模版方法的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#钩子方法"><span class="nav-text">钩子方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#好莱坞原则"><span class="nav-text">好莱坞原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#享元模式"><span class="nav-text">享元模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初识享元模式"><span class="nav-text">初识享元模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件上传"><span class="nav-text">文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象爆炸"><span class="nav-text">对象爆炸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用享元模式重构"><span class="nav-text">使用享元模式重构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#剥离外部状态"><span class="nav-text">剥离外部状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工厂进行对象实例化"><span class="nav-text">工厂进行对象实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管理器封装外部状态"><span class="nav-text">管理器封装外部状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#职责链模式"><span class="nav-text">职责链模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实际开发中的职责链模式"><span class="nav-text">实际开发中的职责链模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用职责链模式重构代码"><span class="nav-text">用职责链模式重构代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#灵活可拆分的职责链节点"><span class="nav-text">灵活可拆分的职责链节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用AOP实现职责链"><span class="nav-text">用AOP实现职责链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中介者模式"><span class="nav-text">中介者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用中介者模式改造泡泡堂游戏"><span class="nav-text">用中介者模式改造泡泡堂游戏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰者模式"><span class="nav-text">装饰者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟传统面向对象语言的装饰着模式"><span class="nav-text">模拟传统面向对象语言的装饰着模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js装饰者"><span class="nav-text">js装饰者</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态模式"><span class="nav-text">状态模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一个例子：-电灯程序"><span class="nav-text">第一个例子： 电灯程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态模式改进电灯程序"><span class="nav-text">状态模式改进电灯程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#适配器模式"><span class="nav-text">适配器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发原则"><span class="nav-text">开发原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一职责原则"><span class="nav-text">单一职责原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最少知识原则"><span class="nav-text">最少知识原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开放-封闭原则"><span class="nav-text">开放-封闭原则</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">brczo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
