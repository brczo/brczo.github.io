<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="进化">
<meta property="og:url" content="brczo.github.io/page/2/index.html">
<meta property="og:site_name" content="进化">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="进化">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="brczo.github.io/page/2/">





  <title>进化</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">进化</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/19/php设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/19/php设计模式/" itemprop="url">PHP设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-19T09:47:35+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/" itemprop="url" rel="index">
                    <span itemprop="name">PHP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>使用static将单例存在静态存储区 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">    static $singleton = false;</span><br><span class="line">    public static function instance()&#123;</span><br><span class="line">        if(!self::$singleton)&#123;</span><br><span class="line">            return self::$singleton = new self;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return self::$singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = Singleton::instance();</span><br><span class="line">$b = Singleton::instance();</span><br><span class="line">var_dump($a === $b); //true</span><br></pre></td></tr></table></figure>
<p>透明单例模式<strong>错误示范</strong>，会导致无限回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    static $animal;</span><br><span class="line">    public function __construct()&#123;</span><br><span class="line">        if(self::$animal)&#123;</span><br><span class="line">            return self::$animal;</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$animal = new self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new Animal();</span><br><span class="line">$b = new Animal();</span><br><span class="line">var_dump($a === $b);</span><br></pre></td></tr></table></figure></p>
<p>使用代理模式实现单例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;&#125;</span><br><span class="line">function ProxyAnimal()&#123;</span><br><span class="line">    static $animal = false;</span><br><span class="line">    if(!$animal) &#123;</span><br><span class="line">        return $animal = new Animal();</span><br><span class="line">    &#125;</span><br><span class="line">    return $animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$animal1 = Animal();</span><br><span class="line">$animal2 = Animal();</span><br><span class="line">var_dump($animal1 === $animal2); //true</span><br></pre></td></tr></table></figure></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Strategies &#123;</span><br><span class="line">    public funciton php()&#123;</span><br><span class="line">        echo &apos;用php解决&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function go()&#123;</span><br><span class="line">        echo &apos;用go解决&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function python()&#123;</span><br><span class="line">        echo &apos;用python解决&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>context类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Context &#123;</span><br><span class="line">    public $strategy;</span><br><span class="line">    public function setStrategy($strategy)&#123;</span><br><span class="line">        $this-&gt;strategy = $strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public function web() &#123;</span><br><span class="line">        (new Strategy)-&gt;&#123;$this-&gt;strategy&#125;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>简单代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//想吃面包又懒得去买的我。</span><br><span class="line">class me &#123;</span><br><span class="line">    public function buyBread()&#123;</span><br><span class="line">        //那就让女朋友去买吧</span><br><span class="line">        (new girlFriend())-&gt;buyBread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 女朋友</span><br><span class="line">class girlFriend &#123;</span><br><span class="line">    public function buyBread()&#123;</span><br><span class="line">       (new shop())-&gt;cuiyiban()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//商店</span><br><span class="line">class shop &#123;</span><br><span class="line">    public function cuoyiban()&#123;</span><br><span class="line">        echo &apos;买到搓衣板&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//(^○^) 喔， 好爽。</span><br><span class="line">$me = (new me())-&gt;buyBread();</span><br></pre></td></tr></table></figure>
<p>虚拟代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 贾跑跑没有钱，但他很会忽悠</span><br><span class="line">class jiapaopao &#123;</span><br><span class="line">    public function investor()&#123;</span><br><span class="line">        (new investors)-&gt;investor)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 投资方有钱，但容易被忽悠</span><br><span class="line">class investors &#123;</span><br><span class="line">    public $money;</span><br><span class="line">    public function investor()&#123;</span><br><span class="line">        (new market())-&gt;eat($this-&gt;money);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 难预测的市场</span><br><span class="line">class market &#123;</span><br><span class="line">    public function eat($money)&#123;</span><br><span class="line">        echo &apos;好吃&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>策略模式 + 缓存代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class strategies &#123;</span><br><span class="line">    public function mult() &#123;</span><br><span class="line">        echo &apos;计算乘积&apos;;</span><br><span class="line">        echo PHP_EOL;</span><br><span class="line">        $args = explode(&apos;,&apos;, func_get_args()[0]);</span><br><span class="line">        $a = 1;</span><br><span class="line">        foreach($args as $val) &#123;</span><br><span class="line">            $a *= $val;</span><br><span class="line">        &#125;</span><br><span class="line">        return $a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function plus() &#123;</span><br><span class="line">        echo &apos;计算和&apos;;</span><br><span class="line">        echo PHP_EOL;</span><br><span class="line">        $args = explode(&apos;,&apos;, func_get_args()[0]);</span><br><span class="line">        $a = 1;</span><br><span class="line">        foreach($args as $val)&#123;</span><br><span class="line">            $a += $val;</span><br><span class="line">        &#125;</span><br><span class="line">        return $a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class proxyCache &#123;</span><br><span class="line">    private $cache = [];</span><br><span class="line">    private $strategy;</span><br><span class="line">    private $strategies;</span><br><span class="line"></span><br><span class="line">    public function __construct($strategy)&#123;</span><br><span class="line">        $this-&gt;strategies = new strategies();</span><br><span class="line">        $this-&gt;strategy = $strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function count()&#123;</span><br><span class="line">        $args = implode(&apos;,&apos;, func_get_args()[0]);</span><br><span class="line">        if(array_key_exists($args, $this-&gt;cache))&#123;</span><br><span class="line">            return $this-&gt;cache[$args];</span><br><span class="line">        &#125;</span><br><span class="line">        return $this-&gt;cache[$args] = $this-&gt;strategies-&gt;&#123;$this-&gt;strategy&#125;($args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __call($name, $args)&#123;</span><br><span class="line">        return $this-&gt;count($args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$multProxy = new proxyCache(&apos;mult&apos;);</span><br><span class="line">var_dump($multProxy-&gt;mult(1,2,3,4));</span><br><span class="line">var_dump($multProxy-&gt;mult(1,2,3,4));</span><br><span class="line"></span><br><span class="line">$plusProxy = new proxyCache(&apos;plus&apos;);</span><br><span class="line">var_dump($plusProxy-&gt;plus(1,2,3,4));</span><br><span class="line">var_dump($plusProxy-&gt;plus(1,2,3,4));</span><br></pre></td></tr></table></figure></p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>php内置了iterator迭代器接口，可以通过iterator接口自定义迭代器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class myIterator implements Iterator &#123;</span><br><span class="line">    private $position;</span><br><span class="line">    private $array = [</span><br><span class="line">        &apos;first&apos;,</span><br><span class="line">        &apos;second&apos;,</span><br><span class="line">        &apos;third&apos;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    public function __construct()&#123;</span><br><span class="line">        $this-&gt;position = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function current()&#123;</span><br><span class="line">        return $array[$this-&gt;position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function next()&#123;</span><br><span class="line">        ++ $this-&gt;position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function key()&#123;</span><br><span class="line">        return $this-&gt;position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function rewind()&#123;</span><br><span class="line">        $this-&gt;position = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function valid()&#123;</span><br><span class="line">        return isset($this-&gt;array[$this-&gt;position]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$it = new myIterator();</span><br><span class="line"></span><br><span class="line">foreach($it as $k=&gt;$v)&#123;</span><br><span class="line">    var_dump($k, $v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'更新'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distributor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $subscribers = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">(Subscriber $sub)</span></span>&#123;</span><br><span class="line">        array_push($subscribers, $sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;subscribers <span class="keyword">as</span> $sub) &#123;</span><br><span class="line">            $sub-&gt;update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> Subcriber();</span><br><span class="line">$b = <span class="keyword">new</span> Subcriber();</span><br><span class="line">$dis = <span class="keyword">new</span> Distributor();</span><br><span class="line">$dis-&gt;register($a);</span><br><span class="line">$dis-&gt;register($b);</span><br><span class="line">$dis-&gt;notice();</span><br></pre></td></tr></table></figure>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ArtificialSun &#123; //命令接受着</span><br><span class="line">    public function sunLight()&#123;</span><br><span class="line">        echo &apos;发光&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class getSunLightCommand &#123;</span><br><span class="line">    private $receiver;</span><br><span class="line"></span><br><span class="line">    public function __construct($receiver)&#123;</span><br><span class="line">        $this-&gt;receiver = $receiver;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function execute()&#123;</span><br><span class="line">        $this-&gt;receiver-&gt;sunLight(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class setCommand &#123; //命令绑定</span><br><span class="line">    private $command;</span><br><span class="line">    public function setUp($command)&#123;</span><br><span class="line">        $this-&gt;command = $command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function run()&#123;</span><br><span class="line">        $this-&gt;command-&gt;execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$receiver = new ArtificialSun();</span><br><span class="line">$command = new getSunLightCommand($receiver);</span><br><span class="line">$setCommand = new setCommand();</span><br><span class="line">$setCommand-&gt;setUp($command);</span><br><span class="line">$setCommand-&gt;run();</span><br></pre></td></tr></table></figure>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">abstract class Component&#123;</span><br><span class="line">    abstract public function add(Component $child)&#123;&#125;</span><br><span class="line">    abstract public function remove(Component $child)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Composite extends Component&#123; //组合对象</span><br><span class="line">    private $childs = [];</span><br><span class="line">    public function add(Component $child)&#123;</span><br><span class="line">        array_push($this-&gt;childs, $child); </span><br><span class="line">    &#125;</span><br><span class="line">    public function remove(Component $theChild)&#123;</span><br><span class="line">        $childs = $this-&gt;childs;</span><br><span class="line">        for($l = count($childs) - 1; $l &gt;= 0; $l --)&#123;</span><br><span class="line">            if($theChild === $childs[$l])&#123;</span><br><span class="line">                array_splice($childs, $l, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Leaf extends Component&#123; //叶对象</span><br><span class="line">    public function add(Component $child)&#123;</span><br><span class="line">        throw new Exception(&apos;叶对象不能再添加子对象&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    public function remove(Component $child)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>就是抽象方法+具体方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">abstract class Beverage &#123;</span><br><span class="line">    public final function init()&#123;</span><br><span class="line">        $this-&gt;boilWater();</span><br><span class="line">        $this-&gt;brew();</span><br><span class="line">        $this-&gt;pourInCup();</span><br><span class="line">        $this-&gt;addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function boilWater()&#123;</span><br><span class="line">        echo &apos;把水煮沸&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract public function brew(); </span><br><span class="line">    abstract public function pourInCup();</span><br><span class="line">    abstract public function addCondiments();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Coffee extends Beverage &#123;</span><br><span class="line">    public function brew()&#123;</span><br><span class="line">        echo &apos;沸水冲泡咖啡&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function pourInCup()&#123;</span><br><span class="line">        echo &apos;把咖啡倒进杯中&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function addCondiments()&#123;</span><br><span class="line">        echo &apos;加糖和牛奶&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tea extends Beverage&#123;</span><br><span class="line">    public function brew()&#123;</span><br><span class="line">        echo &apos;沸水泡茶&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function pourInCup()&#123;</span><br><span class="line">        echo &apos;把茶水倒进杯子&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function addCondiments()&#123;</span><br><span class="line">        echo &apos;加柠檬&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式通过共用对象，减少了性能消耗，是改善性能的利器之一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">    private $type;</span><br><span class="line"></span><br><span class="line">    public function __construct(string $type)&#123;</span><br><span class="line">        $this-&gt;type = $type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function say(string $name)&#123;</span><br><span class="line">        echo &apos;我是&apos;.$this-&gt;type.&apos;我的名字叫&apos;.$name;</span><br><span class="line">        echo PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FlyWeightFactory &#123;</span><br><span class="line">    private $objs = [];</span><br><span class="line">    public function create(string $type)&#123;</span><br><span class="line">        $objs = $this-&gt;objs;</span><br><span class="line">        if($objs[$type]??[])&#123;</span><br><span class="line">            return $objs[$type];</span><br><span class="line">        &#125;</span><br><span class="line">        return $this-&gt;objs[$type] = new People($type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$flyWeightFactory = new FlyWeightFactory();</span><br><span class="line">$student = $flyWeightFactory-&gt;create(&apos;student&apos;);</span><br><span class="line">$student-&gt;say(&apos;小明&apos;);</span><br><span class="line">$student = $flyWeightFactory-&gt;create(&apos;teacher&apos;);</span><br><span class="line">$student-&gt;say(&apos;老湿&apos;);</span><br></pre></td></tr></table></figure></p>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Order &#123;</span><br><span class="line">    function order500(int $orderType, bool $pay, int $stock)&#123;</span><br><span class="line">        if($orderType === 1 &amp;&amp; $pay === true)&#123;</span><br><span class="line">            echo &apos;500元预定金，优惠券100元&apos;;</span><br><span class="line">            echo PHP_EOL;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return $this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function order200(int $orderType, bool $pay, int $stock)&#123;</span><br><span class="line">        if($orderType === 2 &amp;&amp; $pay === true)&#123;</span><br><span class="line">            echo &apos;200元预定金，优惠券100元&apos;;</span><br><span class="line">            echo PHP_EOL;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return $this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function orderNormal(int $orderType, bool $pay, int $stock)&#123;</span><br><span class="line">        if($stock &gt; 0)&#123;</span><br><span class="line">            echo &apos;普通购买，无优惠券&apos;;</span><br><span class="line">            echo PHP_EOL;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            echo &apos;手机库存不足&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Chain &#123;</span><br><span class="line">    private $fn;</span><br><span class="line">    private $successor;</span><br><span class="line">    function __construct(callable $fn)&#123;</span><br><span class="line">        $this-&gt;fn = $fn; </span><br><span class="line">    &#125;</span><br><span class="line">    function setSuccessor($successor)&#123;</span><br><span class="line">        $this-&gt;successor = $successor; </span><br><span class="line">    &#125;</span><br><span class="line">    function passRequest(int $orderType, int $pay, int $stock)&#123;</span><br><span class="line">        $fn = $this-&gt;fn;</span><br><span class="line">        $ret = $fn($orderType, $pay, $stock);</span><br><span class="line">        $ret &amp;&amp; $this-&gt;successor-&gt;passRequest($orderType, $pay, $stock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$order = new Order();</span><br><span class="line">$chain500 = new Chain([$order, &apos;order500&apos;]);</span><br><span class="line">$chain200 = new Chain([$order, &apos;order200&apos;]);</span><br><span class="line">$chainNormal = new Chain([$order, &apos;orderNormal&apos;]);</span><br><span class="line">$chain500-&gt;setSuccessor($chain200);</span><br><span class="line">$chain200-&gt;setSuccessor($chainNormal);</span><br><span class="line">$chain500-&gt;passRequest(1, true, 500);</span><br></pre></td></tr></table></figure>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Plane &#123;</span><br><span class="line">    public function fire()&#123;</span><br><span class="line">        echo &apos;发射普通子弹&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MissleDecorator = function(Plane $plane)&#123;</span><br><span class="line">    $plane.fire();</span><br><span class="line">        echo &apos;发射导弹&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public function do()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    public function go()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BAdapter &#123;</span><br><span class="line">    public function do()&#123;</span><br><span class="line">        new B()-&gt;go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function exec($obj)&#123;</span><br><span class="line">    $obj-&gt;do();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exec(new A());</span><br><span class="line">exec(new BAdapter());</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/18/原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/原则/" itemprop="url">原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T18:44:22+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/改善思维方式/" itemprop="url" rel="index">
                    <span itemprop="name">改善思维方式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用五步实现你的人生愿望"><a href="#用五步实现你的人生愿望" class="headerlink" title="用五步实现你的人生愿望"></a>用五步实现你的人生愿望</h2><blockquote>
<p><strong>有明确的目标</strong>。<br><strong>找到阻碍你实现这些目标的问题，并且不容忍问题</strong>。<br><strong>准确诊断问题，找到问题的根源</strong>。<br><strong>规划可以解决问题的方案</strong><br><strong>做一切必要的事来践行这些方案，实现成果</strong>。</p>
</blockquote>
<h3 id="有明确的目标"><a href="#有明确的目标" class="headerlink" title="有明确的目标"></a>有明确的目标</h3><blockquote>
<p><strong>排列优先顺序：尽管你几乎可以得到你想要的任何东西，但你不可能得到你想要的所有东西。</strong><br><strong>不要混淆目标和欲望。</strong>合理的目标是你真正需要实现的东西，欲望则是你想要但会组织你实现目标的东西。<br><strong>调和你的目标和欲望，以明确你在生活中真正想要的东西。</strong>以激情为例。没有激情的生活枯燥无味，你不会愿意过，但关键在于如何处理自己的激情。是让激情消耗你，驱使你作出不理性的行为，还是驾驭激情，从而得到动力来追求你真正的目标？<br><strong>不要把成功的装饰误认为成功本身。</strong><br><strong>永远不要因为你觉得某个目标无法实现就否决它。</strong><br><strong>谨记伟大的期望创造伟大的能力。</strong><br><strong>如果你拥有灵活性并自我归责，那么几乎没有什么能组织你成功。</strong>灵活性能让你接受现实给你教益。自我归责很重要，如果你真的相信未能实现某个目标是你自己的失败，那么你就可以把这一失败视为一个提醒，它说明，相对于你的任务而言，你的创造性、灵活性和坚定性还不够。<br><strong>知道如何对待挫折和知道如何前进一样重要。</strong>有时你知道你正在不可避免地走向一场大挫败。生活中总会遇到这样的挑战，有的挑战在当时看来似乎就有毁灭性。在逆境中，你的目标应该是守住自己的成绩，尽量减少损失，或者直面不可挽回的损失。</p>
</blockquote>
<h3 id="找出问题，并且不容忍问题"><a href="#找出问题，并且不容忍问题" class="headerlink" title="找出问题，并且不容忍问题"></a>找出问题，并且不容忍问题</h3><blockquote>
<p><strong>把令人痛苦的问题视为考验你的潜在进步机会。</strong>尽管你一开始不这么认为，但你遇到的每个问题都是一个机会。因此你必须把问题摆在桌面上。<br><strong>不要逃避问题，因为问题根植于看起来并不美好的残酷现实。</strong><br><strong>要精准的找到问题所在。</strong><br><strong>不要把问题的某个原因误认为问题本身。</strong><br><strong>区分大问题和小问题。</strong><br><strong>找出一个问题后，不要容忍问题。</strong></p>
</blockquote>
<h3 id="诊断问题，找到问题的根源"><a href="#诊断问题，找到问题的根源" class="headerlink" title="诊断问题，找到问题的根源"></a>诊断问题，找到问题的根源</h3><blockquote>
<p><strong>先把问题是什么弄明白，再决定怎么做。</strong><br><strong>区分直接原因和根本原因。</strong><br><strong>认识到了解人的特性，有助于对其形成合理预期。</strong>对你自己作出评价，包括你自己。</p>
</blockquote>
<h3 id="规划方案"><a href="#规划方案" class="headerlink" title="规划方案"></a>规划方案</h3><blockquote>
<p><strong>前进之前先回顾。</strong><br><strong>把你的问题看作你部分机器产生的一系列结果。</strong><br><strong>谨记实现你的目标通常有很多途径。</strong><br><strong>把你的方案设想为一个电影剧本，然后循序渐进的思考由谁来做什么事。</strong><br><strong>把你的方案写下来，让所有人都看得到，并对照方案执行。</strong><br><strong>要明白，规划好一个方案不一定需要很多时间。</strong></p>
</blockquote>
<h3 id="坚定的从头到尾执行方案"><a href="#坚定的从头到尾执行方案" class="headerlink" title="坚定的从头到尾执行方案"></a>坚定的从头到尾执行方案</h3><blockquote>
<p><strong>规划做得再好，不执行也无济于事。</strong><br><strong>良好的工作习惯的重要性常被大大低估。</strong><br><strong>建立清晰的衡量标准来确保你在严格执行方案。</strong></p>
</blockquote>
<h3 id="谨记：如果你找到了解决方案，弱点是不重要的"><a href="#谨记：如果你找到了解决方案，弱点是不重要的" class="headerlink" title="谨记：如果你找到了解决方案，弱点是不重要的"></a>谨记：如果你找到了解决方案，弱点是不重要的</h3><p>你几乎肯定不可能把每一步都做好，因为每一步都要求不同类型的思维，而几乎没有人能擅长所有这些思维。每个人都有弱点。人们犯错误的类型通常能揭示他们的缺点在哪里。</p>
<blockquote>
<p><strong>考察你犯错误的类型，并识别你通常在五步流程中的哪一步上做的不好。</strong><br><strong>每个人都至少有一个最大的弱点阻碍其成功，找到你的这个弱点并处理它</strong></p>
</blockquote>
<h3 id="理解你和其他人的“意境地图”与谦逊性"><a href="#理解你和其他人的“意境地图”与谦逊性" class="headerlink" title="理解你和其他人的“意境地图”与谦逊性"></a>理解你和其他人的“意境地图”与谦逊性</h3><p>有的人很擅长自己把问题和解决办法搞明白，这样的人拥有良好的“意境地图”。同时，还有一些人比其他人更谦逊，头脑更开放。如果谦逊能引导你找到比自己想出来的更好的解决方案的话，就可以说谦逊比拥有良好的意境地图更大。既头脑开放又拥有良好的“意境地图”的人是最强大的 。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/15/js设计模式与开发实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/js设计模式与开发实践/" itemprop="url">js设计模式与开发实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T11:04:50+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装的目的是将信息隐藏，包括隐藏数据、实现细节、设计细节以及对象的类型。</p>
<h3 id="封装数据"><a href="#封装数据" class="headerlink" title="封装数据"></a>封装数据</h3><p>js依赖变量的作用域来实现封装特性，而且只能模拟出public和private两种封装性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = (function()&#123;</span><br><span class="line">    let _name = &apos;jack&apos;; // 私有（private）变量</span><br><span class="line">    return &#123;</span><br><span class="line">        getName: function()&#123;  // 公开（public）方法</span><br><span class="line">            return _name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(obj.getName()); //输出：jack</span><br><span class="line">console.log(obj._name); // 输出：undefined</span><br></pre></td></tr></table></figure></p>
<h3 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h3><p>封装实现使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对他自己的行为负责。其他对象或用户不关心它的内部实现。</p>
<h3 id="封装类型"><a href="#封装类型" class="headerlink" title="封装类型"></a>封装类型</h3><p>封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口 来进行的1。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象 的行为。在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生 5 的原因之一。比如工厂方法模式、组合模式等。</p>
<h3 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h3><p>从设计模式 的角度出发，封装在更重要的层面体现为封装变化。设计模式可分为：</p>
<ul>
<li>创建型模式 目的是封装创建对象的变化</li>
<li>结构型模式 封装对象之间的组合关系</li>
<li>行为型模式 封装对象的行为变化</li>
</ul>
<h2 id="原型模式与基于原型的继承"><a href="#原型模式与基于原型的继承" class="headerlink" title="原型模式与基于原型的继承"></a>原型模式与基于原型的继承</h2><h3 id="原型编程思想"><a href="#原型编程思想" class="headerlink" title="原型编程思想"></a>原型编程思想</h3><p>在以类为中心的面向对象编程语言中，类和对象关系可以想象成铸模与铸件的关系，对象总是从类中创建而来。而在原型编程思想中，类不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。<br>原型模式不单是一种设计模式，也被称为一种编程范型。</p>
<h3 id="使用克隆的原型模式"><a href="#使用克隆的原型模式" class="headerlink" title="使用克隆的原型模式"></a>使用克隆的原型模式</h3><p>ECMAScript5使用了Object.create方法，可以用来克隆对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Plane = function()&#123;</span><br><span class="line">    this.blood = 100;</span><br><span class="line">    this.attackLevel = 1;</span><br><span class="line">    this.defenseLevel = 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var plane = new Plane();</span><br><span class="line">plane.blood = 500;</span><br><span class="line">plane.attackLevel = 10;</span><br><span class="line">plane.defenseLevel = 7;</span><br><span class="line"></span><br><span class="line">var clonePlane = Object.create(plane); //克隆对象</span><br></pre></td></tr></table></figure></p>
<h3 id="克隆是创建对象的手段"><a href="#克隆是创建对象的手段" class="headerlink" title="克隆是创建对象的手段"></a>克隆是创建对象的手段</h3><h4 id="体验io语言"><a href="#体验io语言" class="headerlink" title="体验io语言"></a>体验io语言</h4><p>原型不仅仅是一种设计模式还是一种编程范型。js就是使用原型模式来搭建整个面向对象的系统的。<br>基于根对象，创建一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io&gt; Animal := Object clone;</span><br><span class="line">Animal makeSound := method(&quot;animal makeSound&quot; print);</span><br></pre></td></tr></table></figure></p>
<p>基于Animal对象创建一个Dog对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io&gt; Dog := Animal clone;</span><br><span class="line">Dog eat := method(&quot;dog eat&quot; printf);</span><br></pre></td></tr></table></figure></p>
<p>原型链<br>Object是Animal的原型，而Animal是Dog的原型，他们之间构成一条原型链。</p>
<h3 id="js中的原型继承"><a href="#js中的原型继承" class="headerlink" title="js中的原型继承"></a>js中的原型继承</h3><p><strong>所有数据都是对象。</strong>按照js设计者的本意， 除了undefined之外，js中一切都是对象。js中的根对象是Object.prototype。Object.prototype是一个空对象。我们遇到的每个对象其实都是从Object.prototype对象克隆而来。Object.prototype对象就是他们的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = &#123;&#125;;</span><br><span class="line">console.log(Object.getPrototypeOf(obj1) === Object.prototype ); //输出： true</span><br><span class="line">console.log(Object.getPrototypeOf(obj2) === Object.prototype ); //输出： true</span><br></pre></td></tr></table></figure>
<p><strong>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = new Person(&quot;jack&quot;);</span><br><span class="line">console.log(a.name); //输出jack</span><br><span class="line">console.log(a.getName); //输出jack</span><br><span class="line">console.log(Object.getPrototypeOf(a) === Person.prototype); //输出：true</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，<strong>Person不是类，而是函数构造</strong>，js中的函数既可以作为普通函数使用，也可以作为构造器被调用。用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype对象，在进行额外的操作。<strong>对象会记住它的原型</strong>。js给对象提供了一个名为<strong>proto</strong>的隐藏属性，某个对象的<strong>proto</strong>属性默认会指向它的构造器的原型对象。在Chrome中，<strong>proto</strong>会被公开出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = new Object();</span><br><span class="line">console.log(a.__proto__ === Object.prototype); 输出 true</span><br></pre></td></tr></table></figure></p>
<p><strong>如果某个对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</strong>这条是原型继承的精髓。原型继承方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name: &apos;jack&apos;&#125;;</span><br><span class="line">var A = function()&#123;&#125;;</span><br><span class="line">A.prototype = obj;</span><br><span class="line"></span><br><span class="line">var a = new A();</span><br><span class="line">console.log(a.name); //输出： jack</span><br></pre></td></tr></table></figure></p>
<p>以上代码中，引擎做了哪些：</p>
<ul>
<li>首先尝试遍历对象a中的所有属性，但没有找到name这个属性</li>
<li>查找name属性的这个请求被委托给对象a的构造器的原型，它被a.<strong>proto</strong>记录着，指向A.protype,而A.prototype被设置为对象obj</li>
<li>在obj对象中找到了name属性，并返回它的值。</li>
</ul>
<h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><h3 id="this的种类"><a href="#this的种类" class="headerlink" title="this的种类"></a>this的种类</h3><ul>
<li>作为对象的方法调用</li>
<li>作为普通的函数调用</li>
<li>构造器调用</li>
<li>Function.prototype.call 或 Function.prototype.apply调用</li>
</ul>
<h3 id="作为对象的调用"><a href="#作为对象的调用" class="headerlink" title="作为对象的调用"></a>作为对象的调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    getA: function()&#123;</span><br><span class="line">        console.log(this === obj); //输出true</span><br><span class="line">        console.log(this.a); //输出1</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure>
<h3 id="作为普通函数的调用"><a href="#作为普通函数的调用" class="headerlink" title="作为普通函数的调用"></a>作为普通函数的调用</h3><p>执行getName函数时，函数内没有那么属性，js引擎沿着作用域链向上查找name属性，直到最顶端的window对象，有则输出，无则输出undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.name = &apos;globalName&apos;;</span><br><span class="line">var getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(getName()); //输出globalName</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.name = &apos;globalName&apos;;</span><br><span class="line">var myObj = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var getName = myObj.getName; </span><br><span class="line">console.log(getName()); //输出：globalName</span><br></pre></td></tr></table></figure></p>
<p>有时，我们会遇到一些困扰，比如在div节点的事件函数内部，有一个局部的callback方法，callback被作为普通函数调用时，callback内部的this指向了window，但我们往往是想让它指向该div节点，见如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;div1&quot;&gt;我是一个div&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.id = &apos;window&apos;;</span><br><span class="line">        document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">            console.log(this.id); //输出：&apos;div1&apos;</span><br><span class="line">            var callback = function()&#123;</span><br><span class="line">                console.log(this.id);  //输出：window</span><br><span class="line">            &#125;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>解决方法是通过闭包将节点保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">    console.log(this.id); //输出：&apos;div1&apos;</span><br><span class="line">    var _self = this;</span><br><span class="line">    var callback = function()&#123;</span><br><span class="line">        console.log(_self.id);  //输出：window</span><br><span class="line">    &#125;</span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在严格模式下（”use strict”），这种情况下this是undefined</p>
<h3 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myClass = function()&#123;</span><br><span class="line">    this.name = &apos;jack&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var obj = new myClass();</span><br><span class="line">console.log(obj.name); //输出 jack</span><br></pre></td></tr></table></figure>
<p>用new调用构造器需注意一个问题，如果构造器显式的返回一个obj类型，那么此次运行结果最终会返回这个对象，而不是我们之前期待的this：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myClass = function()&#123;</span><br><span class="line">    this.name = &apos;jack&apos;;</span><br><span class="line">    return &#123; //显示的返回一个对象</span><br><span class="line">        name: &apos;marry&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var obj = new myClass();</span><br><span class="line">console.log(obj.name); //输出：marry</span><br></pre></td></tr></table></figure></p>
<h3 id="all或apply调用"><a href="#all或apply调用" class="headerlink" title="all或apply调用"></a>all或apply调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    name: &apos;marry&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj1.getName()); //输出：Jack</span><br><span class="line">console.log(obj1.getName.call(obj2)); //输出 marry</span><br></pre></td></tr></table></figure>
<h3 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    myName: &apos;jack&apos;,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        return this.myName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.getName()); //输出：jack</span><br><span class="line">var getName2 = obj.getName;</span><br><span class="line">console.log(getName2()); //输出 undefined</span><br></pre></td></tr></table></figure>
<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Function.prototype.call和Function.prototype.apply都是非常常用的方法。它们的作用一模一样，区别在于传入参数形式的不同。<br>apply接受两个参数，第一个指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，zpply方法把这个集合中的元素作为参数传递给被调用函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a, b ,c)&#123;</span><br><span class="line">    alert([a,b,c]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.apply(null, [1,2,3]);</span><br></pre></td></tr></table></figure></p>
<p>call传入的参数不固定，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a,b,c)&#123;</span><br><span class="line">    alert([a,b,c]);</span><br><span class="line">&#125;</span><br><span class="line">func.call(null, 1, 2, 3);</span><br></pre></td></tr></table></figure></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul>
<li><p>改变this的指向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    name: &apos;amme&apos;</span><br><span class="line">&#125;;</span><br><span class="line">window.name = &apos;window&apos;;</span><br><span class="line">var getName = function()&#123;</span><br><span class="line">    alter(this.name);</span><br><span class="line">&#125;</span><br><span class="line">getName(); // 输出window</span><br><span class="line">getName.call(obj1);//输出 jack</span><br><span class="line">getName.call(obj2);//输出 amme</span><br></pre></td></tr></table></figure>
</li>
<li><p>修正this的指向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">    alert(this.id); //输出 div1</span><br><span class="line">    var func = function()&#123;</span><br><span class="line">        alert(this.id); //输出：undefined</span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在事件内部调用func函数时，func函数体内的this指向了window，而不是我们预期的div，这时候我们要用call或apply修正<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">    alert(this.id); //输出 div1</span><br><span class="line">    var func = function()&#123;</span><br><span class="line">        alert(this.id); //输出：undefined</span><br><span class="line">    &#125;</span><br><span class="line">    func.call(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h3><p>大部分高级浏览器都实现了内置的Function.prototype.bind，用来指定函数内部的this指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context) &#123;</span><br><span class="line">    var self = this; //保存原函数</span><br><span class="line">    return function()&#123; //返回一个新的函数</span><br><span class="line">        return self.apply(context, arguments); //执行新的函数的时候，会把之前传入的context当作新函数体内的this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;jack&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var func = function()&#123;</span><br><span class="line">    alert(this.name); //输出： jack</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p>
<h3 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h3><p>借用构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var A = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = function()&#123;</span><br><span class="line">    A.apply(this, arguments);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.prototype.getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var b = new B(&apos;jack&apos;);</span><br><span class="line">console.log(b.getName()); //输出 ‘jack&apos;</span><br></pre></td></tr></table></figure></p>
<p>使用Array.prototype.push.call<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    Array.prototype.push.call(arguments, 3);</span><br><span class="line">    console.log(arguments); //输出 【1, 2, 3]</span><br><span class="line">&#125;)(1,2)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>变量有作用域和生存周期，如果函数内的变量在函数执行完后没有被销毁，这就产生了闭包 </p>
<ul>
<li>变量的作用域。变量的作用域指的是变量的有效范围</li>
<li>变量的生存周期。全局变量，局部变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function()&#123;</span><br><span class="line">    var a = 1; //退出函数后局部变量a将被销毁</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var func = function()&#123; //闭包，函数执行完后变量未被销毁</span><br><span class="line">		var a = 1;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        a++;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var f = func();</span><br><span class="line">f(); //输出：2</span><br><span class="line">f(); //输出：3</span><br><span class="line">f(); //输出：4÷</span><br></pre></td></tr></table></figure>
<p>经典应用，js的onclick事件是异步的，是在for循环后执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;3&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;4&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var nodes = document.getElementsByTagName(&apos;div&apos;);</span><br><span class="line">        //不使用闭包</span><br><span class="line">        for(var i = 0, len = nodes.length; i &lt; len; i ++)&#123;</span><br><span class="line">            nodes[i].onclick = function()&#123;</span><br><span class="line">                console.log(i); //全部输出5</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用闭包</span><br><span class="line">        for(var i = 0, len = nodes.length; i &lt; len; i ++)&#123;</span><br><span class="line">            (funcion(i)&#123;</span><br><span class="line">                nodes[i].onclick = function()&#123;</span><br><span class="line">                    console.log(i); //全部输出 0,1,2,3,4</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="封装变量"><a href="#封装变量" class="headerlink" title="封装变量"></a>封装变量</h3><p>闭包可以把一些不需要暴露在全局的变量封装成私有变量，假设有一个计算乘积的简单函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var mult = function()&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; 1; i++)&#123;</span><br><span class="line">        a = a * arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>mult函数接受一些number类型的参数，并返回这些参数类型的乘积。现在我们觉得对于那么相同的参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var cache = &#123;&#125;;</span><br><span class="line">var mult = function()&#123;</span><br><span class="line">    var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">    if(cache[args])&#123;</span><br><span class="line">        return cache[args];</span><br><span class="line">    &#125;</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">        a = a * arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return cache[args] = a;</span><br><span class="line">&#125;;</span><br><span class="line">alert(mult(1,2,3)); //输出6</span><br><span class="line">alert(mult(1,2,3)); //输出6</span><br></pre></td></tr></table></figure></p>
<p>我们看到这个变量仅仅在mult函数中被使用，我们可以通过使用闭包将变量放到函数内部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var mult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        var a = 1;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            a = a * arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>提炼函数是代码重构中的一种常见技巧。如果在一个大函数中，有一些代码能够独立出来，我们常常把这些代码封装在独立的小函数里面。独立出来的小函数有利于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把他们用闭包封闭起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var mult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    var calculate = function()&#123; //封闭calculate函数÷</span><br><span class="line">        var a = 1;</span><br><span class="line">        for (var i = 0, l = arguments.length; i &lt; l; i ++) &#123;</span><br><span class="line">            a = a * arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = calculate.apply(null, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h3 id="延续局部变量的寿命"><a href="#延续局部变量的寿命" class="headerlink" title="延续局部变量的寿命"></a>延续局部变量的寿命</h3><p>img对象经常用于进行数据上报，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var report = function(src) &#123;</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">&#125;;</span><br><span class="line">report( &apos;http://xxx.com/getUserInfo&apos; );</span><br></pre></td></tr></table></figure></p>
<p>但是有些情况下，report函数并不是每一次都成功发起了http请求。丢失数据的原因是img是report函数的局部变量，当report调用结束后，img局部变量随即被销毁，而此时或许还没来得及发出http请求。现在我们把img变量用闭包封闭起来，便能解决请求丢失的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var report = (function()&#123;</span><br><span class="line">    var imgs = [];</span><br><span class="line">    return function(src)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        imgs.push(img);</span><br><span class="line">        imgs.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包和面向对象设计"><a href="#闭包和面向对象设计" class="headerlink" title="闭包和面向对象设计"></a>闭包和面向对象设计</h3><p>过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var extent = function()&#123;</span><br><span class="line">    var value = 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        call: function()&#123;</span><br><span class="line">            value++;</span><br><span class="line">            console.log(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var extent = extent();</span><br><span class="line">extent.call(); //输出 1</span><br><span class="line">extent.call(); //输出 2</span><br></pre></td></tr></table></figure></p>
<p>如果换成面向对象的写法，就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var extent = &#123;</span><br><span class="line">    value: 0,</span><br><span class="line">    call: function()&#123;</span><br><span class="line">        this.value ++;</span><br><span class="line">        console.log(this.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var extent = function()&#123;</span><br><span class="line">    this.value = 0;</span><br><span class="line">&#125;;</span><br><span class="line">extent.prototype.call = function()&#123;</span><br><span class="line">    this.value ++;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">var extent = new extent();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br></pre></td></tr></table></figure></p>
<h3 id="用闭包实现命令模式"><a href="#用闭包实现命令模式" class="headerlink" title="用闭包实现命令模式"></a>用闭包实现命令模式</h3><p>命令模式的意思是把请求封装为对象，从而分离请求的发起者和请求的接受者（执行者）之间的耦合关系。在命令执行前，可以预先往命令对象植入命令的接受者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button id=&quot;execute&quot;&gt;点击我执行命令&lt;/button&gt;</span><br><span class="line">        &lt;button id=&quot;undo&quot;&gt;点击我执行命令&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var Tv = &#123;</span><br><span class="line">            open: function()&#123;</span><br><span class="line">                console.log(&apos;打开电视机&apos;);</span><br><span class="line">            &#125;,</span><br><span class="line">            close: function()&#123;</span><br><span class="line">                console.log(&apos;关上电视机&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        var openTvCommand = function(receiver)&#123;</span><br><span class="line">            this.receiver = receiver;</span><br><span class="line">        &#125;;</span><br><span class="line">        openTvCommand.prototype.execute = function()&#123;</span><br><span class="line">            this.receiver.open(); //执行命令， 打开电视机</span><br><span class="line">        &#125;;</span><br><span class="line">        openTvCommand.prototype.undo = function()&#123;</span><br><span class="line">            this.receiver.close();//撤销命令，关闭电视机</span><br><span class="line">        &#125;;</span><br><span class="line">        var setCommand = function(command)&#123;</span><br><span class="line">            document.getElementById(&apos;execute&apos;).onclick = function()&#123;</span><br><span class="line">                command.execute(); //输出：打开电视机</span><br><span class="line">            &#125;;</span><br><span class="line">            document.getElementById(&apos;undo&apos;).onclick = function()&#123;</span><br><span class="line">                command.undo();  //关闭电视机 </span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        setCommand(new openTvCommand(Tv));</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h3><p>闭包与内存泄漏的关系是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏。但这本省并非必报的问题，也并非js的问题。在IE浏览器中，由于BOM和DOM的对象是使用c++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null 即可。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运 行时，就会删除这些值并回收它们占用的内存。<br>不如，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function handle()&#123;</span><br><span class="line">    var element = document.getElementById(&apos;div&apos;);</span><br><span class="line">    element.onclick = function()&#123;</span><br><span class="line">        console.log(element.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数中给element的onclick属性赋值了一个闭包，闭包要访问element的id属性。闭包在js中也是对象，函数即对象。闭包会持有外部传入的变量，因此闭包持有了element对象，而element对象通过onclick属性持有了闭包，因此两个对象相互持有，造成内存泄漏。</p>
<p>解决方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function handle()&#123;</span><br><span class="line">    var element = document.getElementById(&apos;div&apos;);</span><br><span class="line">    var id = element.id;</span><br><span class="line">    element.onclick = function()&#123;</span><br><span class="line">        console.log(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时element对象持有id，不再是element。</p>
<h2 id="高阶函数的概念和应用"><a href="#高阶函数的概念和应用" class="headerlink" title="高阶函数的概念和应用"></a>高阶函数的概念和应用</h2><p>高阶函数是至少满足下列条件之一的函数：</p>
<ul>
<li>函数可以作为参数被传递</li>
<li>函数可以作为返回值输出</li>
</ul>
<h3 id="函数最为参数传递"><a href="#函数最为参数传递" class="headerlink" title="函数最为参数传递"></a>函数最为参数传递</h3><p>把函数作为参数传递，这代表我们可以抽离一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个常见的重要的应用场景是常见的回掉函数。</p>
<h3 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h3><h4 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h4><p>AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来后，再通过“动态织入”的方式掺入业务逻辑模块中。这样的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。<br>通常，在js中实现AOP，都是指把一个函数“动态织入”到另一个函数之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before = function(beforefn)&#123;</span><br><span class="line">    var _self = this; //保存原函数的引用</span><br><span class="line">    return function() &#123;</span><br><span class="line">        beforefn.apply(this, arguments); //执行新函数，修正this 防止this丢失</span><br><span class="line">        return _self.apply(this, arguments); // 执行原函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Function.prototype.after = function(afterfn)&#123;</span><br><span class="line">    var _self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var ret = _self.apply(this, arguments);</span><br><span class="line">        afterfn.apply(this, arguments);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func = function() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func = func.before(function()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;).after(function()&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>curring又称部分求值。一个curring的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。<br>编写一个计算每月开销的函数。在每天结束之前，我们都要记录今天花掉了多少钱。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var monthlyCost = 0;</span><br><span class="line">var cost = function(money)&#123;</span><br><span class="line">    monthlyCost += money;</span><br><span class="line">&#125;;</span><br><span class="line">cost(100); //第一天开销</span><br><span class="line">cost(200); //第二天开销</span><br><span class="line">cost(300); //第三天开销</span><br><span class="line">console.log(monthlyCost);// 输出：600</span><br></pre></td></tr></table></figure></p>
<p>上面的代码计算了今天为止花了多少钱。但我们只想知道月底花了多少钱。也就是说，只需在月底计算一次。如果在每个月的前29天，我们都只是保存好当天的开销，知道第30天才进行求值计算。虽然下面的函数还不是currying函数的完整实现，但有助于我们了解其思想：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var cost = (function()&#123;</span><br><span class="line">    var args = [];</span><br><span class="line">    return = function()&#123;</span><br><span class="line">        if(arguments.length === 0)&#123;</span><br><span class="line">            var money = 0;</span><br><span class="line">            for(var i = 0, l = args.length; i &lt; l; i++)&#123;</span><br><span class="line">                money += args[i];</span><br><span class="line">            &#125;</span><br><span class="line">            return money;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            [].push.apply(args, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line">cost(200); //未真正求值</span><br><span class="line">cost(300); //未真正求值</span><br><span class="line">console.log(cost()); //求值并输出：600</span><br></pre></td></tr></table></figure></p>
<p>编写一个通用的currying函数，它接受一个参数，即将要被curring的函数。在这个例子里，这个函数的作用遍历本月每天的开销并求出它们的总和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var curring = function(fn)&#123;</span><br><span class="line">    var args = [];</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(arguments.length === 0)&#123;</span><br><span class="line">            return fn.apply(this, args);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            [].push.apply(args, arguments);</span><br><span class="line">            return arguments.callee;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var cost = (function()&#123;</span><br><span class="line">    var money = 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            money += arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">var cost = currying(cost);  //转化成currying函数</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line"></span><br><span class="line">console.log(cost()); //求值并输出：600</span><br></pre></td></tr></table></figure></p>
<h3 id="函数节流-分时函数"><a href="#函数节流-分时函数" class="headerlink" title="函数节流 分时函数"></a>函数节流 分时函数</h3><h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><p>函数在有些情况下不是被用户主动频繁调用</p>
<ul>
<li>window.onresize事件</li>
<li>mousemove事件</li>
<li>上传进度。</li>
</ul>
<p>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(fn, interval)&#123;</span><br><span class="line">    var _self = fn, //保存需要被延迟执行的函数引用 </span><br><span class="line">        timer, //定时器</span><br><span class="line">        firstTime = true; //是否是第一次调用 </span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = arguments,</span><br><span class="line">            _me = this;</span><br><span class="line">        if(firstTime)&#123;  //如果是第一次调用，不需要延迟执行</span><br><span class="line">            _self.apply(_me, args);</span><br><span class="line">            return firstTime = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(timer) &#123;  //如果定时器还在，说明前一次延迟执行还没有完成</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(function()&#123; //延迟一段时间执行</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = null;</span><br><span class="line">            _self.apply(_me, args);</span><br><span class="line">        &#125;, interval || 500);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">window.onresize = throttle(function()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;, 500);</span><br></pre></td></tr></table></figure></p>
<h4 id="分时函数"><a href="#分时函数" class="headerlink" title="分时函数"></a>分时函数</h4><p>函数是用户主动调用的，函数影响了页面性能<br>比如创建WebQQ的QQ好友列表。列表中通常会有成百上千个好友，如果一个好友用一个节点来表示，当我们在页面中渲染这个列表的时候，可能要一次性往页面中创建成败上千个节点。这样做和可能造成浏览器卡顿。代码如下 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for(var i = 1; i &lt;= 1000; i++)&#123;</span><br><span class="line">    arr.push(i); //假设arr装载了1000个好友的数据</span><br><span class="line">&#125;</span><br><span class="line">var renderFriendList = function(data)&#123;</span><br><span class="line">    for(var i = 0, l = data.length; i &lt; l; i++)&#123;</span><br><span class="line">        var div = document.createElement(&apos;div&apos;);</span><br><span class="line">        div.innerHTML = i;</span><br><span class="line">        document.body.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">rederFriendList(arr);</span><br></pre></td></tr></table></figure>
<p>解决方案一： 使用timeChunk函数让创建节点的工作分批进行，比如把1秒钟创建1000个节点，改为每隔200毫秒创建8个节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">第一个参数是创建节点时需要用到的数据，第二个参数是封装了创建节点逻辑的函数</span><br><span class="line">，第三个参数表示每一批创建的节点数量。</span><br><span class="line">var timeChunk = function(arr, fn, count)&#123;</span><br><span class="line">    var obj,</span><br><span class="line">        t;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var start = function()&#123;</span><br><span class="line">        for(var i = 0; i &lt; Math.min(count || 1, arr.length); i++;)&#123;</span><br><span class="line">            var obj = arr.shift();</span><br><span class="line">            fn(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        t = setInterval(function()&#123;</span><br><span class="line">            if(arr.length === 0)&#123; //如果全部节点都已经被创建好</span><br><span class="line">                return clearInterval(t);</span><br><span class="line">            &#125;</span><br><span class="line">            start();</span><br><span class="line">        &#125;, 200); //分批执行的时间间隔</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用timeChunk函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for(var i = 1; i &lt;= 1000; i++)&#123;</span><br><span class="line">    arr.push(i);</span><br><span class="line">&#125;</span><br><span class="line">var renderFriendList = timeChunk(arr, function(n)&#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = n;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;, 8)</span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例只有一个对象，支持全局访问。</p>
<h3 id="不透明的单例模式"><a href="#不透明的单例模式" class="headerlink" title="不透明的单例模式"></a>不透明的单例模式</h3><p>Singleton 类的使用者必须知道这是一个单例类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var Singleton = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.instance = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton.prototype = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = function(name) &#123;</span><br><span class="line">    if(!this.instance) &#123;</span><br><span class="line">        this.instance = new Singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line">    return this.instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = Singleton.getInstance(&apos;jack1&apos;);</span><br><span class="line">var b = Singleton.getInstance(&apos;jack2&apos;);</span><br><span class="line"></span><br><span class="line">console.log(a === b);</span><br></pre></td></tr></table></figure>
<p>或者,使用闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Singleton = function(name)&#123; //相当于构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton.prototype.getInstance = (function()&#123;</span><br><span class="line">    var instance = null;</span><br><span class="line">    return function(name)&#123;</span><br><span class="line">        if(!instance)&#123;</span><br><span class="line">            instance = new Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="透明的单例模式"><a href="#透明的单例模式" class="headerlink" title="透明的单例模式"></a>透明的单例模式</h3><p>使用CreateDiv单例类，作用是在页面中创建唯一的div节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var CreateDiv = (function()&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    var CreateDiv = function(html)&#123;</span><br><span class="line">        if(instance)&#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">        this.html = html;</span><br><span class="line">        this.init();</span><br><span class="line">        return instance = this;</span><br><span class="line">    &#125;</span><br><span class="line">    CreateDiv.prototype.init = function()&#123;</span><br><span class="line">        var div = document.createElement(&apos;div&apos;);</span><br><span class="line">        div.innerHTML = this.html;</span><br><span class="line">        document.body.appendChild(div);</span><br><span class="line">    &#125;;</span><br><span class="line">    return CreateDiv;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var a = new CreateDiv(&apos;jack1&apos;);</span><br><span class="line">var b = new CreateDiv(&apos;jack2&apos;);</span><br><span class="line">console.log(a === b); //true</span><br></pre></td></tr></table></figure>
<p>用代理模式实现单例 把负责管理单例的代码移除出去，使它成为一个普通的创建div的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var createDiv = function(html)&#123;</span><br><span class="line">    this.html = html;</span><br><span class="line">    this.init();</span><br><span class="line">&#125;;</span><br><span class="line">createDiv.prototype.init = function()&#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;;</span><br><span class="line">var ProxySingletonCreateDiv = (function()&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    return funtion(html)&#123;</span><br><span class="line">        if(!instance)&#123;</span><br><span class="line">            instance = new CreateDiv(html);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;)();</span><br><span class="line">var a = new ProxySingletonCreateDiv(&apos;jack1&apos;);</span><br><span class="line">var b = new ProxySingletonCreateDiv(&apos;jack2&apos;);</span><br><span class="line">console.log(a === b);</span><br></pre></td></tr></table></figure></p>
<p>有时候我们会使用全局变量来实现单例。但是考虑到命名污染，我们需要采取措施避免：</p>
<ol>
<li>使用命名空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var namespace = &#123;</span><br><span class="line">    a: function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    b: function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用闭包封装私有变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var user = (function()&#123;</span><br><span class="line">    var _name = &apos;sven&apos;,</span><br><span class="line">        _age = 29;</span><br><span class="line">    return &#123;</span><br><span class="line">        getUserInfo: function()&#123;</span><br><span class="line">            return _name + &apos;-&apos; + _age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我们用下划线来约定私有变量_name和_age，它们被封装在闭包产生的作用域中，这就避免了全局污染。</p>
<h2 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h2><p>惰性单例是指在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用，有用的程度超出我们的想象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button id=&quot;login&quot;&gt;登陆&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var createDiv = function()&#123;</span><br><span class="line">        var div;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            if(!div)&#123;</span><br><span class="line">                div = document.createElement(&apos;div&apos;);</span><br><span class="line">                div.innerHTML = &apos;我是浮框&apos;;</span><br><span class="line">                document.body.appendChild(div);</span><br><span class="line">                return div;</span><br><span class="line">            &#125;</span><br><span class="line">            return div;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    document.getELementById(&apos;login&apos;).onclick = function()&#123;</span><br><span class="line">        var div = createDiv();</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="通用惰性加载"><a href="#通用惰性加载" class="headerlink" title="通用惰性加载"></a>通用惰性加载</h3><p>上面的代码有以下问题：</p>
<blockquote>
<p>这段代码仍然违反单一职责原则，创建对象和管理单例的逻辑都放在createDiv对象内<br>如果我们下次需要创建页面中唯一的iframe，或者script标签，用来跨域请求数据，就必须得如法炮制，把createDiv几乎抄一遍。<br>我们可以把不变的部分隔离出来，先不考虑创建一个div和创建一个iframe有多少差异，管理单例的逻辑其实是完全可以抽象出来的，这个逻辑始终是一样的：用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj;</span><br><span class="line">if(!ob) &#123;</span><br><span class="line">    obj = xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>现在我们就把如何管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在getSingle函数内部，创建对象的方法fn被当成参数动态传入getSingle函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var getSingle = function(fn)&#123;</span><br><span class="line">    var result;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return result || (result = fn.apply(this.arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来将用于创建div的方法用参数fn的形式闯入getSingle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var createDiv = function() &#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = &apos;我是div&apos;;</span><br><span class="line">    return div;</span><br><span class="line">&#125;;</span><br><span class="line">var createSingleDiv =  getSingle(createDiv);</span><br><span class="line">document.getElementById(&apos;login&apos;).onclick = function()&#123;</span><br><span class="line">    var login = createSingleDiv();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种单例模式远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定click事件，如果是通过ajax动态往列表里追加数据，在使用事件代理的前提下，click事件实际上只需要在第一次渲染列表的时候被绑定一次，但是我们不想去判断当前是否是第一次渲染列表，如果借助于jq，我们通常选择给节点绑定one事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var bindEvent = function()&#123;</span><br><span class="line">//one 事件： 处理函数在每个元素上每种事件类型最多执行一次</span><br><span class="line">    $(&apos;div&apos;).one(&apos;click&apos;, function()&#123; </span><br><span class="line">        console.log(&apos;click&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var render = function()&#123;</span><br><span class="line">    console.log(&apos;开始);</span><br><span class="line">    bindEvent();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render();</span><br><span class="line">render();</span><br><span class="line">render();</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="使用策略模式计算奖金"><a href="#使用策略模式计算奖金" class="headerlink" title="使用策略模式计算奖金"></a>使用策略模式计算奖金</h3><p>绩效为S的年终奖有4倍工资，绩效为A的3倍工资，绩效为B的2倍工资。</p>
<ul>
<li>最初的实现代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var calculateBonus = function(performanceLevel, salary)&#123;</span><br><span class="line">    if(performanceLevel === &apos;S&apos;)&#123;</span><br><span class="line">        return salary * 4;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;A&apos;)&#123;</span><br><span class="line">        return salary * 3;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;B&apos;)&#123;</span><br><span class="line">        return salary * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculateBonus(&apos;B&apos;, 20000); //输出： 40000</span><br><span class="line">calculateBonus(&apos;S&apos;, 6000); //输出： 24000</span><br></pre></td></tr></table></figure>
<p>calculateBonus函数的缺点：</p>
<blockquote>
<p>calculateBonus函数比较庞大，包含了很多if-else语句，这些语句需要覆盖所有的逻辑分支。<br>calculateBonus函数缺乏弹性，如果增加了一种新的绩效等级C，或者想把绩效S的奖金系数改为5，<br>那么我们必须深入calculateBonus函数的内部实现，这是违反开放-封闭原则的。<br>算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们只有粘贴复制</p>
</blockquote>
<ul>
<li>使用组合函数重构代码  缺点： 函数依据很庞大</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var performanceS = function()&#123;</span><br><span class="line">    return salary * 4;</span><br><span class="line">&#125;;</span><br><span class="line">var performanceA = function()&#123;</span><br><span class="line">    return salary * 3;</span><br><span class="line">&#125;;</span><br><span class="line">var performanceB = function(salary)&#123;</span><br><span class="line">    return salary * 2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var calculateBonus = function(performanceLevel, salary)&#123;</span><br><span class="line">    if(performanceLevel === &apos;S&apos;)&#123;</span><br><span class="line">        return performanceS(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;A&apos;)&#123;</span><br><span class="line">        return performanceA(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;B&apos;)&#123;</span><br><span class="line">        return performanceB(salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculateBonus(&apos;A&apos;, 1000); // 3000</span><br></pre></td></tr></table></figure>
<ul>
<li>使用策略模式重构代码，一个基于策略模式的程序至少由两部分组成：</li>
</ul>
<blockquote>
<p>第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。<br>第二个部分是环境类Context，Context接受客户的请求，随后将请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。</p>
</blockquote>
<ul>
<li>版本一： 用传统的面向对象语言的方式，把每种绩效的计算规则都封装在对应的策略类里面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var performanceS = function()&#123;&#125;;</span><br><span class="line">performanceS.prototype.calculate = function(salary)&#123;</span><br><span class="line">    return salary * 4;</span><br><span class="line">&#125;;</span><br><span class="line">var performanceA = function()&#123;&#125;;</span><br><span class="line">performanceA.prototype.calculate = function(salary)&#123;</span><br><span class="line">    return salary * 3;</span><br><span class="line">&#125;;</span><br><span class="line">var performanceB = function()&#123;&#125;;</span><br><span class="line">performanceB.prototype.calculate = function(salary)&#123;</span><br><span class="line">    return salary * 2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来定义奖金类Bonus：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var Bonus = function()&#123;</span><br><span class="line">    this.salary = null; //原始工资</span><br><span class="line">    this.strategy = null; //绩效等级对应的策略对象</span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setSalary = function(salary)&#123;</span><br><span class="line">    this.salary = salary; //设置员工的原始工资</span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setStrategy = function(strategy) &#123;</span><br><span class="line">    this.strategy = strategy; //设置员工绩效等级对应的策略对象</span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.getBonus = function()&#123; //取得奖金数额 </span><br><span class="line">    return this.strategy.calculate(this.salary); //把计算奖金的操作委托给对应的策略对象</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bonus = new Bonus;</span><br><span class="line">bonus.setSalary(1000);</span><br><span class="line">bonus.setStrategy(new PerfomanceA());</span><br><span class="line">console.log(bonus.getBonus); //输出 3000</span><br></pre></td></tr></table></figure></p>
<ul>
<li>版本二：js版本的策略模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var strategies = &#123;</span><br><span class="line">    &apos;S&apos;: function(salary)&#123;</span><br><span class="line">        return salary * 4;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;A&apos;: function(salary)&#123;</span><br><span class="line">        return salary * 3;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;B&apos;: function(salary)&#123;</span><br><span class="line">        return salary * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var calculateBonus = function(level, salary)&#123;</span><br><span class="line">    return strategies[level](salary);</span><br><span class="line">&#125;;</span><br><span class="line">console.log(calculateBonus(&apos;S&apos;, 20000)); //80000</span><br></pre></td></tr></table></figure>
<h3 id="多态在策略模式中的体现"><a href="#多态在策略模式中的体现" class="headerlink" title="多态在策略模式中的体现"></a>多态在策略模式中的体现</h3><p>先记录一些有用的信息</p>
<ul>
<li>动画开始时，小球所在的原始位置</li>
<li>小球移动的目标位置</li>
<li>动画开始时的准确时间点</li>
<li>小球运动持续的时间</li>
</ul>
<p>用setInterval创建一个定时器，定时器每隔19ms循环一次。在定时器的每一帧里，我们会把动画已消失的时间、小球的原始位置、小球目标位置和动画持续的总时间等传入缓动算法。该算法通过这几个参数，计算出小球当前应该所在的位置。最后再更新该div对应的css属性，小球就能顺利地运动起来了。</p>
<h4 id="让小球运动起来"><a href="#让小球运动起来" class="headerlink" title="让小球运动起来"></a>让小球运动起来</h4><p><strong>常见缓动算法</strong>。4个参数分别为动画已消耗的时间、小球原始位置、小球目标位置、动画持续的总时间；返回的值则是动画元素应该处在的当前位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var tween = &#123;</span><br><span class="line">    linear: function(t, b, c, d)&#123;</span><br><span class="line">        return c*t/d + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    easeIn: function(t, b, c, d)&#123;</span><br><span class="line">        return c*(t/=d)*t + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    strongEaseIn: function(t, b, c, d)&#123;</span><br><span class="line">        return c*(t/=d)*t*t*t*t + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    strongEaseOut: function(t, b, c, d)&#123;</span><br><span class="line">        return c * ((t = t/ d - 1)*t*t*t*t + 1) + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    sineaseIn: function(t,b,c,d)&#123;</span><br><span class="line">        return c * (t/=d) * t*t + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    sineaseOut: function(t,b,c,d)&#123;</span><br><span class="line">        return c*((t = t/d - 1)*t*t + 1) + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div style=&quot;position:absolute;background:blue;&quot; id=&apos;div&apos;&gt;div&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>Animate类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var Animal = function(dom)&#123;</span><br><span class="line">    this.dom = dom;  //进行运动的dom节点</span><br><span class="line">    this.startTime = 0; //动画开始时间</span><br><span class="line">    this.startPos = 0; //动画开始是，dom节点的位置，即dom的初始位置</span><br><span class="line">    this.endPos = 0; //动画结束时，dom节点的位置，即dom的目标位置</span><br><span class="line">    this.propertyName = null; // dom节点需要被改变的css属性名</span><br><span class="line">    this.easing = null; //缓动算法</span><br><span class="line">    this.duration = null; //动画持续时间</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param propertyName: 要改变的CSS属性名，比如left，top，分别表示左右移动和上下移动。</span><br><span class="line"> * @param endPos: 小球运动的目标位置</span><br><span class="line"> * @param duration: 动画持续时间</span><br><span class="line"> * @param easing：缓动算法</span><br><span class="line"> **/</span><br><span class="line">Animal.prototype.start = function(propertyName, endPos, duration, easing) &#123;</span><br><span class="line">    this.startTime = new Date; //动画启动时间</span><br><span class="line">    this.startPos = this.dom.getBoundingClientRect()[propertyName]; //dom节点初始位置</span><br><span class="line">    this.propertyName = propertyName; //dom节点需要被改变的css属性名</span><br><span class="line">    this.endPos = endPos; //dom节点目标位置</span><br><span class="line">    this.duration = duration; //动画持续事件</span><br><span class="line">    this.easing = tween[easing]; //缓动算法</span><br><span class="line">    var self = this;</span><br><span class="line">    var timeId = setInterval(function()&#123; //启动定时器，开始执行动画</span><br><span class="line">        if(self.step() === false)&#123; //如果动画已结束，则清楚定时器</span><br><span class="line">            clearInterval(timeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 19);</span><br><span class="line">&#125;;</span><br><span class="line">//定义小球的每一帧都要做的事情</span><br><span class="line">Animal.prototype.step = function()&#123;</span><br><span class="line">    var t = new Date; //取得当前时间</span><br><span class="line">    if(t &gt;= this.startTime + this.duration) &#123; //(1)</span><br><span class="line">        this.update(this.endPos); //更新小球的CSS属性值</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var pos = this.easing(t - this.startTime, this.startPos,</span><br><span class="line">        this.endPos - this.startPos, this.duration);</span><br><span class="line">    //pos为小球当前位置</span><br><span class="line">    this.update(pos); //更新小球的CSS属性值</span><br><span class="line">&#125;;</span><br><span class="line">Animal.prototype.update = function(pos)&#123;</span><br><span class="line">    this.dom.style[this.propertyName] = pos + &apos;px&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var div = document.getElementById(&apos;div&apos;);</span><br><span class="line">var animate = new Animate(div);</span><br><span class="line">animate.start(&apos;left&apos;, 500, 1000, &apos;strongEaseOut&apos;);</span><br></pre></td></tr></table></figure></p>
<p>(1)处的意思是，如果当前时间大于动画开始时间加上动画持续时间只和，说明动画已经结束，此时要修正小球的位置。因为在这一帧开始之后，小球的位置已经接近了目标位置，但很可能不完全等于目标位置。此时我们要主动修正小球的当前位置为最终的目标位置。此外让Animal.prototype.step方法返回false，可以同志animate.prorotype.start方法清楚定时器。</p>
<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form action=&quot;#&quot; id=&quot;registerForm&quot; method=&quot;post&quot;&gt;</span><br><span class="line">            请输入用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;</span><br><span class="line">            请输入密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;</span><br><span class="line">            请输入手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot; /&gt;</span><br><span class="line">            &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var registerForm = document.getElementById(&apos;registerForm&apos;);</span><br><span class="line">        registerForm.onsubmit = function()&#123;</span><br><span class="line">            if(registerForm.userName.value === &apos;&apos;)&#123;</span><br><span class="line">                console.log(&apos;用户名不能为空&apos;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(registerForm.password.value.length &lt; 6)&#123;</span><br><span class="line">                console.log(&apos;密码长度不能少于6位&apos;);</span><br><span class="line">                return fasle;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!/(1[358])[0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)&#123;</span><br><span class="line">                console.log(&apos;手机号码格式不正确&apos;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>代码编写方式的缺点：</p>
<blockquote>
<p>函数庞大<br>缺乏弹性<br>算法复用性差</p>
</blockquote>
<p>用策略模式重构表单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var strategies = &#123;</span><br><span class="line">    isNonEmpty: function(value, errorMsg)&#123; //不为空</span><br><span class="line">        if(value === &apos;&apos;)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    minLength: function(value, errorMsg)&#123; //限制最小长度</span><br><span class="line">        if(value.length &lt; 6)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    isPhoneNumber: function(value, errorMsg)&#123; //判断是否为正确的手机号</span><br><span class="line">        if(!/(^1[358][0-9]&#123;9&#125;$)/.test(value)) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var validateFunc = function()&#123;</span><br><span class="line">    var validator = new Validator();  //创建一个validator对象</span><br><span class="line">    /************* 添加一些校验规则 ***************/</span><br><span class="line">    validator.add(registerForm.userName,&apos;isNonEmpty&apos;, &apos;用户名不能为空&apos;);</span><br><span class="line">    validator.add(registerForm.password,&apos;minLength:6&apos;, &apos;密码长度不能少于6位&apos;);</span><br><span class="line">    validator.add(registerForm.phoneNumber,&apos;isPhoneNumber&apos;, &apos;手机号码格式不正确&apos;);</span><br><span class="line">    </span><br><span class="line">    var errorMsg = validator.start(); //获得校验结果</span><br><span class="line">    return errorMsg; //返回校验结果</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var registerForm = document.getELementById(&apos;registerFrom&apos;);</span><br><span class="line">registerForm.onsubmit = function()&#123;</span><br><span class="line">    var errorMsg = validatorFunc(); //如果errorMsg有确切的返回值，说明未通过校验</span><br><span class="line">    if(errorMsg) &#123;</span><br><span class="line">        console.log(errorMsg);</span><br><span class="line">        return false; //组织表单提交</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Validator = function()&#123;</span><br><span class="line">    this.cache = []; //保存校验规则</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.add = function(dom, rule, errorMsg) &#123;</span><br><span class="line">    var arr = rule.split(&apos;:&apos;); //把strategy和参数分开</span><br><span class="line">    this.cache.push(function()&#123; //把校验的步骤用空函数包装起来，并且放入cache</span><br><span class="line">        var strategy = arr.shift(); //用户挑选的strategy</span><br><span class="line">        arr.unshift(dom.value); //把input的value添加进参数列表</span><br><span class="line">        arr.push(errorMsg); // 把errorMsg添加进参数列表</span><br><span class="line">        return strategies[strategy].apply(dom, arr);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Validator.prototype.start = function()&#123;</span><br><span class="line">    for(var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123;</span><br><span class="line">        var msg = validatorFunc(); //开始校验，并取得校验后的返回信息</span><br><span class="line">        if(msg)&#123; //如果有确切的返回值，说明校验没有通过</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。代理模式的关键是，当客户不方便直接访问一个对象或不满足需要的时候，提供一个替身来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转给本体对象。</p>
<p>在四月一个晴朗的早晨，小明遇见了他的百分百女孩，我们暂且叫小明的女神为A。两天后，小明决定给A送一束花来表白。刚好小明打听到A和他有一个共同好友B，于是内向的小明决定让B来代替自己完成送花这件事。虽然小明的故事必将以悲剧收场，因为追MM更好的方式是送她一辆宝马。</p>
<p>不用代理的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var flower = function()&#123;&#125;;</span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    sendFlower: function(target) &#123;</span><br><span class="line">        var flower = new Flower();</span><br><span class="line">        target.receiveFlower(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var A = &#123;</span><br><span class="line">    receiveFlower: function(flower) &#123;</span><br><span class="line">        console.log(&apos;收到花&apos; + flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.sendFlower(A);</span><br></pre></td></tr></table></figure></p>
<p>使用代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var Flower = function()&#123;&#125;;</span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    sendFlower: function(target)&#123;</span><br><span class="line">        var flower = new Flower();</span><br><span class="line">        target.receiveFlower(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = &#123;</span><br><span class="line">    receiveFlower: function(flower) &#123;</span><br><span class="line">        A.receiveFlower(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var A = &#123;</span><br><span class="line">    receiveFlower: function(flower) &#123;</span><br><span class="line">        console.log(&apos;收到花&apos; + flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.sendFlower(B);</span><br></pre></td></tr></table></figure></p>
<p>B会监听A的心情，在A心情好的时候将花交给A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var Flower = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    sendFlower: function(target)&#123;</span><br><span class="line">        var flower = new Flower();</span><br><span class="line">        target.recerveFlower(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = &#123;</span><br><span class="line">    recerveFlower: function(flower) &#123;</span><br><span class="line">        A.listenGoodMood(function()&#123; //监听A的好心情</span><br><span class="line">            A.receiveFlower(flower); </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var A = &#123;</span><br><span class="line">    receiveFlower: function(flower) &#123;</span><br><span class="line">        console.log(&apos;收到花&apos; + flower);</span><br><span class="line">    &#125;,</span><br><span class="line">    listenGoodMood: function(fn) &#123;</span><br><span class="line">        setTimeout(function()&#123;  //假设10秒后A的心情变好</span><br><span class="line">            fn();</span><br><span class="line">        &#125;, 10000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.sendFlower(B);</span><br></pre></td></tr></table></figure></p>
<h4 id="保护代理和虚拟代理"><a href="#保护代理和虚拟代理" class="headerlink" title="保护代理和虚拟代理"></a>保护代理和虚拟代理</h4><p>代理B可以帮助A过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理B处被处理掉。这种代理叫做保护代理。A和B一个充当白脸，一个充当黑脸。白脸A继续保持良好的女神形象，不希望拒绝任何人，于是找到了黑脸B来控制对A的访问。<br>另外，假设现实中的花价格不菲，导致在程序世界里，new Flower也是一个代价昂贵的操作，那么我们可以把new Flower的操作交给代理B去执行，代理B会在A心情好的时候再执行new Flower，这是代理模式的另一种形式，叫做虚拟代理。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var B = &#123;</span><br><span class="line">    receiveFlower: function()&#123;</span><br><span class="line">        A.listenGoodMood(function()&#123; //监听A的好心情</span><br><span class="line">            var flower = new Flower(); //延迟创建flower对象</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="虚拟代理实现图片预加载"><a href="#虚拟代理实现图片预加载" class="headerlink" title="虚拟代理实现图片预加载"></a>虚拟代理实现图片预加载</h3><p>在web开发中，图片预加载是一种常用的技术，如果直接给某个img标签节点设置src属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张loading图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到img节点里，这种场景就很是时候使用虚拟代理。</p>
<p>创建一个普通的本体对象，这个对象负责往页面创建一个img标签，并且提供一个对外的serSrc接口，便可以给该image标签设置src属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var MyImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.apppendChild(imgNode);</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function(src)&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">myImage.serSrc(&apos;http://picture.jpg&apos;);</span><br></pre></td></tr></table></figure></p>
<p>引入代理对象proxyImage，通过这个代理对象，在图片被真正加载好之前，页面中将出现一张占位的菊花图loading.gif，来提示用户图片正在加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function(src) &#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var proxyImage = (function()&#123;</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        myImage.serSrc(this.src);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function(src) &#123;</span><br><span class="line">            imImage.setSrc(&apos;loading.gif&apos;);</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyImage.setSrc(&apos;http://someone.jpg&apos;);</span><br></pre></td></tr></table></figure></p>
<h4 id="代理的意义"><a href="#代理的意义" class="headerlink" title="代理的意义"></a>代理的意义</h4><p>不用代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.appendChild(&apos;imgNode&apos;);</span><br><span class="line">    var img = new Image;</span><br><span class="line"></span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        imgNode.src = img.src;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function()&#123;</span><br><span class="line">            imgNode.src = &apos;loading.gif&apos;;</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">myImage.setSrc(&apos;picture.jpg&apos;);</span><br></pre></td></tr></table></figure></p>
<p>为了说明代理的意义，我们引入面向对象设计的原则—单一职责原则。<br>单一指责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多想职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承当的责任过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。</p>
<h4 id="代理和本体接口的一致性"><a href="#代理和本体接口的一致性" class="headerlink" title="代理和本体接口的一致性"></a>代理和本体接口的一致性</h4><p>如果我们有一天不需要预加载，那么就不再需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了setSrc方法，在客户看来，代理对象和本体是一致的，代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这样做的好处。</p>
<blockquote>
<p>用户可以放心的请求代理，他只关心是否能得到想要的结果。<br>在任何使用本体的地方都可以替换成使用代理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line"></span><br><span class="line">    return function(src)&#123;</span><br><span class="line">        imgNode.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var proxyImage = (function()&#123;</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        myImage(this.src);</span><br><span class="line">    &#125;</span><br><span class="line">    return function(src) &#123;</span><br><span class="line">        myImage(&apos;loading.src&apos;);</span><br><span class="line">        img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="虚拟代理合并HTTP请求"><a href="#虚拟代理合并HTTP请求" class="headerlink" title="虚拟代理合并HTTP请求"></a>虚拟代理合并HTTP请求</h3><p>点一下checkbox发送一次请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;1&quot;/&gt;1</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;2&quot;/&gt;2</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;3&quot;/&gt;3</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;4&quot;/&gt;4</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;5&quot;/&gt;5</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;6&quot;/&gt;6</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;7&quot;/&gt;7</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var synchronousFile = function(id)&#123;</span><br><span class="line">        console.log(&apos;开始同步文件，id为：&apos; + id);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var checkbox = document.getElementByTagName(&apos;input&apos;);</span><br><span class="line">    for(var i = 0, c; c = checkbox(i++);)&#123;</span><br><span class="line">        c.onclick = function()&#123;</span><br><span class="line">            if(this.checked === true)&#123;</span><br><span class="line">                synchronousFile(this.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>为了减轻服务器压力，我们可以将2秒内的请求一次性发送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var synchronousFile = function(id) &#123;</span><br><span class="line">    console.log(&apos;开始同步文件&apos; + id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxySynchronousFile = (function()&#123;</span><br><span class="line">    var cache = [], //保存一段时间内需要同步的ID</span><br><span class="line">        timer;  //定时器</span><br><span class="line">    return function(id) &#123;</span><br><span class="line">        cache.push(id);</span><br><span class="line">        if(timer) &#123; //保证不会覆盖已经启动的定时器</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(function()&#123;</span><br><span class="line">            synchronousFile(cache.join(&apos;,&apos;)); //2秒后向本体发送需要同步的ID集合</span><br><span class="line">            clearTimeOut(timer); //清空定时器</span><br><span class="line">            timer = null;</span><br><span class="line">            cache.length = 0; //晴空ID集合</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var checkbox = document.getElementsByTagName(&apos;input&apos;);</span><br><span class="line"></span><br><span class="line">for(var i = 0, c; c = checkbox[i++]) &#123;</span><br><span class="line">    c.onclick = function()&#123;</span><br><span class="line">        if(this.checked === true) &#123;</span><br><span class="line">            proxySynchronousFile(this.id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h3><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前的一致，则可以直接返回千面存储的运算结果</p>
<h4 id="计算乘积"><a href="#计算乘积" class="headerlink" title="计算乘积"></a>计算乘积</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var mult = function()&#123;</span><br><span class="line">    console.log(&apos;开始计算乘积&apos;);</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">        a = a * arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mult(2,3); </span><br><span class="line">mult(2,3,4);</span><br></pre></td></tr></table></figure>
<p>加入缓存代理函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var proxyMult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache) &#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = mult.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyMult(2,3);</span><br><span class="line">proxyMult(2,3); //这里会使用缓存</span><br></pre></td></tr></table></figure></p>
<h4 id="缓存代理用于ajax异步请求数据"><a href="#缓存代理用于ajax异步请求数据" class="headerlink" title="缓存代理用于ajax异步请求数据"></a>缓存代理用于ajax异步请求数据</h4><p>我们常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉去一次，这些已经拉取的数据在某个地方缓存之后，下次再请求同一页的时候，便可以直接食用之前的数据。</p>
<h4 id="用高阶函数动态创建代理"><a href="#用高阶函数动态创建代理" class="headerlink" title="用高阶函数动态创建代理"></a>用高阶函数动态创建代理</h4><p>通过传入高阶函数这种更加灵活的方式，可以为各种计算方法创建缓存代理。现在这些计算方法被当作参数传入一个专门用于创建缓存代理的工厂中，这样以来我们就可以为乘法、加法、减法等创建缓存代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/************** 计算乘积 *****************/</span><br><span class="line">var mult = function()&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">        a *= argumens[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/************ 计算和 *****************/</span><br><span class="line">var plus = function()&#123;</span><br><span class="line">    var a = 0;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">        a += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/************ 创建缓存代理工厂 *********/</span><br><span class="line">var createProxyFactory = function(fn) &#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = fn.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var proxyMult = createProxyFactory(mult);</span><br><span class="line">var proxyPlus = createProxyFactory(plus);</span><br><span class="line"></span><br><span class="line">console.log(proxyMult(1,2,3,4));</span><br><span class="line">console.log(proxyMult(1,2,3,4));</span><br><span class="line">console.log(proxyPlus(1,2,3,4));</span><br><span class="line">console.log(proxyPlus(1,2,3,4));</span><br></pre></td></tr></table></figure></p>
<p>策略模式 + 缓存代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var strategies = &#123;</span><br><span class="line">    mult: function()&#123;</span><br><span class="line">        var a = 1;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            a *= arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;,</span><br><span class="line">    plus: function()&#123;</span><br><span class="line">        var a = 1;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            a += arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var createProxyFactory = function(fn)&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments. &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = fn.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proxyMult = createProxyFactory(strategies.mult);</span><br><span class="line">var proxyMult = createProxyFactory(strategies.plus);</span><br></pre></td></tr></table></figure></p>
<h4 id="其他代理模式"><a href="#其他代理模式" class="headerlink" title="其他代理模式"></a>其他代理模式</h4><ul>
<li>防火墙代理： 控制网络资源的访问，保护主题不让“坏人接近“。</li>
<li>远程代理：为一个对象在不同的地址空间提供局部代表。</li>
<li>保护代理： 用于对象应该有不同访问权限的情况</li>
<li>智能引用代理： 取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。</li>
<li>写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体。DLL（操作系统中的动态链接库）是其典型运用场景。</li>
</ul>
<p>尽管代理模式有用，但我们在编写业务代码时，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p>
<h3 id="实现自己的迭代器"><a href="#实现自己的迭代器" class="headerlink" title="实现自己的迭代器"></a>实现自己的迭代器</h3><p>实现一个each函数，each函数接受2个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回掉函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var each = function(arr, callback) &#123;</span><br><span class="line">    for(var i = 0, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        callback.call(arr[i], i, arr[i]); //把下标和元素当作参数传给callback函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">each([1,2,3], function(i, n)&#123;</span><br><span class="line">    console.log([i,n]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="内部迭代器和外部迭代器"><a href="#内部迭代器和外部迭代器" class="headerlink" title="内部迭代器和外部迭代器"></a>内部迭代器和外部迭代器</h3><h4 id="内部迭代器"><a href="#内部迭代器" class="headerlink" title="内部迭代器"></a>内部迭代器</h4><p>上面编写的each函数就是内部迭代器，each函数的内部已经定义好了迭代规则，它完全接受整个迭代过程，外部只需要一次初始调用。由于内部迭代器被提前定义了规则，上面的each函数就无法同时迭代2个数组了。比如现在有个需求，要判断2个数组里元素的值是否完全相等，如果不该写each函数本身的代码，我们能够入手的地方似乎只有each的回掉函数了，代码如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var compare = function(arr1, arr2)&#123;</span><br><span class="line">    if(arr1.length !== arr2.length)&#123;</span><br><span class="line">        throw new Error(&apos;arr1和arr2不想等&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    each(arr1, function(i, n)&#123;</span><br><span class="line">        if(n !== arr2[i])&#123;</span><br><span class="line">            throw new Error(&apos;arr1和arr2不想等&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&apos;arr1和arr2相等&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> 说实话，这个compare函数一点都算不上好看，我们目前能够顺利完成需求，还要感谢在js里可以把函数当作参数传递的特性，但在其他语言中未必能够实现。</p>
<h4 id="外部迭代器"><a href="#外部迭代器" class="headerlink" title="外部迭代器"></a>外部迭代器</h4><p> 外部迭代器必须显式地请求迭代下一个元素。外部迭代器增加了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var Iterator = function(ob) &#123;</span><br><span class="line">    var current = 0;</span><br><span class="line"></span><br><span class="line">    var next = function() &#123;</span><br><span class="line">        current += 1;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var isDone = function()&#123;</span><br><span class="line">        return current &gt;= obj.length;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var getCurrItem = function()&#123;</span><br><span class="line">        return obj[current];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var getLength = function()&#123;</span><br><span class="line">        return obj.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        next: next,</span><br><span class="line">        isDone: isDone,</span><br><span class="line">        getCurrItem: getCurrItem,</span><br><span class="line">        getLength: getLength</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var compare = function(iterator1, iterator2) &#123;</span><br><span class="line">    if(iterator1.getLength !== iterator2.getLength)</span><br><span class="line">        throw new Error(&apos;iterator1与iterator2不相等&apos;);</span><br><span class="line">    while(!iterator1.isDone() &amp;&amp; !iterator2.isDone()) &#123;</span><br><span class="line">        if(iterator1.getCurrItem() !== iterator2.getCurrItem()) &#123;</span><br><span class="line">            throw new Error(&apos;iterator1与iterator2不相等&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator1.next();</span><br><span class="line">        iterator2.next();</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;iterator1与iterator2相等&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var iterator1 = iterator([1,2,3]);</span><br><span class="line">var iterator2 = iterator([1,2,3]);</span><br><span class="line">compare(iterator1, iterator2);</span><br></pre></td></tr></table></figure></p>
<p> 外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。</p>
<h3 id="迭代类数组对象和字面量对象"><a href="#迭代类数组对象和字面量对象" class="headerlink" title="迭代类数组对象和字面量对象"></a>迭代类数组对象和字面量对象</h3><p> 迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象。比如arguments、{“0”:’a’,”1”:’b’}等。通过上面的代码观察到，无论是内部迭代器还是外部迭代器，只要迭代的聚合对象拥有length属性，而且可以用下表访问，那它就可以被迭代。<br> 在js中，for in语句可以用来迭代普通字面量对象的属性。jq中提供了$.each来封装各种迭代行为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$.each = function(obj, callback)&#123;</span><br><span class="line">    var value,</span><br><span class="line">        i = 0,</span><br><span class="line">        length = obj.length,</span><br><span class="line">        isArray = isArraylike(obj); //isArraylist 是jq中的函数</span><br><span class="line">        if(isArray) &#123; //迭代类数组</span><br><span class="line">           for(; i &lt; length; i++)&#123;</span><br><span class="line">               value = callback.call(obj[i], i, obj[i]);</span><br><span class="line">               if(value === false)&#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for(i in obj) &#123; //迭代object对象</span><br><span class="line">               value = callback.call(obj[i], i obj[i]);</span><br><span class="line">               if(value === false)&#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="倒序迭代器"><a href="#倒序迭代器" class="headerlink" title="倒序迭代器"></a>倒序迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reverseEach = function(arr, callback)&#123;</span><br><span class="line">    for(var l = arr.length - 1; l &gt;=0; l--)&#123;</span><br><span class="line">        callback(l, arr[l]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">reverseEach([1,2,3], function(i, n)&#123;</span><br><span class="line">    console.log(n);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="中止迭代器"><a href="#中止迭代器" class="headerlink" title="中止迭代器"></a>中止迭代器</h3><p>迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。jq中的each函数里有这样一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(value === false)&#123;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这句代码的意思是，约定如果回掉函数的执行结果返回false，则提前终止循环。下面我们把之前的each函数改写以下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var each = function(arr, callback)&#123;</span><br><span class="line">    for(var i = 0, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        if(callback(i, arr[i]) === false) &#123; //callback的执行结果返回false，提前终止迭代</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">each([1,2,3,4,5], function(i, n)&#123;</span><br><span class="line">    if(n &gt; 3) return false;</span><br><span class="line">    console.log(n);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器模式的应用举例"><a href="#迭代器模式的应用举例" class="headerlink" title="迭代器模式的应用举例"></a>迭代器模式的应用举例</h3><p>2013年的一天， 当我在重构某个项目中文件上传模块的代码时，发现了下面这段代码，它的目的是根据不同的浏览器获取相应的上传组件对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var getUploadObj = function()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        return new ActiveXObject(&quot;TXFTNActiveX.FTNUpload&quot;); //IE上传控件</span><br><span class="line">    &#125;catch(e) &#123;</span><br><span class="line">        if(supportFlash()) &#123;</span><br><span class="line">            var str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</span><br><span class="line">            return $(str).appendTo($(&apos;body&apos;));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            var str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot;/&gt;&quot;; //表单上传</span><br><span class="line">            return $(str).appendTo($(&apos;body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码第一很难阅读，第二是严重违反开闭原则。在开发和调试中，我们需要来回切换不同的上传方式，每次改动都相当痛苦。后来我们还增加支持了一些另外的上传方式，比如HTML5上传，这时候唯一的办法是继续往getUplaodObj函数里增加条件分支。<br>现在来梳理以下问题，目前一共有三种上传方式，我们不知道目前正在使用的浏览器支持哪种。我们可以把每种获取upload对象的方法封装在各自的函数里，然后使用一个迭代器，迭代获取这些upload对象，直到获取到一个可用的为止：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var getActiveUploadObj = function()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        return new ActiveXObject(&apos;TXFTNActiveX.FTNUpload&apos;); //IE上传控件 </span><br><span class="line">    &#125;catch(e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var getFlashUploadObj = function()&#123; </span><br><span class="line">    if(supportFlash()) &#123; //supportFlash函数未提供</span><br><span class="line">        var str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</span><br><span class="line">        return $(str).appendTo($(&apos;body&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var getFormUploadObj = function()&#123;</span><br><span class="line">    var str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot; class=&quot;ui-file&quot;/&gt;&apos;; //表单上传</span><br><span class="line">    return $(str).appendTo($(&apos;body&apos;));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var iteratorUploadObj = function()&#123;</span><br><span class="line">    for(var i = 0, fn; fn = arguments[i++];) &#123;</span><br><span class="line">        var uploadObj = fn();</span><br><span class="line">        if(uploadObj !== false) &#123;</span><br><span class="line">            return uploadObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iteratorUploadObj(getActiveUploadObj, getFlashUploadObj, getHtml5UploadOb);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p>发布-订阅模式又称观察者模式，它定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在js中，我们一般用事件模型来替代传统的发布-订阅模式。</p>
<p>发布-订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅ajax请求的error、succ等事件。或者如果想在动画的每一帧完成后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布-订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。</p>
<p>发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显示地调用另一个对象的某个接口。发布-订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这并不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</p>
<h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这里需要监控用户点击document.body的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅document.body上的click事件，当body节点被点击时，body节点便会向订阅者发布这个消息。<br>我们还可以随意增加或删除订阅者，增加任何订阅者都不会影响发布者代码的编写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.body.addEventListener(&apos;click&apos;, function()&#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">document.body.click(); //模拟用户点击</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>除了DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布-订阅模式可以用于任何js代码中。<br>现在看看如何一步步实现发布-订阅模式：</p>
<ul>
<li>首先要指定好谁充当发布者；</li>
<li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者；</li>
<li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数。</li>
</ul>
<p>另外，我们还可以往回调函数里填入一些参数，订阅者可以接受这些参数，订阅者接受到这些参数后可以进行各自的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;; //定义售楼处</span><br><span class="line">salesOffices.clientList = []; //缓存列表，存放订阅者的回调函数</span><br><span class="line">salesOffices.listen = function(fn)&#123; //增加订阅者</span><br><span class="line">    this.clientList.push(fn); //订阅的消息添加进缓存列表</span><br><span class="line">&#125;；</span><br><span class="line">salesOffices.trigger = function()&#123; //发布消息</span><br><span class="line">    for(var i = 0, fn; fn = this.clientList[i++];)&#123;</span><br><span class="line">        fn.apply(this, arguments); //(2)//arguments是发布消息时带上的参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.listen(function(price, squareMeter)&#123; //小明订阅消息</span><br><span class="line">    console.log(&apos;价格=&apos; + price);</span><br><span class="line">    console.log(&apos;squareMeter= &apos; + squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(function(price, squareMeter)&#123; //小红订阅消息</span><br><span class="line">    console.log(&apos;价格=&apos; + price);</span><br><span class="line">    console.log(&apos;squareMeter=&apos; + squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(200000, 88); // 小明订阅88平米房子的消息</span><br><span class="line">salesOffices.trigger(300000, 110);// 小红订阅110平米房子的消息</span><br></pre></td></tr></table></figure></p>
<p>至此，我们已经实现了最简单的发布-订阅模式，但这里还存在一些问题。我们看到订阅者接收到了发布者发布的每个消息，虽然小明只想买88平米的房子，但是发布者把110平米的信息也发给了小明，这对小明是不必要的困扰。所以我们有必要增加一个标示key，让订阅者只订阅自己感兴趣的消息。改写后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;; //定义售楼处</span><br><span class="line">salesOffices.clientList = &#123;&#125;; //缓存列表，存放订阅者的回调函数</span><br><span class="line">salesOffices.listen = function(key, fn)&#123;</span><br><span class="line">    if(!this.clientList[key])&#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表</span><br><span class="line">        this.clientList[key] = []; </span><br><span class="line">    &#125;</span><br><span class="line">    this.clienList[key].push(fn); //订阅的消息添加进消息缓存列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.trigger = function()&#123; //发布消息</span><br><span class="line">    var key = Array.prototype.shift.call(arguments), //取出消息类型</span><br><span class="line">        fns = this.clientList[key]; //取出该消息类型下的回调函数集合</span><br><span class="line">        if(!fns || fns.length === 0)&#123; //如果没有订阅该消息， 则返回</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    for(var i = 0, fn; fn = fns[i++];)&#123;</span><br><span class="line">        fn.apply(this, arguments); //arguments是发布消息时附送的参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter88&apos;,function(price)&#123; //小明订阅88平米房子的消息</span><br><span class="line">    console.log(price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter110&apos;, function(price)&#123; //小红订阅110平米房子消息</span><br><span class="line">    console.log(price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffice.trigger(&apos;squareMeter88&apos;, 2000000);</span><br><span class="line">salesOffice.trigger(&apos;squareMeter110&apos;, 2000000);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="发布-订阅模式的通用实现"><a href="#发布-订阅模式的通用实现" class="headerlink" title="发布-订阅模式的通用实现"></a>发布-订阅模式的通用实现</h3><p>把发布-订阅的功能提取出来，放在一个单独的对象内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var event = &#123;</span><br><span class="line">    clientList: &#123;&#125;,</span><br><span class="line">    listen: function(key, fn)&#123;</span><br><span class="line">        if(!this.clientList[key])</span><br><span class="line">            this.clientList[key] = [];</span><br><span class="line">        this.clientList[key].push(fn); //订阅的消息添加进缓存列表</span><br><span class="line">    &#125;,</span><br><span class="line">    trigger: function()&#123;</span><br><span class="line">        var key = Array.prototype.shift.call(arguments), </span><br><span class="line">            fns = this.clientList[key];</span><br><span class="line">        if(!fns || fns.length === 0)</span><br><span class="line">            return false;</span><br><span class="line">        for(var i = 0, fn; fn = fns[i++];)&#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在定义一个installEvent函数， 这个函数可以给所有的对象都动态安装发布-订阅功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var installEvent = function(obj)&#123;</span><br><span class="line">    for(var i in event) &#123;</span><br><span class="line">        obj[i] = event[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再来测试一番，我们给售楼处salesOffices动态添加发布-订阅功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var salesOffices = &#123;&#125;;</span><br><span class="line">installEvent(salesOffices);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter88&apos;, function(price)&#123; //小明订阅消息</span><br><span class="line">    console.log(&apos;价格=&apos; + price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.listen(&apos;squareMeter110&apos;, function(price)&#123; //小红订阅消息</span><br><span class="line">    console.log(&apos;价格=&apos; + price):</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(&apos;squareMeter88&apos;, 2000000);</span><br><span class="line">salesOffices.trigger(&apos;squareMeter100&apos;, 3000000);</span><br></pre></td></tr></table></figure></p>
<p>取消订阅事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">event.remove = function(key, fn)&#123;</span><br><span class="line">    var fns = this.clientList[key];</span><br><span class="line">    if(!fns)&#123; //如果key对应的消息没有被人订阅，则直接返回</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!fn) &#123; //如果没有传入具体的回调参数，表示需要取消key对应消息的所有订阅</span><br><span class="line">        fns &amp;&amp; (fns.length = 0);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(var l = fns.length - 1; l &gt;= 0; l --)&#123; //反向遍历订阅的回调函数</span><br><span class="line">                var _fn = fns[l];</span><br><span class="line">                if(_fn === fn)&#123;</span><br><span class="line">                    fns.splice(l, 1); //删除订阅者的回调函数</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="网站登陆"><a href="#网站登陆" class="headerlink" title="网站登陆"></a>网站登陆</h3><p>假如我们正在开发一个商城网站，网站里有header头部、nav导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用ajax异步请求获取用户的登陆信息。但是现在还不足以说服我们在此使用发布-订阅模式，因为异步的问题通常也可以用回调函数来解决。更重要的一点是，我们不知道除了header头部、nav导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">login.succ(function(data)&#123;</span><br><span class="line">    header.setAvatar(data.avatar); //设置header模块的头像</span><br><span class="line">    nav.setAvatar(data.avatar); //设置导航模块的头像</span><br><span class="line">    message.refresh(); //刷新消息列表</span><br><span class="line">    cart.refresh(); //刷新购物车列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>现在登陆模块是我们负责编写的，但我们还必须了解header模块里设置头像的方法叫setAvatar、购物车模块里刷新的方法叫refresh，这种耦合性会使程序变得僵硬，header模块不能随意再改变setAvatar的方法名，它自身的名字也不能被改为header1，header2。这是针对具体实现编程的典型例子，针对具体实现编程是不被赞同的。<br>等到有一天，项目中🈶️新增了一个收获地址管理的模块，这个模块本来是另一个同时所写的，而此时你正在马来西亚度假，但是他却不得不给你打电话：“hi 登陆之后麻烦刷新一下收获地址“。于是你又翻开你3个月前写的登陆模块，在最后部分加上这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">login.succ(function(data)&#123;</span><br><span class="line">    header.setAvatar(data.avatar);</span><br><span class="line">    nav.setAvatar(data.avatar);</span><br><span class="line">    message.refresh();</span><br><span class="line">    cart.refresh();</span><br><span class="line">    address.refresh(); // 增加这行代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们就会越来越疲于应付这些突如其来的业务要求，要么跳槽了事，要么必须来重构这些代码。<br>用发布-订阅模式重写后，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解它们的内部细节。改善后的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&apos;http...&apos;, function(data)&#123; //登录成功</span><br><span class="line">    login.trigger(&apos;loginSucc&apos;, data); //发布登陆成功的消息</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>各模块监听登陆成功的消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var header = (function()&#123; //header模块</span><br><span class="line">    login.listen(&apos;loginSucc&apos;, function(data)&#123;</span><br><span class="line">        header.setAvatar(data.avatar);</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">        setAvatar: function(data) &#123;</span><br><span class="line">            console.log(&apos;设置header模块的头像&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var nav = (function()&#123; //nav 模块</span><br><span class="line">    login.listen(&apos;loginSucc&apos;, function(data)&#123;</span><br><span class="line">        nav.setAvatar(data.avatar);</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">        setAvatar: function(avatar)&#123;</span><br><span class="line">            console.log(&apos;设置nav模块的头像&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>如上所述，我们随时可以把setAvatar的方法名改成其他。如果有一天在登录完成之后，又增加一个刷新收货地址列表的行为，那么只要在收获地址模块里加上监听消息的方法即可，而这可以让开发该模块的同事自己完成，你作为登录模块的开发者，永远不用关心这些行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var address = (function()&#123; //nav模块</span><br><span class="line">    login.listen(&apos;loginSucc&apos;, function(obj)&#123;</span><br><span class="line">        address.refresh(obj);</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">        refresh: function(avatar) &#123;</span><br><span class="line">            console.log(&apos;刷新收获地址&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="全局的发布-订阅对象"><a href="#全局的发布-订阅对象" class="headerlink" title="全局的发布-订阅对象"></a>全局的发布-订阅对象</h3><p>回想下刚刚实现的发布-订阅模式，我们给售楼处对象和登录都添加了订阅和发布的功能，这里还存在两个小问题。</p>
<ul>
<li>我们给每个发布者对象都添加了listen和trigger方法，以及一个缓存列表，这其实是一种资源浪费。</li>
<li>小明跟售楼处对象还是存在一定的耦合性，小明至少要知道售楼处对象的名字是salesOffices，才能顺利的订阅到事件。见如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salesOffices.listen(&apos;squareMeter100&apos;, function(price)&#123; //小明订阅消息j</span><br><span class="line">    console.log(&apos;价格= &apos;+price);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果小明还关心300平米的房子，而这套房子的卖家是salesOffice2，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salesOffices2.listen(&apos;squareMeter300&apos;, function(price)&#123;</span><br><span class="line">    console.log(&apos;价格= &apos;+price);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>引入中介<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var event = (function()&#123;</span><br><span class="line">    var clientList = &#123;&#125;,</span><br><span class="line">        listen,</span><br><span class="line">        trigger,</span><br><span class="line">        remove;</span><br><span class="line">    listen = function(key, fn)&#123;</span><br><span class="line">        if(!clientList[key]) &#123;</span><br><span class="line">            clientList[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        clientList[key].push(fn);</span><br><span class="line">    &#125;;</span><br><span class="line">    trigger = function()&#123;</span><br><span class="line">        var key = Array.prototype.shift.call(arguments),</span><br><span class="line">            fns = clientList[key];</span><br><span class="line">            if(!fns || fns.length === 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            for(var i = 0, fn; fn = fns[i++];)&#123;</span><br><span class="line">                fn.apply(this, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    remove = function(key, fn)&#123;</span><br><span class="line">        var fns = clientList[key];</span><br><span class="line">        if(!fns)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!fn)&#123;</span><br><span class="line">            fns &amp;&amp; (fns.length = 0);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(var l = fns.length - 1; l &gt;= 0; l --)&#123;</span><br><span class="line">                var _fn = fns[l];</span><br><span class="line">                if(_fn === fn)&#123;</span><br><span class="line">                    fns.splice(l, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        listen: listen,</span><br><span class="line">        trigger: trigger,</span><br><span class="line">        remove: remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Event.listen(&apos;squareMeter88&apos;, function(price)&#123; //小红订阅消息</span><br><span class="line">    console.log(price);</span><br><span class="line">&#125;);</span><br><span class="line">Event.trigger(&apos;squareMeter88&apos;, 2000000); //售楼处发布消息</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式是最简单和优雅的模式之一，命令模式中的命令指的是一个执行某些特定事情的指令。<br>命令模式最常见的<strong>应用场景是</strong>：有时候需要向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道被请求的操作是什么。此时需要用一种松耦合的方法来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。<br>拿餐厅来说，客人需要向厨师发送请求，但是完全不知道这些厨师的名字和联系方式，也不知道厨师炒菜的方式和步骤。命令模式把客人订餐的请求封装成command对象，也就是订餐中的订单对象。这个对象可以在程序中被四处传递，就像订单可以从服务员手中传到厨师的手中。这样一来，客人不需要知道厨师的名字，从而解开了请求调用者和请求接收者之间的耦合。<br>另外，相对于过程化的请求调用，command对象拥有<strong>更长的生命周期</strong>。对象的生命周期是跟初始请求无关的，因为这个请求已经封装在了command对象的方法中，成为了这个对象的行为。<br><strong>设计模式的主题总是把不变的事物和变化的事物分离开来。</strong></p>
<h3 id="命令模式的例子-菜单程序"><a href="#命令模式的例子-菜单程序" class="headerlink" title="命令模式的例子  菜单程序"></a>命令模式的例子  菜单程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;button1&quot;&gt;点击按钮1&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;button2&quot;&gt;点击按钮2&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;button3&quot;&gt;点击按钮3&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var button1 = document.getElementById(&apos;button1&apos;);</span><br><span class="line">    var button2 = document.getElementById(&apos;button2&apos;);</span><br><span class="line">    var button3 = document.getElementById(&apos;button3&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>接下来定义setCommand函数，setCommand函数负责往按钮上面安装命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var setCommand = function(button, command)&#123;</span><br><span class="line">    button.onclick = function()&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>命令接受者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var MenuBar = &#123;</span><br><span class="line">    refresh: function()&#123;</span><br><span class="line">        console.log(&quot;刷新菜单目录&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var SubMenu = &#123;</span><br><span class="line">    add: function()&#123;</span><br><span class="line">        console.log(&apos;增加子菜单&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    del: function()&#123;</span><br><span class="line">        console.log(&apos;删除子菜单&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在让button变得有用之前，我们先把行为都封装在命令类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var RefreshMenuBarCommand = function(receiver)&#123;</span><br><span class="line">    this.receiver = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">refreshMenuCommand.prototype.execute = function()&#123;</span><br><span class="line">    this.receiver.refresh();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var AddSubMenuCommand = function(receiver)&#123;</span><br><span class="line">    this.receiver = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AddSubMenuCommand.prototype.execute = function()&#123;</span><br><span class="line">    this.receiver.add();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var DelSubMenuCommand = function(receiver)&#123;</span><br><span class="line">    this.receiver = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DelSubMenuCommand.prototype.execute = function()&#123;</span><br><span class="line">    console.log(&apos;删除子菜单&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>最后把命令接受者传入到command对象中，并且把command对象安装到button上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);</span><br><span class="line">var addSubMenuCommand = new AddSubMenuCommand(SubMenu);</span><br><span class="line">var delSubMenuCommand = new DelSubMenuCommand(SubMenu);</span><br><span class="line"></span><br><span class="line">setCommand(button1, refreshMenuBarCommand);</span><br><span class="line">setCommand(button2, addSubMenuCommand);</span><br><span class="line">setCommand(button3, delSubMenuCommand);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>在js中，函数是一等对象。可以用回调函数实现命令模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var setCommand = function(button, command)&#123;</span><br><span class="line">    button.onclick = function()&#123;</span><br><span class="line">        commmand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var MenuBar = &#123;</span><br><span class="line">    refresh: function()&#123;</span><br><span class="line">        console.log(&apos;刷新菜单界面&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var RefreshMenuBarCommand = function(receiver)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        execute: function()&#123;</span><br><span class="line">            receiver.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);</span><br><span class="line">setCommand(button1, refreshMenuBarCommand);</span><br></pre></td></tr></table></figure></p>
<h3 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h3><p>宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var closeDoorCommand = &#123;</span><br><span class="line">    execute: function()&#123;</span><br><span class="line">        console.log(&apos;关门&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var openPcCommand = &#123;</span><br><span class="line">    execute: function()&#123;</span><br><span class="line">        console.log(&apos;开电脑&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var openQQCommand = &#123;</span><br><span class="line">    execute: function()&#123;</span><br><span class="line">        console.log(&apos;登录QQ&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义宏命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var MacroCommand = function()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        commandsList: [],</span><br><span class="line">        add: function(command)&#123;</span><br><span class="line">            this.commandsList.push(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        execute: function()&#123;</span><br><span class="line">            for(var i = 0, command; command = this.commandsList[i++];)&#123;</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var macroCommand = MacroCommand();</span><br><span class="line"></span><br><span class="line">macroCommand.add(closeDoorCommand);</span><br><span class="line">macroCommand.add(openPcCommand);</span><br><span class="line">macroCommand.add(openQQCommand);</span><br><span class="line"></span><br><span class="line">macroCommand.execute();</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式就是用小的对象来构建更大的对象，而这些小的子对象本身也许是由更小的孙对象构成的。<br><img src="/images/组合模式.png" alt="组合模式中的对象由一个或多个叶对象组成"></p>
<h4 id="更加强大的宏命令"><a href="#更加强大的宏命令" class="headerlink" title="更加强大的宏命令"></a>更加强大的宏命令</h4><p>要实现的功能</p>
<ul>
<li>打开空调</li>
<li>打开电视和音响</li>
<li>关门、开电脑、登录QQ<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button id=&quot;button&quot;&gt;按我&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var MacroCommand = function()&#123; //工厂模式</span><br><span class="line">            return &#123;</span><br><span class="line">                commandsList: [],</span><br><span class="line">                add: function(command)&#123;</span><br><span class="line">                    this.commandsList.push(command)</span><br><span class="line">                &#125;,</span><br><span class="line">                execute: function()&#123;</span><br><span class="line">                    for(var i = 0, command; command = this.commandsList[i++];)&#123;</span><br><span class="line">                        command.execute();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var openAcCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;打开空调&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    //电视和音响连在一起</span><br><span class="line">        var openTvCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;打开电视&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var openSoundCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;打开音响&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var macroCommand1 = MacroCommand();</span><br><span class="line">        macroCommand1.add(openTvCommand);</span><br><span class="line">        macroCommand1.add(openSoundCommand);</span><br><span class="line"></span><br><span class="line">    //关闭、打开电脑和登陆QQ的命令</span><br><span class="line">        var closeDoorCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;关门&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var openPcCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;开电脑&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var openQQCommand = &#123;</span><br><span class="line">            execute: function()&#123;</span><br><span class="line">                console.log(&apos;登陆QQ&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var macroCommand2 = MacroCommand();</span><br><span class="line">        macroCommand2.add(closeDoorCommand);</span><br><span class="line">        macroCommand2.add(openPcCommand);</span><br><span class="line">        macroCommand2.add(openQQCommand);</span><br><span class="line">    //现在把所有命令组合成一个超级命令</span><br><span class="line">        var macroCommand = MacroCommand();</span><br><span class="line">        macroCommand.add(openAcCommand);</span><br><span class="line">        macroCommand.add(macroCommand1);</span><br><span class="line">        macroCommand.add(macroCommand2);</span><br><span class="line">    //最后给遥控器绑定“超级命令”</span><br><span class="line">        var setCommand = (function(command)&#123;</span><br><span class="line">            ducoment.getElementById(&apos;button&apos;).onclick = function()&#123;</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(macroCommand):</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由上面的例子可以看出，基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，这样不断递归下去，这棵树的结构可以支持任意多的复杂度。</p>
<hr>
<h3 id="透明性带来的安全问题"><a href="#透明性带来的安全问题" class="headerlink" title="透明性带来的安全问题"></a>透明性带来的安全问题</h3><p>组合模式使得不用去区分具体的对象，这就是组合模式的透明性。<br>组合对象可以拥有子节点，叶对象下面就没有子节点，所以我们也许会发生一些误操作，比如试图往叶对象中添加子节点。解决方案通常也是给叶对象增加add方法，并且在调用这个方法时，抛出一个异常来及时提醒客户，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var MacroCommand = function()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        commandsList: [],</span><br><span class="line">        add: function(command)&#123;</span><br><span class="line">            this.commandsList.push(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        execute: function()&#123;</span><br><span class="line">            for(var i = 0, command; command = this.commandsList[i++];)&#123;</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var openTvCommand = &#123;</span><br><span class="line">    execute: function()&#123;</span><br><span class="line">        console.log(&apos;打开电视&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    add: function()&#123;</span><br><span class="line">        throw new Error(&apos;叶对象不能添加子节点&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add(openTvCommand);</span><br><span class="line">openTvCommand.add(macroCommand); //叶对象不能添加子节点</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="例子–扫描文件夹"><a href="#例子–扫描文件夹" class="headerlink" title="例子–扫描文件夹"></a>例子–扫描文件夹</h3><p>文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树，组合模式在文件夹的应用中有以下两层好处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***************** Folder *******************/</span><br><span class="line">var Folder = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.files = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.add = function(file)&#123;</span><br><span class="line">    this.files.push(file);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.scan = function()&#123;</span><br><span class="line">    console.log(&apos;开始扫描文件夹：&apos; + this.name);</span><br><span class="line">    for(var i = 0, file, files = this.files; file = files[i++];)&#123;</span><br><span class="line">        file.scan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/********************* File *****************/</span><br><span class="line">var File = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.add = function()&#123;</span><br><span class="line">    throw new Error(&apos;文件下面不能再添加文件&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.scan = function()&#123;</span><br><span class="line">    console.log(&apos;开始扫描文件&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来创建一些文件夹和文件对象，并且让他们组合成一棵树，这棵树就是我们F盘里的现有文件目录结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var folder = new Folder(&apos;学习资料&apos;);</span><br><span class="line">var folder1 = new Folder(&apos;Javascript&apos;);</span><br><span class="line">var folder2 = new Folder(&apos;JQuery&apos;);</span><br><span class="line"></span><br><span class="line">var file = new File(&apos;JS设计模式与开发实践&apos;);</span><br><span class="line">var file1 = new File(&apos;精通JQuery&apos;);</span><br><span class="line">var file2 = new File(&apos;重构与模式&apos;);</span><br><span class="line"></span><br><span class="line">folder1.add(file1);</span><br><span class="line">folder1.add(file);</span><br><span class="line">folder2.add(file2);</span><br><span class="line"></span><br><span class="line">folder.add(folder1);</span><br><span class="line">folder.add(folder2);</span><br><span class="line">folder.add(file3);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="引用父对象"><a href="#引用父对象" class="headerlink" title="引用父对象"></a>引用父对象</h3><p>组合对象保存了它下面的子节点的引用，这是组合模式的特点，此时树结构是从上至下的。但有时候我们需要在子节点上保持对父节点的引用，比如在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当我们删除某个文件时，实际上是从这个文件所在的上层文件夹中删除该文件的。</p>
<p>改写folder类和file类，在两个类的构造函数中，增加this.parent属性，并且在调用add方法时，正确设置文件或文件夹的父节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">var Folder = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.parent = null; //增加this.parent属性</span><br><span class="line">    this.files = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.add = function(file)&#123;</span><br><span class="line">    file.parent = this; //设置父对象</span><br><span class="line">    this.files.push(file);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.scan = function()&#123;</span><br><span class="line">    console.log(&apos;开始扫描文件夹：&apos;+this.name);</span><br><span class="line">    for(var i , file files = this.files; file = files[i++];)&#123;</span><br><span class="line">        file.scan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Folder.prototype.remove = function()&#123;</span><br><span class="line">    if(!this.parent)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var files = this.parent, l = files.length;l &gt;= 0; l --)&#123;</span><br><span class="line">        var file = files[l];</span><br><span class="line">        if(file === this)&#123;</span><br><span class="line">            files.splice(l, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var File = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.parent = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.add = function()&#123;</span><br><span class="line">    throw new Error(&apos;不能添加文件在下面&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.scan = function()&#123;</span><br><span class="line">    console.log(&apos;开始扫描文件：&apos;+this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File.prototype.remove = function()&#123;</span><br><span class="line">    if(!this.parent)&#123; //跟节点或者树外的游离节点</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var files = this.parent.files, l = files.length; l &gt;= 0; l --)&#123;</span><br><span class="line">        if(file === this)&#123;</span><br><span class="line">            files.splice(l, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var folder = new Folder(&apos;math&apos;);</span><br><span class="line">var file = new File(&apos;高等数学&apos;);</span><br><span class="line">folder.add(file);</span><br><span class="line">folder.scan();</span><br><span class="line"></span><br><span class="line">file.remove();</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h2><p>在js开发中用到继承的场景其实并不多，很多时候我们都喜欢用mix-in的方式给对象扩展属性。但这不代表继承在js中没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。</p>
<h3 id="模板方法模式的定义和组成"><a href="#模板方法模式的定义和组成" class="headerlink" title="模板方法模式的定义和组成"></a>模板方法模式的定义和组成</h3><p>模板方法模式是一种只需要使用继承就可以实现的非常简单的模式。<br>模板方法由两部分组成：</p>
<ul>
<li>第一部分是抽象父类</li>
<li>第二部分是具体的实现子类<br>通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</li>
</ul>
<h3 id="coffee-or-tea"><a href="#coffee-or-tea" class="headerlink" title="coffee or tea"></a>coffee or tea</h3><p>泡一杯咖啡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var Coffee = function()&#123;&#125;;</span><br><span class="line">Coffee.prototype.boilWater = function()&#123;</span><br><span class="line">    console.log(&apos;把水煮沸&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Coffee.prototype.brewCoffeeGriends = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水冲泡咖啡&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Coffee.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把咖啡倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Coffee.prototype.addSugarAndMilk = function()&#123;</span><br><span class="line">    console.log(&apos;加糖和牛奶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Coffee.prototype.init = function()&#123;</span><br><span class="line">    this.boilWater();</span><br><span class="line">    this.brewCoffeeGriends();</span><br><span class="line">    this.pourInCup();</span><br><span class="line">    this.addSugarAndMilk();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var coffee = new Coffee();</span><br><span class="line"></span><br><span class="line">coffee.init();</span><br></pre></td></tr></table></figure></p>
<p>泡一壶茶<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var Tea = function()&#123;&#125;;</span><br><span class="line">Tea.prototype.boilWater = function()&#123;</span><br><span class="line">    console.log(&apos;把水煮沸&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tea.prototype.steepTeaBag = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水浸泡茶叶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tea.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把茶水倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tea.prototype.addLemon = function()&#123;</span><br><span class="line">    console.log(&apos;加柠檬&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tea.prototype.init() = function()&#123;</span><br><span class="line">    this.boilWater();</span><br><span class="line">    this.steepTeaBag();</span><br><span class="line">    this.pourInCup();</span><br><span class="line">    this.addLemon();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var tea = new Tea();</span><br><span class="line">tea.init();</span><br></pre></td></tr></table></figure></p>
<p>抽出共同点后</p>
<ul>
<li>把水煮沸</li>
<li>用沸水冲泡饮料</li>
<li>把饮料倒进杯子</li>
<li>加调料</li>
</ul>
<p>Beverage 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Beverage = function()&#123;&#125;;</span><br><span class="line">Beverage.prototype.boilWater = function()&#123;</span><br><span class="line">    console.log(&apos;把水煮沸&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.brew = function()&#123;&#125;; //空方法， 由子类重写</span><br><span class="line">Beverage.prototype.pourInCup = function()&#123;&#125;; //空方法， 应该由子类重写</span><br><span class="line">Beverage.prototype.addCondiments = function()&#123;&#125;; //空方法，由子类实现</span><br><span class="line">Beverage.prototype.init = function()&#123;</span><br><span class="line">    this.boilWater();</span><br><span class="line">    this.brew();</span><br><span class="line">    this.pourInCup();</span><br><span class="line">    this.addCondiments();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建Coffee子类和Tea子类"><a href="#创建Coffee子类和Tea子类" class="headerlink" title="创建Coffee子类和Tea子类"></a>创建Coffee子类和Tea子类</h3><p>Coffee子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Coffee = function()&#123;&#125;;</span><br><span class="line">Coffee.prototype = new Beverage(); //继承Beverage类</span><br><span class="line">Coffee.prototype.brew = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水冲泡咖啡&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把咖啡倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.addCondiments = function()&#123;</span><br><span class="line">    console.log(&apos;加糖和牛奶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">var Coffee = new Coffee();</span><br><span class="line">Coffee.init();</span><br></pre></td></tr></table></figure></p>
<p>Tea子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Tea = function()&#123;&#125;;</span><br><span class="line">Tea.prototype = new Beverage();</span><br><span class="line">Tea.prototype.brew = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水浸泡茶叶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">Tea.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把茶倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">Tea.prototype.addCondiments = function()&#123;</span><br><span class="line">    console.log(&apos;加柠檬&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">var tea = new Tea();</span><br><span class="line">tea.init();</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="模版方法的使用场景"><a href="#模版方法的使用场景" class="headerlink" title="模版方法的使用场景"></a>模版方法的使用场景</h3><p>从大的方面讲，模板方法常被架构师用于搭建项目的框架，架构师定义好了框架的骨架，程序员继承框架的结构之后，负责往里面填空，比如java程序员大多使用过httpservlet技术来开发项目。<br>一个HttpServlet的程序包含7个生命周期，这7个生命周期分别对应一个do方法。</p>
<ul>
<li>doGet()</li>
<li>doHead()</li>
<li>doPost()</li>
<li>doPut()</li>
<li>doDelete()</li>
<li>doOption()</li>
<li>doTrace()</li>
</ul>
<p>HttpServle类还提供了一个service方法， 它就是这里的模板方法，service规定了这些do方法的执行顺序，而这些do方法的具体实现则需要HttpServet的子类来提供</p>
<hr>
<h3 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h3><p>通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法在正常状态下是适用于大多数子类的，但如果有一些特别“个性”的子类呢？使用钩子方法让子类不受父类约束。在父类中容易变化的地方放置钩子，钩子有一个默认的实现，究竟要不要挂钩，由子类自行决定。钩子方法返回的结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就有了变化的可能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var Beverage = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.boilWater = function()&#123;</span><br><span class="line">    console.log(&apos;把水烧开&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.brew = function()&#123;</span><br><span class="line">    throw new Error(&apos;子类必须重写brew方法&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.pourInCup = function()&#123;</span><br><span class="line">    throw new Error(&apos;子类必须重写pourInCup方法&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.customerWantsCondiments = function()&#123;</span><br><span class="line">    return true; //默认需要调料</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Beverage.prototype.init = function()&#123;</span><br><span class="line">    this.boilWater();</span><br><span class="line">    this.brew();</span><br><span class="line">    this.pourInCup();</span><br><span class="line">    if(this.customerWantsCondiments())&#123; //如果挂钩返回true，则需要调料</span><br><span class="line">        this.addCondiments(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var CoffeeWithHook = function()&#123;&#125;;</span><br><span class="line">CoffeeWithHook.prototype = new Beverage();</span><br><span class="line">CoffeeWithHook.prototype.brew = function()&#123;</span><br><span class="line">    console.log(&apos;用沸水冲泡咖啡&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">CoffeeWithHook.prototype.pourInCup = function()&#123;</span><br><span class="line">    console.log(&apos;把咖啡倒进杯子&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">CoffeeWithHook.prototype.addCondiments = function()&#123;</span><br><span class="line">    console.log(&apos;加🥣和牛奶&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">CoffeeWIthHook.prototype.customerWantsCondiments = function()&#123;</span><br><span class="line">    return window.confirm(&apos;请问需要调料吗?&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">var coffeeWithHook = new CoffeeWithHook();</span><br><span class="line">coffeeWithHook.init();</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h3><p>好莱坞原则：允许底层将自己挂钩到高层上，而高层组件会决定什么时候，以何种方式去使用这些底层组件。<br>模板方法模式是好莱坞原则的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法在什么时候被调用。最为子类，只负责提供一些设计上的细节。<br>除此之外，好莱坞原则还常应用于其他模式和场景，例如发布-订阅模式和回调函数</p>
<hr>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式是一种用于性能优化的模式。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。<br>如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常游泳了。在js中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事。</p>
<h3 id="初识享元模式"><a href="#初识享元模式" class="headerlink" title="初识享元模式"></a>初识享元模式</h3><p>不用享元模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var Model = function(sex, underwear)&#123;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">    this.underwear = underwear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Model.prototype.takePhoto = function()&#123;</span><br><span class="line">    console.log(&apos;sex= &apos; + this.sex + &apos; underwear=&apos; + this.underwear);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(var i = 1; i &lt;= 50; i++)&#123;</span><br><span class="line">    var maleModel = new Model(&apos;male&apos;, &apos;underwear&apos; + i);</span><br><span class="line">    maleModel.takePhoto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var j = 1; j &lt;= 50; j++)&#123;</span><br><span class="line">    var femaleModel = new Model(&apos;female&apos;, &apos;underwear&apos; + j);</span><br><span class="line">    femaleModel.takePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用享元模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var Model = function(sex)&#123;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Model.prototype.takePhoto = function()&#123;</span><br><span class="line">    console.log(&apos;sex= &apos; + this.sex + &apos; underwear=&apos; + this.underwear);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var maleModel = new Model(&apos;male&apos;);</span><br><span class="line">var femaleModel = new Model(&apos;female&apos;);</span><br><span class="line"></span><br><span class="line">//共享一个对象</span><br><span class="line">for(var i = 1; i &lt;= 50; i++)&#123;</span><br><span class="line">    maleModel.underwear = &apos;underwear&apos; + i;</span><br><span class="line">    maleModel.takePhoto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var j = 1; j &lt;= 50; j++)&#123;</span><br><span class="line">    femaleModel.underwear = &apos;underwear&apos; + j;</span><br><span class="line">    femaleModel.tablePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="对象爆炸"><a href="#对象爆炸" class="headerlink" title="对象爆炸"></a>对象爆炸</h4><p>微云的文件上传功能虽然可以选择依照队列，一个一个地排队上传，但也支持同时选择2000个文件。每一个文件都对应着一个js上传对象的创建，在第一版的开发中，的确往程序里同时new了2000个upload对象，结果可想而知，Chrome中还勉强能够支撑，IE下直接进入假死状态。<br>微云支持好几种上传方式，比如浏览器插件、flash和表单上传等，为了简化例子，我们先假设只有插件和Flash这两种。不论是插件上传，还是Flash上传，原理都是一样的，当用户选择了文件之后，插件和Flash都回调用window下的一个全局js函数，它的名字叫startUpload，用户选择的文件列表被组合成一个数组files塞进该函数的参数列表里，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var id = 0;</span><br><span class="line">window.startUpload = function(uploadType, files)&#123; //uploadType区分是控件还是flash</span><br><span class="line">    for(var i = 0, file; file = files[i++];)&#123;</span><br><span class="line">        var uploadObj = new Upload(uploadType, file.fileName, file.fileSize);</span><br><span class="line">        uploadObj.init(id++); //给upload对象设置一个唯一的id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>定义upload构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var Upload = function(uploadType, fileName, fileSize)&#123;</span><br><span class="line">    this.uploadType = uploadType;</span><br><span class="line">    this.fileName = fileName;</span><br><span class="line">    this.fileSize = fileSize;</span><br><span class="line">    this.dom = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Upload.prototype.init = function(id)&#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    this.id = id; </span><br><span class="line">    this.dom = document.createElement(&apos;div&apos;);</span><br><span class="line">    this.dom.innerHTML = &apos;&lt;span&gt;文件名称：&apos;+this.fileName+&apos;,文件大小：&apos;+this.fileSize+&apos;&lt;/span&gt;&apos;+&apos;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;&apos;;</span><br><span class="line">    this.dom.querySelector(&apos;.delFile&apos;).onclick = function()&#123;</span><br><span class="line">        that.delFile();</span><br><span class="line">    &#125;</span><br><span class="line">    document.body.appendChild(this.dom);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>删除文件逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.delFile = function()&#123;</span><br><span class="line">    if(this.fileSize &lt; 3000)&#123;</span><br><span class="line">        return this.dom.parentNode.removeChild(this.dom);</span><br><span class="line">    &#125;</span><br><span class="line">    if(window.confirm(&apos;确定要删除该文件吗？&apos;+this.fileName))&#123;</span><br><span class="line">        return this.dom.parentNode.removeChild(this.dom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来创建3个插件上传对象和3个Flash上传对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">startUpload(&apos;plugin&apos;, [</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;1.txt&apos;,</span><br><span class="line">        fileSize: 1000</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;2.html&apos;,</span><br><span class="line">        fileSize: 3000</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;3.txt&apos;,</span><br><span class="line">        fileSize: 5000</span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">startUpload(&apos;flash&apos;, [</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;4.txt&apos;,</span><br><span class="line">        fileSize: 1000</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;5.html&apos;,</span><br><span class="line">        fileSize: 3000</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        fileName: &apos;6.txt&apos;,</span><br><span class="line">        fileSize: 5000</span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p>
<h4 id="使用享元模式重构"><a href="#使用享元模式重构" class="headerlink" title="使用享元模式重构"></a>使用享元模式重构</h4><p>先确认内部状态，内、外部状态划分依据：</p>
<ul>
<li>内部状态存储于对象内部。</li>
<li>内部状态可以被一些对象共享</li>
<li>内部状态独立于具体的场景，通常不会改变</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li>
</ul>
<h4 id="剥离外部状态"><a href="#剥离外部状态" class="headerlink" title="剥离外部状态"></a>剥离外部状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Upload = function(uploadType)&#123;</span><br><span class="line">    this.uploadType = uploadType;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.delFile = function(id)&#123;</span><br><span class="line">    uploadManager.setExternalState(id, this); </span><br><span class="line">    if(this.fileSize &lt; 3000)&#123;</span><br><span class="line">        return this.dom.parentNode.removeChild(this.dom);</span><br><span class="line">    &#125;</span><br><span class="line">    if(window.confirm(&apos;确定要删除该文件吗？&apos; + this.fileName))&#123;</span><br><span class="line">        return this.dom.parentNode.removeChild(this.dom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="工厂进行对象实例化"><a href="#工厂进行对象实例化" class="headerlink" title="工厂进行对象实例化"></a>工厂进行对象实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var UploadFactory = (function()&#123;</span><br><span class="line">    var createdFlyWeightObjs = &#123;&#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        create: function(uploadType)&#123;</span><br><span class="line">            if(createdFlyWeightObjs[uploadType])&#123;</span><br><span class="line">                return createdFlyWeightObjs[uploadType];</span><br><span class="line">            &#125;</span><br><span class="line">            return createdFlyWeightObjs[uploadType] = new Upload(uploadType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="管理器封装外部状态"><a href="#管理器封装外部状态" class="headerlink" title="管理器封装外部状态"></a>管理器封装外部状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var uploadManager = (function()&#123;</span><br><span class="line">    var uploadDatabase = &#123;&#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        add: function(id, uploadType, fileName, fileSize)&#123;</span><br><span class="line">            var flyWeightObj = UploadFactory.create(uploadType)</span><br><span class="line">            var dom = document.createElement(&apos;div&apos;);</span><br><span class="line">            dom.innerHTML = &apos;&lt;span&gt;文件名称：&apos;+fileName+&apos;,文件大小：&apos;+fileSize+&apos;&lt;/span&gt;&apos;+&apos;&lt;button class=&quot;delFile&quot;&gt;删除&lt;/button&gt;&apos;;</span><br><span class="line">            dom.querySelector(&apos;.delFile&apos;).onclick = function()&#123;</span><br><span class="line">                flyWeightObj.delFile(id);</span><br><span class="line">            &#125;</span><br><span class="line">            document.body.appendChild(dom);</span><br><span class="line">            uploadDatabase[id] = &#123;</span><br><span class="line">                fileName: fileName,</span><br><span class="line">                fileSize: fileSize,</span><br><span class="line">                dom: dom</span><br><span class="line">            &#125;;</span><br><span class="line">            return flyWeightObj;</span><br><span class="line">        &#125;,</span><br><span class="line">        setExternalState: function(id, flyWeightOb)&#123;</span><br><span class="line">            var uploadData = uploadDatabase[id];</span><br><span class="line">            for(var i in uploadData)&#123;</span><br><span class="line">                flyWeightObj[i] = uploadData[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">window.startUpload = function(uploadType, files)&#123;</span><br><span class="line">    for(var i = 0, file; file = files[i++];)&#123;</span><br><span class="line">        var uploadObj = uploadManager.add(++id , uploadType, file.fileName, file.fileSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>职责链的定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对西那个练成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。</p>
<h3 id="实际开发中的职责链模式"><a href="#实际开发中的职责链模式" class="headerlink" title="实际开发中的职责链模式"></a>实际开发中的职责链模式</h3><p>假设我们负责一个售卖手机的电商网站，经过分别交纳500元定金和200元定金的两轮预定后（订单已在此时产生），现在已经到了正式购买的阶段。公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过500元定金的用户会收到100元的商城优惠券，200元定金的用户可以收到50元的优惠券，而之前没有支付定金的用户只能进入普通模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。<br>我们的订单页面是PHP吐出的模版，在页面加载之初，PHP会传递给页面几个字段。<br>orderType：表示订单类型（定金用户或普通购买用户），code的值为1的时候是500元定金用户，为2的时候是200元定金用户，为3时为普通用户。<br>pay：表示用户是否已经支付过定金，值为true或者false，虽然用户已经下过500元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。<br>stock： 表示当前用于普通购买的手机库存数量，已经支付过500元或者200元定金的用户不受限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var order = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(orderType === 1)&#123;</span><br><span class="line">        if(pay === true)&#123;</span><br><span class="line">            console.log(&apos;500元定金预购，得到100优惠券&apos;);</span><br><span class="line">        &#125;else&#123; </span><br><span class="line">            if(stock &gt; 0)&#123;</span><br><span class="line">                console.log(&apos;普通购买，无优惠券&apos;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                console.log(&apos;手机库存不足&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(orderType === 2)&#123;</span><br><span class="line">        if(par === true)&#123;</span><br><span class="line">            console.log(&apos;200元定金预购，得到50优惠券&apos;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(stock &gt; 0)&#123;</span><br><span class="line">                console.log(&apos;普通购买，无优惠券&apos;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                console.log(&apos;手机库存不足&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;elseif(orderType === 3)&#123;</span><br><span class="line">        if(stock &gt; 0)&#123;</span><br><span class="line">            console.log(&apos;普通购买，无优惠券&apos;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&apos;手机库存不足&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">order(1,true,500);</span><br></pre></td></tr></table></figure>
<p>虽然我们得到了意料中的运行结果，但这远远算不上一段值得夸奖的代码。order函数不仅巨大到难以阅读，而且需要经常进行修改。虽然目前项目能正常运行，但接下来的维护工作无疑是个梦魇。恐怕只有最新手的程序员才会写出这样的代码。</p>
<h3 id="用职责链模式重构代码"><a href="#用职责链模式重构代码" class="headerlink" title="用职责链模式重构代码"></a>用职责链模式重构代码</h3><p>现在我们采用职责链模式重构这段代码，先把500元订单、200元订单以及普通购买分成3个函数。接下来把orderType、pay、stock这3个字段当作参数传递给500元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的200元订单函数，如果200元订单函数依然不能处理该请求，则继续传递请求给普通购买函数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var order500 = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(orderType === 1 &amp;&amp; pay === true)&#123;</span><br><span class="line">        console.log(&apos;500元定金预约，得到100优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        order200(orderType,pay,stock); //将请求传递给200元订单</span><br><span class="line">        //order200 和 order500耦合</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var order200 = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(orderType === 2 &amp;&amp; pay === true)&#123;</span><br><span class="line">        console.log(&apos;200元定金预购，得到50优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        orderNormal(orderType, pay, stock); //将请求传递给普通订单</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var orderNorNamal = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(stock &gt; 0)&#123;</span><br><span class="line">        console.log(&apos;普通购买，无优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&apos;手机库存不足&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上代码虽然有了进步，但依然违反了开放-封闭原则，如果有一天我们要增加300元预定或者去掉200元预定，意味着就必须改动这些业务函数内部。就像一根环环相扣打了死结的链条，如果要增加、拆除或者移动一个节点，就必须砸烂这根链条。</p>
<h3 id="灵活可拆分的职责链节点"><a href="#灵活可拆分的职责链节点" class="headerlink" title="灵活可拆分的职责链节点"></a>灵活可拆分的职责链节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var order500 = function(orderType, pay. stock)&#123;</span><br><span class="line">    if(orderType === 1 &amp;&amp; pay == true)&#123;</span><br><span class="line">        console.log(&apos;500元定金预购，得到100优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return &apos;nextSuccessor&apos;; //我不知道下一个节点是谁，反正把请求往后传递</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var order200 = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(orderType === 2 &amp;&amp; pay === true)&#123;</span><br><span class="line">        console.log(&apos;200元定金预购，得到50元优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return &apos;nextSuccessor&apos;; //我不知道下一个节点是谁，反正把请求往后传递</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var orderNormal = function(orderType, pay, stock)&#123;</span><br><span class="line">    if(stock &gt; 0)&#123;</span><br><span class="line">        console.log(&apos;普通购买， 无优惠券&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&apos;手机库存不足&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来需要把函数包进职责链节点，我们定义一个构造函数Chain，在new Chain的时候传递的参数即为需要被包装的函数，同时它还拥有一个实例属性this.successor，表示在链中的下一个节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var Chain = function(fn)&#123;</span><br><span class="line">    this.fn = fn;</span><br><span class="line">    this.successor = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Chain.prototype.setNextSuccessor = function(successor)&#123; //指定在链中的下一个节点</span><br><span class="line">    return this.successor = successor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Chain.prototype.passRequest = function()&#123; //传递请求给某个节点</span><br><span class="line">    var ret = this.fn.apply(this, arguments);</span><br><span class="line">    if(ret === &apos;nextSuccessor&apos;)&#123;</span><br><span class="line">        //递归</span><br><span class="line">        return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在我们把3个订单函数分别包装成职责链的节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var chainOrder500 = new Chain(order500);</span><br><span class="line">var chainOrder200 = new Chain(order200);</span><br><span class="line">var chainOrderNormal = new Chain(orderNormal);</span><br><span class="line">chainOrder500.setNextSuccessor(chainOrder200);</span><br><span class="line">chainOrder200.setNextSuccessor(chainOrderNormal);</span><br><span class="line">chainOrder500.passRequest(1,true,500);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="用AOP实现职责链"><a href="#用AOP实现职责链" class="headerlink" title="用AOP实现职责链"></a>用AOP实现职责链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.after = function(fn)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var ret = self.apply(this, arguments);</span><br><span class="line">        if(ret === &apos;nextSuccessor&apos;)&#123;</span><br><span class="line">            return fn.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var order = order500yuan.after(order200yuan).after(orderNormal);</span><br><span class="line">order(1,true,500);</span><br></pre></td></tr></table></figure>
<p>用AOP来实现职责链既简单又巧妙，但这种把函数叠在一起的方式，同时也叠加了函数的作用域，如果链条太长的话，也会对性能有较大的影响。</p>
<hr>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>在我们生活中，每个人每个物体之间都会产生一些错综复杂的联系。在应用程序也是一样，程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。<br>面向对象设计鼓励将行为分布到各个对象中，把对象分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度的对象激增，又有可能会反过来降低它们的可复用性。<br><img src="/images/对象与对象之间紧耦合.png" alt><br>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个对象后，所有的相关对象都通过中介者对象来通信，而不是相互引用，所以当一个对象发生变化时，只需要通知终结者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br><img src="/images/中介者模式.png" alt></p>
<hr>
<h3 id="用中介者模式改造泡泡堂游戏"><a href="#用中介者模式改造泡泡堂游戏" class="headerlink" title="用中介者模式改造泡泡堂游戏"></a>用中介者模式改造泡泡堂游戏</h3><p>首先仍然是定义Player构造函数和player对象的原型方法，在player对象的这些原型方法中，不再负责具体的执行逻辑，而是把操作转交给中介者对象，我们把中介者对象命名为playerDIrector:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function Player(name, teamColor)&#123;</span><br><span class="line">    this.name = name; //角色名字</span><br><span class="line">    this.teamColor = teamColor; //队伍颜色</span><br><span class="line">    this.state = &apos;alive&apos;; //玩家生存状态</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Player.prototype.win = function()&#123;</span><br><span class="line">    console.log(this.name + &apos; won&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Player.prototype.lose = function()&#123;</span><br><span class="line">    console.log(this.name + &apos; lost&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**************** 玩家死亡 *****************/</span><br><span class="line">Player.prototype.die = function()&#123;</span><br><span class="line">    this.state = &apos;dead&apos;;</span><br><span class="line">    playerDirectory.receiveMessage(&apos;playerDead&apos;, this); // 给中介者发送消息，玩家死亡</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**************** 移除玩家 *****************/</span><br><span class="line">Player.prototype.remove = function()&#123;</span><br><span class="line">    playerDirectory.receiveMessage(&apos;removeDead&apos;, this); // 给中介者发送消息，移除一个玩家</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*************** 玩家换队 ****************/</span><br><span class="line">Player.prototype.changeTeam = function(color)&#123;</span><br><span class="line">    playerDirectory.receiveMessage(&apos;changeTeam&apos;, this, color); //给中介者发送消息，玩家换队</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再继续改写之前创建玩家对象的工厂函数，可以看到，因为工厂函数里不再需要给创建的玩家对象设置队友和敌人，这个工厂函数几乎失去了工厂的意义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var playerFactory = function(name, teamColor)&#123;</span><br><span class="line">    var newPlayer = new Player(name, teamColor); //创建一个新的玩家对象</span><br><span class="line">    playerDirectory.receiveMessage(&apos;addPlayer&apos;, newPlayer); //给中介者发送消息，新增玩家</span><br><span class="line">    return newPlayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们要实现这个中介者playerDirectory对象，一般有以下两种方式。</p>
<ul>
<li>利用发布-订阅模式。将playerDIrectory实现为订阅者，各player作为发布者，一旦player的状态发生改变，便推送消息给playerDirectory，playerDirectory处理消息后将反馈发送给其他player。</li>
<li>在playerDirectory中开放一些接受消息的接口，各player可以直接调用该接口来给playerDIrectory发送消息，player只需传递一个参数给playerDirectory，这个参数的目的是使playerDirectory可以识别发送着。同样，playerDirectory接收到消息后会将处理结果反馈给其他player。<br>这两种方式的实现本质上没什么区别。在这里我们使用第二种方式，playerDirectory开放一个对外暴露的接口receiveMessage，负责接受player对象发送的消息，而player对象发送消息的时候，总是把自身this作为参数发送给playerDirectory，以便playerDirectory识别消息来自于哪个玩家对象，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">var playerDirectory = (function()&#123;</span><br><span class="line">    var players = &#123;&#125;, //保存所有玩家</span><br><span class="line">        operations = &#123;&#125;; //中介者可以执行的操作</span><br><span class="line">    /************ 新增一个玩家 ***************/</span><br><span class="line">    operations.addPlayer = function(player)&#123;</span><br><span class="line">        var teamColor = player.teamColor; //玩家的队伍颜色</span><br><span class="line">        players[teamColor] = players[teamColor] || []; //如果该颜色的玩家还没有成立队伍，则新成立一个队伍</span><br><span class="line">        players[teamColor].push(player); //添加玩家进队伍</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**************** 移除一个玩家 ***********/</span><br><span class="line">    operations.removePlayer = function(player)&#123;</span><br><span class="line">        var teamColor = player.teamColor, //玩家的队伍颜色</span><br><span class="line">            teamPlayers = players[teamColor] || [];//该队伍所有成员</span><br><span class="line">        for(var i = teamPlayers.length - 1; i &gt;= 0; i --)&#123; //遍历删除</span><br><span class="line">            if(teamPlayer[i] === player)&#123;</span><br><span class="line">                teamPlayer.splice(i, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /************* 玩家换队 **************/</span><br><span class="line">    operations.changeTeam = function(player, newTeamColor)&#123; //玩家换队</span><br><span class="line">        operations.removePlayer(player); //从原队伍中删除</span><br><span class="line">        player.teamColor = newTeamColor; //改变队伍颜色</span><br><span class="line">        operations.addPlayer(player); //增加到新队伍中</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    operations.playerDead = function(player)&#123; //玩家死亡</span><br><span class="line">        var teamColor = player.teamColor,</span><br><span class="line">            teamPlayer = players[teamColor]; // 玩家所在队伍</span><br><span class="line">        var all_dead = true;</span><br><span class="line">        for(var i = 0, player; player = teamPlayers[i++];)&#123;</span><br><span class="line">            if(player.state !== &apos;dead&apos;)&#123;</span><br><span class="line">                all_dead = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(all_dead === true)&#123; //全部死亡</span><br><span class="line">            for(var i = 0, player; player = teamPlayers[i++];)&#123;</span><br><span class="line">                player.lose(); //本队所有玩家lose</span><br><span class="line">            &#125;</span><br><span class="line">            for(var color in players)&#123;</span><br><span class="line">                if(color !== teamColor)&#123;</span><br><span class="line">                    var teamPlayers = players[color]; // 其他队伍的玩家</span><br><span class="line">                    for(var i = 0, player; player = teamPlayers[i++];)&#123;</span><br><span class="line">                        player.win(); //其他队伍所有玩家win</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var receiveMessage = function()&#123;</span><br><span class="line">            var message = Array.prototype.shift.call(arguments); //arguments的第一个参数为消名称</span><br><span class="line">            operations[message].apply(this, arguments);</span><br><span class="line">        &#125;;</span><br><span class="line">        return &#123;</span><br><span class="line">            receiveMessage: receiveMessage</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">//红队</span><br><span class="line">var player1 = playerFacotory(&apos;皮蛋&apos;, &apos;red&apos;);</span><br><span class="line">    player2 = playerFacotory(&apos;小乖&apos;, &apos;red&apos;);</span><br><span class="line">    player3 = playerFacotory(&apos;宝宝&apos;, &apos;red&apos;);</span><br><span class="line">    player4 = playerFacotory(&apos;小强&apos;, &apos;red&apos;);</span><br><span class="line"></span><br><span class="line">//蓝队</span><br><span class="line">    player5 = playerFacotory(&apos;黑妞&apos;, &apos;blue&apos;);</span><br><span class="line">    player5 = playerFacotory(&apos;葱头&apos;, &apos;blue&apos;);</span><br><span class="line">    player5 = playerFacotory(&apos;胖墩&apos;, &apos;blue&apos;);</span><br><span class="line">    player5 = playerFacotory(&apos;海盗&apos;, &apos;blue&apos;);</span><br><span class="line"></span><br><span class="line">player1.die();</span><br><span class="line">player2.die();</span><br><span class="line">player3.die();</span><br><span class="line">player4.die();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式可以动态的给每个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。<br>再传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，但超类改变时，子类也会随之改变；另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱复用”是相对可见行而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常破坏了分装性。</p>
<h3 id="模拟传统面向对象语言的装饰着模式"><a href="#模拟传统面向对象语言的装饰着模式" class="headerlink" title="模拟传统面向对象语言的装饰着模式"></a>模拟传统面向对象语言的装饰着模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Plane = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Plane.prototype.fire = function()&#123;</span><br><span class="line">    console.log(&apos;发射普通子弹&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//接下来增加两个装饰类，分别是导弹和原子弹：</span><br><span class="line">var MissileDecorator = function(plane)&#123;</span><br><span class="line">    this.plane = plane;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MissleDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plane.fire();</span><br><span class="line">    console.log(&apos;发射导弹&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var AtomDecorator = function(plane)&#123;</span><br><span class="line">    this.plane = plane;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AtomDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plane.fire();</span><br><span class="line">    console.log(&apos;发射原子弹&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="js装饰者"><a href="#js装饰者" class="headerlink" title="js装饰者"></a>js装饰者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var plane = &#123;</span><br><span class="line">    fire: function()&#123;</span><br><span class="line">        console.log(&apos;发射普通子弹&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var missleDecorator = function()&#123;</span><br><span class="line">    console.log(&apos;发射原子弹&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fire1 = plane.fire;</span><br><span class="line">plane.fire = function()&#123;</span><br><span class="line">    fire1();</span><br><span class="line">    missleDecoretor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fire2 = place.fire;</span><br><span class="line">plane.fire = function()&#123;</span><br><span class="line">    fire2();</span><br><span class="line">    atomDecorator();</span><br><span class="line">&#125;</span><br><span class="line">plane.fire();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="第一个例子：-电灯程序"><a href="#第一个例子：-电灯程序" class="headerlink" title="第一个例子： 电灯程序"></a>第一个例子： 电灯程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var Light = function()&#123;</span><br><span class="line">    this.state = &apos;off&apos;; //给电灯设置初始状态off</span><br><span class="line">    this.button = null; // 电灯开关按钮</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">        self = this;</span><br><span class="line">    button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Light.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    if(this.state === &apos;off&apos;)&#123;</span><br><span class="line">        console.log(&apos;开灯j&apos;);</span><br><span class="line">    &#125;else if(this.state === &apos;on&apos;)&#123;</span><br><span class="line">        console.log(&apos;关灯&apos;);</span><br><span class="line">        this.state = &apos;off&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var light = new Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure>
<h3 id="状态模式改进电灯程序"><a href="#状态模式改进电灯程序" class="headerlink" title="状态模式改进电灯程序"></a>状态模式改进电灯程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">var OffLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OffLightState.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    console.log(&apos;弱光&apos;); //offLightState对应的行为</span><br><span class="line">    this.light.setState(this.light.weakLightState); //切换状态到weakLightState </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var WeakLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">WeakLightState.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    console.log(&apos;强光&apos;); //weakLightState对应的行为</span><br><span class="line">    this.light.setState(this.light.strongLightState); //切换状态到strongLightState</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var StrongLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrongLightState.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    console.log(&apos;关灯&apos;); // strongLightState对应的行为</span><br><span class="line">    this.light.setState(this.light.offLightState);// 切换状态到offLightStatej</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Light = function()&#123;</span><br><span class="line">    this.offLightState = new OffLightState(this);</span><br><span class="line">    this.weakLightState = new WeakLightState(this);</span><br><span class="line">    this.strongLightState = new StrongLightState(this);</span><br><span class="line">    this.button = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">        self = this;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.curState = this.offLightState; //设置当前状态</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.curState.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Light.prototype.setState = function(newState)&#123;</span><br><span class="line">    this.curState = newState;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var light = new Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var googleMap = &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">        console.log(&apos;开始渲染谷歌地图&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var baiduMap = &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">        console.log(&apos;开始渲染百度地图&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var renderMap = function(map)&#123;</span><br><span class="line">    if(map.show instanceof Function)&#123;</span><br><span class="line">        map.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">renderMap(googleMap); //输出： 开始渲染谷歌地图</span><br><span class="line">renderMap(baiduMap); //输出： 开始渲染百度地图</span><br></pre></td></tr></table></figure>
<p>这段程序得以运行大关键是googleMap和baiduMap提供了一致的show方法，但第三方的接口方法并不在我们自己的控制范围之内，假如baiduMap提供的显示地图的方法不叫show而叫display呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var googleMap = &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">        console.log(&apos;开始渲染谷歌地图&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var baiduMap = &#123;</span><br><span class="line">    display: function()&#123;</span><br><span class="line">        console.log(&apos;开始渲染百度地图&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var baiduMapAdapter = &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">        return baiduMap.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap(googleMap);</span><br><span class="line">renderMap(baiduMapAdapter);</span><br></pre></td></tr></table></figure>
<p>另一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var getGuangdongCity = function()&#123;</span><br><span class="line">    var guangdongCity = [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &apos;shenzhen&apos;,</span><br><span class="line">            id: 11,</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            name: &apos;guangzhou&apos;,</span><br><span class="line">            id: 12,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line">    return guangdongCity;</span><br><span class="line">&#125;;</span><br><span class="line">var render = function(fn)&#123;</span><br><span class="line">    console.log(&apos;开始渲染广东省地图&apos;);</span><br><span class="line">    document.write(JSON.stringify(fn()));</span><br><span class="line">&#125;;</span><br><span class="line">render(getGuangdongCity);</span><br></pre></td></tr></table></figure></p>
<p>利用这些数据，我们编写了真个页面，并且在线上运行了一段时间。后来发现这些数据不太可靠，里面还缺少很多城市。于是我们又在网上找到了另外一些数据资源，这次的数据更加全面，但遗憾的是，数据结构和正在运行项目中的并不一致。新的数据结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var guangdongCity = &#123;</span><br><span class="line">    shenzhen: 11,</span><br><span class="line">    guangzhou: 12,</span><br><span class="line">    zhuhai: 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了大动干戈地改写渲染页面的前端代码之外，另外一种更轻便的解决方案就是新增一个数据格式转换的适配器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var getGuangdongCity = function()&#123;</span><br><span class="line">    var guangdongCity = [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &apos;shenzhen&apos;,</span><br><span class="line">            id: 11</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            name: &apos;guangdong&apos;,</span><br><span class="line">            id: 12</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line">    return guangdongCity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var render = function(fn)&#123;</span><br><span class="line">    console.log(&apos;开始渲染广东省地图&apos;);</span><br><span class="line">    document.write(JSON.stringify(fn()));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var addressAdapter = function(oldAddressfn)&#123;</span><br><span class="line">    var address = &#123;&#125;,</span><br><span class="line">        oldAddress = oldAddressfn();</span><br><span class="line">    for(var i = 0, c; c = oldAddress[i++];)&#123;</span><br><span class="line">        address[c.name] = c.id;</span><br><span class="line">    &#125;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">render(addressAdapter(getGuangdongCity));</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="面向委托的设计"><a href="#面向委托的设计" class="headerlink" title="面向委托的设计"></a>面向委托的设计</h2><p>js中一切皆对象，没有类模版，类不过是js中的语法糖。在js中面向委托编程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Task = &#123;</span><br><span class="line">    setID: function()&#123;this.id = ID;&#125;,</span><br><span class="line">    outputID: function()&#123;console.log(this.id);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//让XYZ委托Task</span><br><span class="line">XYZ = Object.create(Task); //创建一个新的XYZ对象，并关联对象到Task。</span><br><span class="line">XYZ.prepareTask = function(ID, Label)&#123;</span><br><span class="line">    this.setID(ID);</span><br><span class="line">    this.Label = Label;</span><br><span class="line">&#125;</span><br><span class="line">XYZ.outputTaskDetails = function() &#123;</span><br><span class="line">    this.outputID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开发原则"><a href="#开发原则" class="headerlink" title="开发原则"></a>开发原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有连个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。</p>
<h3 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h3><p>最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块‘函数、变量等。<br>下面引用《面向对象设计原理和模式》一书中的例子来解释最少知识原则：</p>
<blockquote>
<p>某军队中的将军需要挖掘一些散兵坑。下面是完成任务的一种方式：将军可以通知上校让他叫来少校，然后让少校找来少尉，并让上尉通知一个军士，最后军士唤来一个士兵，然后命令士兵挖掘一些散兵坑。</p>
</blockquote>
<p>这种方式十分荒谬，不是吗？不过，我们还是先来看一下这个过程的等价代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">general.getColonel(c).getMajor(m).getCaptain(c).getSergeant(s).getPrivate(p).digFoxHole();</span><br></pre></td></tr></table></figure></p>
<p>让代码通过这么长的消息链才能完成一个任务，这就像让将军通过那么多繁琐的步骤才能命令别人挖掘散兵坑一样荒谬！而且，这条链中任何一个对象的改动都会影响整条链的结果。<br>最有可能的是，将军自己根本不会考虑挖散兵坑这样的细节信息。但是如果将军真的考虑了这个问题的话，他一定会通知某个军官：“我不关心这个工作如何完成，但是你得命令人去挖散兵坑”。</p>
<h3 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h3><p>在面向对象的程序设计中，开放封闭原则（OCP）是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放-封闭原则。<br>开放-封闭原则最早由Eiffel语言的设计者Bertrand Meyer在其著作Object-Oriented Software Constructtion中提出。它的定义如下：</p>
<blockquote>
<p>软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/12/CMake简单教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/CMake简单教程/" itemprop="url">CMake简单教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T14:33:59+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-c/" itemprop="url" rel="index">
                    <span itemprop="name">c/c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>main.c 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    print(&quot;这是第一步&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写CMakeLists.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目名称</span><br><span class="line">project (Demo1)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.c)</span><br></pre></td></tr></table></figure></p>
<p>在命令行执行cmake .,得到Makefile后再用make命令编译得到可执行文件</p>
<hr>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>一个目录，多个源文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./Demo2</span><br><span class="line">    |</span><br><span class="line">    +--- main.c</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.c</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.h</span><br></pre></td></tr></table></figure></p>
<p>main.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    if(argc &lt; 3) &#123;</span><br><span class="line">        printf(&quot;Usage: %s base exponent\n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MathFunctions.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double power(double base, int exponent);</span><br></pre></td></tr></table></figure></p>
<p>MathFunctions.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">double power(double base, int exponent)&#123;</span><br><span class="line">    int result = base;</span><br><span class="line">    int i;</span><br><span class="line">    if (exponent == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 1; i &lt; exponent; i++)&#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CMakeLists.txt 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo2)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到DIR_SRCS变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo $&#123;DIR_SRCD&#125;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>多个目录， 多个源文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./Demo3 </span><br><span class="line">    |</span><br><span class="line">    +--- main.c</span><br><span class="line">    |</span><br><span class="line">    +--- math/</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.c</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.h</span><br></pre></td></tr></table></figure></p>
<p>CMakeLists.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project （Demo3）</span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"># 添加子目录</span><br><span class="line">add_subdirectory(math)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.c)</span><br><span class="line"># 添加链接库</span><br><span class="line">target_link_libraries(Demo MathFunctions)</span><br></pre></td></tr></table></figure></p>
<p>math/CMakeLists.txt 生成静态库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"># 生成链接库</span><br><span class="line">add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>自定义编译选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line">project (Demo4)</span><br><span class="line"></span><br><span class="line"># 加入一个配置头文件，用于处理CMake对源码的设置 config.h将由config.h.in生成</span><br><span class="line">configure_file (</span><br><span class="line">    &quot;$&#123;PROJECT_SOURCE_DIR&#125;/config.h.in&quot;</span><br><span class="line">    &quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 是否使用子的 MathFunctions 库</span><br><span class="line">option (</span><br><span class="line">    USE_MYMATH &quot;Use provided math implementation&quot; ON</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 是否加入 MathFunctions 库</span><br><span class="line">if (USE_MYMATH)</span><br><span class="line">    include_directories (&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;)</span><br><span class="line">    add_subdirectory (math)</span><br><span class="line">    set (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)</span><br><span class="line">endif (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br><span class="line"></span><br><span class="line">target_link_libraries (Demo $&#123;EXTRA_LIBS&#125;)</span><br></pre></td></tr></table></figure></p>
<p>main.cc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef USE_MYMATH</span><br><span class="line">    #include &quot;math/MathFunctions&quot;</span><br><span class="line">#else</span><br><span class="line">    #include </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    if(argc &lt; 3) &#123;</span><br><span class="line">        printf(&quot;Usage: %s base exponent \n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line"></span><br><span class="line">    #ifdef USE_MYMATH</span><br><span class="line">        printf(&quot;Now we use our own math library&quot;);</span><br><span class="line">        double result = power(base, exponent);</span><br><span class="line">    #else</span><br><span class="line">        printf(&quot;Now we use standard math library&quot;);</span><br><span class="line">        double result = power(base, exponent);</span><br><span class="line">    #endif</span><br><span class="line">    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>config.h.in<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#cmakedefine USE_MYMATH</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>安装和测试</p>
<p>添加至CMakeLists.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 指定安装路径</span><br><span class="line">install (TARGETS Demo DESTINATION bin)</span><br><span class="line">install (FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span><br><span class="line">         DESTINATION include)</span><br></pre></td></tr></table></figure></p>
<p>添加至math/CMakeLists.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 指定 MathFunctions 库的安装路径</span><br><span class="line">install (TARGETS MathFunctions DESTINATION bin)</span><br><span class="line">install (FILES MathFunctions.h DESTINATION include)</span><br></pre></td></tr></table></figure></p>
<p>通过上面的定制，生成的Demo文件和MathFunctions函数库libMathFunctions.o文件将会被复制到/usr/local/local/<strong>bin</strong>中，而MathFunctions.h和生成的config.h被复制到/usr/local/<strong>include</strong>下</p>
<p>为工程添加测试 添加add_test到CMakeLists.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 启用测试</span><br><span class="line">enable_testing()</span><br><span class="line"># 测试程序是否成功运行</span><br><span class="line">add_test (test_run Demo 5 2)</span><br><span class="line"># 测试帮助信息是否可以正常提示</span><br><span class="line">add_test (test_usage Demo)</span><br><span class="line">set_tests_properties (test_usage</span><br><span class="line">  PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage: .* base exponent&quot;)</span><br><span class="line"># 测试 5 的平方</span><br><span class="line">add_test (test_5_2 Demo 5 2)</span><br><span class="line">set_tests_properties (test_5_2</span><br><span class="line"> PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 25&quot;)</span><br><span class="line"># 测试 10 的 5 次方</span><br><span class="line">add_test (test_10_5 Demo 10 5)</span><br><span class="line">set_tests_properties (test_10_5</span><br><span class="line"> PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 100000&quot;)</span><br><span class="line"># 测试 2 的 10 次方</span><br><span class="line">add_test (test_2_10 Demo 2 10)</span><br><span class="line">set_tests_properties (test_2_10</span><br><span class="line"> PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 1024&quot;)</span><br></pre></td></tr></table></figure></p>
<p>支持gdb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_BUILD_TYPE &quot;Debug&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;)</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/10/linux高性能服务器编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/linux高性能服务器编程/" itemprop="url">linux高性能编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T14:03:13+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="tcp-amp-ip"><a href="#tcp-amp-ip" class="headerlink" title="tcp&amp;ip"></a>tcp&amp;ip</h2><p><img src="/images/TCP:IP协议族体系结构及主要协议.png" alt="TCP/IP协议族体系结构及主要协议"></p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层的两个常用协议是ARP协议（Address Resolve Protocol）地址解析协议和RARP（Reverse Address Resolve Protocol）逆地址解析协议。实现IP地址与机器物理地址之间的相互转换。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层实现数据包的选路和转发。网络层最核心的协议是<strong>IP协议</strong>。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接投递给目标主机，那么IP协议就为它寻找下一个合适的下一跳路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或者发送失败而丢弃。<br>网络层的另一重要协议是ICMP协议，主要用于检测网络连接。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层为两台主机上的应用提供端到端的通信，只关心通信的起始端和目的端，而不在乎数据包的中转过程。<br><img src="/images/网络层与传输层的区别
.png" alt="网络层与传输层的区别"></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层负责处理应用程序逻辑。</p>
<h3 id="socket和tcp-ip协议族的关系"><a href="#socket和tcp-ip协议族的关系" class="headerlink" title="socket和tcp/ip协议族的关系"></a>socket和tcp/ip协议族的关系</h3><p>数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能访问这些协议提供的服务。实现这些系统调用的api主要是socket。<br>由socket定义的这一组API提供以下两点功能：</p>
<ul>
<li>一是将应用程序数据从用户缓冲区中复制到TCP/IP内核发送缓冲区，以交付内核来发送数据，或者从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区，以读取数据。</li>
<li>二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精细的控制底层通信行为。比如可以通过setsockopt函数来设置IP数据报在网络上的存活时间。</li>
</ul>
<hr>
<h2 id="socket地址结构"><a href="#socket地址结构" class="headerlink" title="socket地址结构"></a>socket地址结构</h2><h3 id="socket地址api"><a href="#socket地址api" class="headerlink" title="socket地址api"></a>socket地址api</h3><h4 id="大端字节序与小端字节序"><a href="#大端字节序与小端字节序" class="headerlink" title="大端字节序与小端字节序"></a>大端字节序与小端字节序</h4><p>大端字节序的高位字节在前，低位字节在后。人类读数值的顺序。<br>小端字节序高位字节在后，低位字节在前。计算机处理速度快。<br>网络字节是大端字节序<br>小端字节序也叫主机字节序</p>
<h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr &#123;</span><br><span class="line">    sa_family_t sa_family; </span><br><span class="line">    char sa_data[14];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sa_family是地址族类型（sa_family_t)的变量。地址族类型通常与协议族类型对应。</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址族</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX本地域协议族</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP/IPv4协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP/IPv6协议族</td>
</tr>
</tbody>
</table>
<p>sa_data用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址值含义和长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>PF_UNIX</td>
<td>文件的路径名，长度可达108字节</td>
</tr>
<tr>
<td>PF_INET</td>
<td>16bit端口号和32bitIPv4地址，共6字节</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>16bit端口号，32bit流标识，128bitIPv6地址，32bit范围ID，共26字节</td>
</tr>
</tbody>
</table>
<p>由于sa_data的14字节已不能满足需求，linux新定义了一个新的通用socket地址结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_storage&#123;</span><br><span class="line">    sa_family_t sa_family;</span><br><span class="line">    unsigned long int __ss_align;</span><br><span class="line">    char __ss_padding[128-sizeof(__ss_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><p>UNIX本地域协议族专用socket地址结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line">struct sockaddr_un&#123;</span><br><span class="line">    sa_family_t sin_family; /* 地址族：AF_UNIX */</span><br><span class="line">    char sun_path[108]; /* 文件路径名 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>IPv4专用socket地址结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t sin_family; /* 地址族：AF_INET */</span><br><span class="line">    u_int16_t sin_port; /* 端口号，要用网络字节序表示 */</span><br><span class="line">    struct in_addr sin_addr; /* IPv4地址结构体 */</span><br><span class="line">&#125;;</span><br><span class="line">struct in_addr&#123;</span><br><span class="line">    u_int32_t s_addr; /* IPv4地址，要用网络字节序 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>IPv6专用socket地址结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in6&#123;</span><br><span class="line">    sa_family_t sin6_family; /* 地址族：AF_INET6 */</span><br><span class="line">    u_int16_t sin6_port; /* 端口号，要用网络字节序表示 */</span><br><span class="line">    u_int32_t sin6_flowauto; /* 流信息，应设置为0 */</span><br><span class="line">    struct in6_addr sin6_addr; /* IPv6地址结构体 */</span><br><span class="line">    u_int32_t sin6_scope_id; /* scope ID， 尚处于实验阶段 */</span><br><span class="line">&#125;;</span><br><span class="line">struct in6_addr &#123;</span><br><span class="line">    unsigned char sa_addr[16]; /* IPv6地址，要用网络字节序表示 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>所有专用socket地址类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可）</strong></p>
<hr>
<h2 id="socket-创建-命名…"><a href="#socket-创建-命名…" class="headerlink" title="socket 创建 命名…"></a>socket 创建 命名…</h2><h3 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param domain 协议族 包括PF_INET（IPv4）、PF_INET6（IPv6）或PF_UNIX</span><br><span class="line">    @param type 服务类型 包括流服务（SOCK_STREAM）、数据包服务（SOCK_DGRAM）、</span><br><span class="line">    SOCK_NONBLOCK和SOCK_CLOEXEC。后两者表示将新创建的socket设为非阻塞的，以及用</span><br><span class="line">    fork调用创建子进程时在子进程中关闭socket。</span><br><span class="line">    @param protocol 选择子协议 默认为0</span><br><span class="line">    @return socket文件描述符|-1并设置errno</span><br><span class="line">**/</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>
<h3 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h3><p>创建socket时，指定了地址族，但是并未指定使用该地址族中的哪个具体的socket地址。将一个socket与socket地址绑定称为命名。<br>在服务器端通常需要命名socket，客户端通常不需要，而是采用匿名的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket文件描述符</span><br><span class="line">    @param addr socket地址</span><br><span class="line">    @param addrlen 指定地址长度</span><br><span class="line">    @return 0 成功|-1 并设置errno。其中两种常见的errno是EACCES和EADDRINUSE</span><br><span class="line">    EACCES 被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket</span><br><span class="line">    绑定到知名服务端口（端口号为0~1023）上时，bind将返回EACCES错误</span><br><span class="line">    EADDRINUSE 被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT</span><br><span class="line">    状态的socket地址。</span><br><span class="line">**/</span><br><span class="line">int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<h3 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h3><p>socket被命名后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket文件描述符</span><br><span class="line">    @param backlog 提示内核监听队列的最大长度 监听队列的长度如果超过最大长度</span><br><span class="line">    服务器将不受理新的客户连接。客户端也将收到ECONNREFUSED</span><br><span class="line">    @return 0|-1</span><br><span class="line">**/</span><br><span class="line">int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure></p>
<h3 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h3><p>从listen监听队列中接受一个连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd 执行过listen系统调用的监听socket。</span><br><span class="line">    @param addr 用来获取被接受连接的远程socket地址</span><br><span class="line">    @param addrlen socket地址的长度</span><br><span class="line">    @return socket 该socket唯一的标识了被接收的这个连接|-1</span><br><span class="line">**/</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure></p>
<p><strong>accept只是从监听队列中取出连接，而不论连接处于何种状态，更不关心任何网络状况的变化。</strong></p>
<h3 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h3><p>主动与服务器建立连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket系统调用返回一个socket。</span><br><span class="line">    @param serv_addr 服务器监听的socket地址</span><br><span class="line">    @param addrlen 指定地址长度</span><br><span class="line">    @return 0|-1 并设置errno </span><br><span class="line">    ECONNREFUSED 目标端口不存在，连接被拒绝</span><br><span class="line">    ETIMEOUT 连接超时</span><br><span class="line">**/</span><br><span class="line">int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure></p>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param fd 待关闭的socket</span><br><span class="line">**/</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="socket-数据读写"><a href="#socket-数据读写" class="headerlink" title="socket 数据读写"></a>socket 数据读写</h2><h3 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket文件描述符</span><br><span class="line">    @param buf 读/写缓冲区的位置</span><br><span class="line">    @param len 读缓冲区的大小</span><br><span class="line">    @param flags 通常设置为0</span><br><span class="line">    @return 0 | -1</span><br><span class="line">**/</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>
<h3 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);</span><br><span class="line">ssize_t sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<h3 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);</span><br><span class="line">ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);</span><br><span class="line"></span><br><span class="line">struct msghdr&#123;</span><br><span class="line">    void* msg_name;  /* socket地址 */</span><br><span class="line">    socklen_t msg_namelen; /*socket地址的长度*/</span><br><span class="line">    struct iovec* msg_iov; /*分散的内存块*/</span><br><span class="line">    int msg_iovlen; /*分散内存块的数量*/</span><br><span class="line">    void* msg_control; /*指向辅助数据的起始位置*/</span><br><span class="line">    socklen_t msg_controllen; /*辅助数据的大小*/</span><br><span class="line">    int msg_flags; /*复制函数中的flags参数，并在调用过程中更新*/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct iovec&#123;</span><br><span class="line">    void *iov_base; /* 内存起始地址 */</span><br><span class="line">    size_t iov_len; /* 这块内存的长度 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="地址信息函数-socket选项"><a href="#地址信息函数-socket选项" class="headerlink" title="地址信息函数 socket选项"></a>地址信息函数 socket选项</h2><h3 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    获取sockfd对应的本端socket地址，并将其存储于address参数指定的内存中</span><br><span class="line">    @param sockfd socket文件描述符</span><br><span class="line">    @param address socket地址</span><br><span class="line">    @param address_len socket地址长度</span><br><span class="line">    @return -1 | 0</span><br><span class="line">**/</span><br><span class="line">int getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len);</span><br><span class="line">/**</span><br><span class="line">    获取sockfd对应的远端socket地址，其参数及返回值的含义与getsockname的参数及返回值相同</span><br><span class="line">**/</span><br><span class="line">int getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);</span><br></pre></td></tr></table></figure>
<h3 id="socket-选项"><a href="#socket-选项" class="headerlink" title="socket 选项"></a>socket 选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#inclde &lt;sys/socket.h&gt;</span><br><span class="line">/**</span><br><span class="line">    @param sockfd socket描述符</span><br><span class="line">    @param level 指定要操作协议的选项 比如 IPv4 IPv6</span><br><span class="line">    @param option_name参数则指定选项的名字</span><br><span class="line">    @param option_value 被操作选项的值</span><br><span class="line">    @param option_len 被操作选项的长度</span><br><span class="line">    @return -1 | 0</span><br><span class="line">**/</span><br><span class="line">int getsockopt(int sockfd, int level, int option_name, void* option_value,</span><br><span class="line">               socklen_t* restrict option_len);</span><br><span class="line">int setsockopt(int sockfd, int level, int option_name, const void* option_value,</span><br><span class="line">               socklen_t option_len);</span><br></pre></td></tr></table></figure>
<p>socket 常用选项<br><img src="/images/socketOption.png" alt></p>
<hr>
<h2 id="网络信息API-06"><a href="#网络信息API-06" class="headerlink" title="网络信息API 06"></a>网络信息API 06</h2><p>socket地址的两个要素, 即IP地址和端口号,都是用数值表示.</p>
<h3 id="gethostbyname-和-gethostbyaddr"><a href="#gethostbyname-和-gethostbyaddr" class="headerlink" title="gethostbyname 和 gethostbyaddr"></a>gethostbyname 和 gethostbyaddr</h3><p>gethostbyname函数根据主机名称获取主机的完整信息, gethostbyaddr函数根据IP地址获取主机的完整信息. gethostbyname函数通常先在本地的/etc/hosts配置文件中查找主机.如果没有找到, 再去访问DNS服务器.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    @param name 指定目标主机的主机名</span><br><span class="line">    @param addr 指定目标主机的ip地址    </span><br><span class="line">    @param len 指定addr所指ip地址的长度</span><br><span class="line">    @param type 指定addr所指IP地址的类型, 其合法取值包括AF_INET和AF_INET6</span><br><span class="line">**/</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct hostent* gethostbyname(const char* name);</span><br><span class="line">struct hostent* gethostbyname(const void* addr, size_t len, int type);</span><br><span class="line"></span><br><span class="line">这两个函数返回的都是hostent结构体类型的指针, hostent结构体的定义如下</span><br><span class="line"></span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct hostent &#123;</span><br><span class="line">    char* h_name; //主机名</span><br><span class="line">    char** h_aliases; // 主机别名列表</span><br><span class="line">    int h_addrtype; // 地址类型</span><br><span class="line">    int h_length; //地址长度</span><br><span class="line">    char** h_addr_list; // 按网络字节序列出的主机IP地址列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="getservbyname-和-getservbyport"><a href="#getservbyname-和-getservbyport" class="headerlink" title="getservbyname 和 getservbyport"></a>getservbyname 和 getservbyport</h3><p>getservbyname函数根据名称获取某个服务的完整信息, getservbyport函数根据端口号获取某个服务的完整信息.它们实际上都是通过读取/etcservices文件来获取服务的信息的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    @param name 指定目标服务的名字</span><br><span class="line">    @param port 指定目标服务对应的端口号</span><br><span class="line">    @param proto 指定服务类型 给它传递tcp表示流服务, 给它传递udp表示流服务, 给它传递NULL则表示所有获取类型的服务</span><br><span class="line">**/</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct servent* getservbyname(const char *name, const char * proto);</span><br><span class="line">struct servent* getservbyport(int port, const char * proto);</span><br><span class="line"></span><br><span class="line">两个函数返回的都是servent结构体类型的指针, 结构servent的定义如下</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct servent &#123;</span><br><span class="line">    char* s_name; //服务名称</span><br><span class="line">    char** s_aliases; // 服务的别名列表</span><br><span class="line">    int s_port; // 端口号</span><br><span class="line">    char* s_proto; // 服务类型, 通常是tcp或udp</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过主机名和服务名访问目标服务器上的daytime服务, 以获取该机器的系统时间.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    assert(argc == 2);</span><br><span class="line">    char *host = argv[1];</span><br><span class="line">    /* 获取主机地址信息 */</span><br><span class="line">    struct hostent* hostinfo = gethostbyname(host);</span><br><span class="line">    assert(hostinfo);</span><br><span class="line">    /* 获取daytime服务信息 */</span><br><span class="line">    struct servent* servinfo = getservbyname(&quot;daytime&quot;, &quot;tcp&quot;);</span><br><span class="line">    assert(servinfo);</span><br><span class="line">    printf(&quot;daytime port is %d\n&quot;, ntohs(servinfo-&gt;s_port));</span><br><span class="line">    struct sockaddr_in address;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = servinfo-&gt;s_port;</span><br><span class="line">    /* 注意下面的代码, 因为h_addr_list本身是使用网络字节序的地址列表, 所以使用其中的IP地址时, 无须对目标IP转换字节序.</span><br><span class="line">    address.sin_addr = *(struct in_addr*) *hostinfo-&gt;h_addr_list;</span><br><span class="line">    int sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    int result = connect(sockfd, (struct sockaddr*)&amp;address, sizeof(address));</span><br><span class="line">    assert(result != -1);</span><br><span class="line"></span><br><span class="line">    char buffer[128];</span><br><span class="line">    result = read(sockfd, buffer, sizeof(buffer));</span><br><span class="line">    assert(result &gt; 0);</span><br><span class="line">    buffer[result] = &apos;\0&apos;;</span><br><span class="line">    printf(&quot;the daytime is: %s&quot;, buffer);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">需要支出的是, 上面讨论的4个函数都是不可重入的, 即非线程安全的. 不过netdb.h头文件给出了它们的可重入版本.正如linux下所有  其他函数的可重入版本的命名规则那样, 这些函数的函数名是在原函数名尾部加上_r(re-entrantj)</span><br></pre></td></tr></table></figure></p>
<h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p>getaddrinfo 函数既能通过主机名获取IP地址(内部使用的是gethostbyname函数),也能通过服务名获取端口号(内部使用的是getservbyname函数).它是否可重入取决于内部调用的gethostbyname和getservbyname函数是否是他们的可重入版本. 该函数的定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    @param hostname 可以接受主机名,也可以接收字符串表示的IP地址(IPv4采用点分十进制字符串, IPv6采用16进制字符串)</span><br><span class="line">    @param service 参数可以接受服务名也可以接受字符串表示的十进制端口号.hints参数是应用程序给getaddrinfo的一个提示,以对getaddrinfo的输出进行更精确的控制. hints参数可以被设置为NULL, 表示允许getaddrinfo反馈任何可用的结果.result参数指向一个链表, 该链表用于存储getaddrinfo反馈的结果.</span><br><span class="line">    getaddrinfo反馈的每一条结果都是addrinfo结构体类型的对象,结构体addrinfo的定义如下:</span><br><span class="line">    struct addrinfo &#123;</span><br><span class="line">        int ai_flags; //j</span><br><span class="line">        int ai_family //地址族</span><br><span class="line">        int ai_socktype; // 服务类型: SOCK_STREAM 或 SOCK_DGRAMj</span><br><span class="line">        int ai_protocol; // </span><br><span class="line">        socklen_t ai_addrlen; //socket地址 ai_addr的长度</span><br><span class="line">        char* ai_canonname;  //主机的别名</span><br><span class="line">        struct sockaddr* ai_addr; //指向socket地址</span><br><span class="line">        struct addrinfo* ai_next;  //指向下一个sockinfo结构的对象</span><br><span class="line">    &#125;;</span><br><span class="line">**/</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">int getaddrinfo(const char* hostname, const char* service, const struct addrinfo* hints, struct addrinfo** result);</span><br></pre></td></tr></table></figure></p>
<h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p>getnameinfo函数通过socket地址获取以字符串表示的主机名(内部使用的是gethostbyaddr)和服务名(内部使用getservbyport函数).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">int getnameinfo(const struct sockaddr* sockaddr, socklen_t addrlen, char* host, socklen_t hostlen, char* serv, socklen_t servlen, int flags);</span><br><span class="line">getnameinfo将返回的主机名存储在host参数指向的缓存中, 将服务名存储在serv参数指向的缓存中, hostlen和servlen参数分别指定这两块缓存的长度.</span><br><span class="line">flags参数控制getnameinfo的行为.</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="高级I-O函数"><a href="#高级I-O函数" class="headerlink" title="高级I/O函数"></a>高级I/O函数</h2><h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p>pipe函数用于创建管道, 以实现进程间通信.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pipe函数的参数是一个包含两个int型整数的数组指针. 该函数成功时返回0, 并将一对打开的文件描述符值填入其参数指向的数组. 如果失败, 则返回-1并设置errno.</span><br><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/07/写给大家看的设计书/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/07/写给大家看的设计书/" itemprop="url">写给大家看的设计书</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-07T18:12:13+08:00">
                2019-04-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/06/心流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/06/心流/" itemprop="url">心流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-06T11:16:08+08:00">
                2019-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/改善思维方式/" itemprop="url" rel="index">
                    <span itemprop="name">改善思维方式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="做自己的主人"><a href="#做自己的主人" class="headerlink" title="做自己的主人"></a>做自己的主人</h2><p>个人社会化是必然的；社会化的真谛在于使个人依赖社会的控制，并对赏罚有既定的反应；社会化的最高境界就是使每个人都完全认同社会秩序，根本不想触犯任何规则。<br>人的每个弱点-从性欲到侵略，从寻求安全感到接受改变-几乎都成为政客、教会、企业及广告届控制社会的手段。<br>寻求快乐是基因为物种延续而设计的一种即使反射。跟随基因的反应，享受自然的乐趣，并没有什么不好，但我们应该认清实现真相，在必要的时候，按照自己的优先顺序，做自己的主人。</p>
<h2 id="放任的争议"><a href="#放任的争议" class="headerlink" title="放任的争议"></a>放任的争议</h2><p>再复杂的社会中，有许多强势的团体执行者社会化的工作，有时他们的目标看起来相互矛盾。一方面，学校、教堂、银行等官方机构拼命把我们塑造成拼命工作与储蓄的负责任公民；另一方面，商人、广告商、厂商却不断哄骗我们把我们辛辛苦苦赚的钱悉数购买让他们获利的产品。此外还有赌徒、皮条客、毒贩组成的地下组织，提供禁忌的快乐，他们完全与官方那一套相呼应：只要付钱，就提供放荡的快乐。尽管透露出来的信息完全不同，但结果基本上是一样的：剥夺我们的精力以逞其私欲，是我们沦为社会制度的附庸。</p>
<h2 id="不以社会赏罚为念"><a href="#不以社会赏罚为念" class="headerlink" title="不以社会赏罚为念"></a>不以社会赏罚为念</h2><p>在社会制约下解放自我，最重要的步骤是时时刻刻发掘每一件事情中的回馈。如果我们学会在不断向前推进的体验中找到快乐与意义，社会制约的重担就会从肩上自动滑落。当奖赏不再受外界力量管制时，权利就回到了个人手中。再也不必为追逐不到的目标而孜孜以求，或是在每个无聊的一天告终时，盼望明天会更好；再也不必为遥不可及的奖励受尽折磨，而可以真正开始充实人生。</p>
<h2 id="控制意识，改善体验"><a href="#控制意识，改善体验" class="headerlink" title="控制意识，改善体验"></a>控制意识，改善体验</h2><h3 id="意识的内涵"><a href="#意识的内涵" class="headerlink" title="意识的内涵"></a>意识的内涵</h3><p>构成意识的事件-我们看见、感觉、想到、渴望的事物-就是我们所能操纵的资讯，因此我们也可以把意识视为经过刻意排列组合的资讯。</p>
<h3 id="意识的极限"><a href="#意识的极限" class="headerlink" title="意识的极限"></a>意识的极限</h3><p>意识有一定局限。因此准许哪些资讯进入我们的意识就显得格外重要。事实上，这就决定了生活的内涵与品质。</p>
<h3 id="注意力：无价的资源"><a href="#注意力：无价的资源" class="headerlink" title="注意力：无价的资源"></a>注意力：无价的资源</h3><p>控制意识最明显的指标就是能随心所欲的集中注意力，不因任何事情而分心。若能做到这一点，就能在日常生活中找到乐趣。</p>
<h3 id="注意力的探照灯"><a href="#注意力的探照灯" class="headerlink" title="注意力的探照灯"></a>注意力的探照灯</h3><p>应用注意力的方式足以决定人生的外观和内涵，塑造可能全然相反的现实。我们用以描述人格特征的字眼-诸如外向、成就不凡、偏执狂，其实指的就是一个人构建注意力的模式。</p>
<h3 id="注意力与自我的相互塑造"><a href="#注意力与自我的相互塑造" class="headerlink" title="注意力与自我的相互塑造"></a>注意力与自我的相互塑造</h3><p>体验（比如成为程序员、运动员，体验是不一样的。）取决于我们运用精神能量的方式，而这有牵扯到目标和意图所有过程乃是靠自我衔接的。我们若想在任何方面有所进步，都逃不脱这些步骤。外在因素当然也有助于改善人生，但也必须在意识中取得一席之地，以积极的方式与自我建立练习，才能对生活品质产生影响。</p>
<h3 id="内在失序"><a href="#内在失序" class="headerlink" title="内在失序"></a>内在失序</h3><p>内在失序-也就是资讯跟既定的意图发生冲突，或是我们分心，无法为实现意图而努力-是对意识极为不利的影响力。我们曾为这种状况取了各式各样的名称，如痛苦、恐惧、愤怒、焦虑和嫉妒等。所有失序的现象都强迫注意力转移到错误的方向，不再发挥预期的功能，精神力量也窒息了。</p>
<h4 id="胡里欧的破轮胎"><a href="#胡里欧的破轮胎" class="headerlink" title="胡里欧的破轮胎"></a>胡里欧的破轮胎</h4><p>从胡里欧的例子可以看出，自我的内在秩序收到打扰时，会有什么后果。基本的模式是固定的：与个人目标相冲突的资讯侵入意识后，视目标的重要性与威胁的大小而定，某些程度的注意力必须腾出手来消除危机，用于处理其他事物的注意力就相对减少了。对于胡里欧而言，保住工作是非常重要的目标，一旦失业，所有其他目标就要跟着泡汤，因此，工作是他维系自我内在秩序的最重要一环。漏气的破轮胎危及他的工作，因而消耗了他大部分的精神能量。</p>
<h4 id="撞球理论"><a href="#撞球理论" class="headerlink" title="撞球理论"></a>撞球理论</h4><p>我们接受的每一条资讯，都要经过自我的评判。它对我们的目标是威胁、支持，还是中立？股票下跌的消息往往令银行家担忧，但对政治异议分子却可能是振奋人心的好消息。一条新资讯可能会使我们付出所有心力应付威胁，造成意识的失序；但他也有可能强化我们的目标，激发出更多的精神能量。</p>
<h3 id="意识的井然有序"><a href="#意识的井然有序" class="headerlink" title="意识的井然有序"></a>意识的井然有序</h3><h4 id="流动的最有体验"><a href="#流动的最有体验" class="headerlink" title="流动的最有体验"></a>流动的最有体验</h4><p>最优体验出现时，一个人可以投入全部的注意力，以求实现目标；没有失序现象需要整顿，自我也没有收到任何威胁，因此不需要分心防卫。拥有最有体验就能培养一个更坚强、更自信的自我，能够用更多的精神力量，专注于自己选择的目标。</p>
<h3 id="自我的成长"><a href="#自我的成长" class="headerlink" title="自我的成长"></a>自我的成长</h3><p>心流体验会使自我变得比过去更复杂，而这可以说是一种自我成长。复杂性是两种广泛的心理过程造成的-“独特化”与“整合”。其中，独特化是把自己与他人区分开来，朝独一无二的方向发展；整合则恰好相反，是接着超越自我的观念和实体，与他人联结。而复杂的自我便能成功地融合这两种乍看矛盾的过程。</p>
<hr>
<h2 id="心流的构成要素"><a href="#心流的构成要素" class="headerlink" title="心流的构成要素"></a>心流的构成要素</h2><p>改善生活品质的主要策略有两种：一是使外在条件符合我们的目标；而是改变我们体验外在条件的方式，使他与我们的目标相契合。</p>
<h3 id="幸福的假象"><a href="#幸福的假象" class="headerlink" title="幸福的假象"></a>幸福的假象</h3><p>有钱不一定幸福，幸福一定要有钱。</p>
<h3 id="享乐与乐趣"><a href="#享乐与乐趣" class="headerlink" title="享乐与乐趣"></a>享乐与乐趣</h3><p>享乐是高水准生活的重要一环，但享乐本身并不能带来幸福。睡眠、休息、食物与性，都属于恢复“均衡的体验”，在肉体需要引起精神熵后，重整意识的秩序。它们并不能带动心灵的成长，也不能增加自我的复杂性。换言之，享乐虽有助于维持意识的秩序，却无法在意识中创造新秩序。</p>
<h4 id="享乐转瞬即逝，乐趣回味无穷"><a href="#享乐转瞬即逝，乐趣回味无穷" class="headerlink" title="享乐转瞬即逝，乐趣回味无穷"></a>享乐转瞬即逝，乐趣回味无穷</h4><p>乐趣具有向前发展的特性，并蕴涵新鲜感和成就感。在网球赛中险胜，通过考验证明自己的能力；阅读一本书，发掘新观点；在谈话中发表过去甚至不自知的观点——这都是乐趣横生的事。谈成一笔竞争激烈的生意，或做好任何一份工作，乐趣自在其中。这些事在进行的过程中，谈不上什么享乐，但事后回想起来，我们会情不自禁地说：“真有意思！”而且，盼望一切能重演。经历过有乐趣的事，我们就感觉自己有了改变，自我有了成长；在某些方面，这次体验已使我们变得更复杂、更丰富。</p>
<h3 id="构成心流体验的要素"><a href="#构成心流体验的要素" class="headerlink" title="构成心流体验的要素"></a>构成心流体验的要素</h3><h4 id="具挑战性的活动"><a href="#具挑战性的活动" class="headerlink" title="具挑战性的活动"></a>具挑战性的活动</h4><ul>
<li>敌人也是我们的好帮手</li>
<li>化无趣为乐趣</li>
</ul>
<h3 id="挑战与技巧的黄金比例"><a href="#挑战与技巧的黄金比例" class="headerlink" title="挑战与技巧的黄金比例"></a>挑战与技巧的黄金比例</h3><h4 id="知行合一"><a href="#知行合一" class="headerlink" title="知行合一"></a>知行合一</h4><p>当情况要求一个人运用相关技巧来应付挑战时，这个人的注意力就会完全投入，不剩一丝精神能量处理与挑战无关的资讯，而完全集中于相关的刺激上。。最优体验最普遍、最清晰的特质就会在此时呈现：当事人全神贯注，一切行动都不假思索，几乎完全自动自发；他们的知觉甚至泯灭，人与行动完全合一。</p>
<h4 id="明确目标和即时回馈"><a href="#明确目标和即时回馈" class="headerlink" title="明确目标和即时回馈"></a>明确目标和即时回馈</h4><h4 id="目标主导回馈"><a href="#目标主导回馈" class="headerlink" title="目标主导回馈"></a>目标主导回馈</h4><p>学者确立目标，辨认与评估回馈，否则无法从任何活动中发觉乐趣。</p>
<h4 id="回馈因人而异"><a href="#回馈因人而异" class="headerlink" title="回馈因人而异"></a>回馈因人而异</h4><p>回馈只要和我们用精神能量追求的目标有合理的关联，就能产生乐趣。</p>
<h4 id="全神贯注"><a href="#全神贯注" class="headerlink" title="全神贯注"></a>全神贯注</h4><p>在平凡的日常生活中，我们受任意闯进意识的思想和忧虑驱使，由于大多数工作和普通的家庭生活，要求都不及心流体验那么高，也不需要全神贯注，因此悬念和 焦虑才有了乘虚而入的机会。这就导致在一般状态下，心灵常会受到精神熵的突如其来的干扰，精神能量不能流转自如。也正因为如此，心流才能提升体验的品质；这类需要全心投入的活动，要求分明，秩序井然，根本不容外来因素介入与破坏。</p>
<h4 id="掌控自如"><a href="#掌控自如" class="headerlink" title="掌控自如"></a>掌控自如</h4><p>心流中有高度控制感。</p>
<h4 id="危险是心流的契机"><a href="#危险是心流的契机" class="headerlink" title="危险是心流的契机"></a>危险是心流的契机</h4><p>真正给人带来乐趣的不是控制本身，而是在艰难状况下行驶控制权的感觉。除非放弃生活常规所提供的保护，否则不可能体会到控制的感觉。只有在个人力量能左右结果时，才能确知自己拥有控制权。</p>
<h4 id="心流会上瘾"><a href="#心流会上瘾" class="headerlink" title="心流会上瘾"></a>心流会上瘾</h4><h4 id="浑然忘我"><a href="#浑然忘我" class="headerlink" title="浑然忘我"></a>浑然忘我</h4><h4 id="与大我合一"><a href="#与大我合一" class="headerlink" title="与大我合一"></a>与大我合一</h4><p>自我的执着很耗费精神能量，因为它使我们在日常生活中，经常觉得备受威胁。一受到威胁，我们就必须用知觉检视自我，以了解威胁是否真正存在，应该如何应付。比方说，在街上漫步时，我发现有人回头笑嘻嘻的向我张望，正常人的反应是开始担心：“有什么不对吗？我是否显得很可笑？我走路的样子很奇怪，或是脸上有污点？”，每天好几百次我们都得到类似的提醒，察觉自己浑身上下都是缺点。这种事情没发生一次，精神能量就为重建意识秩序而消耗一次。<br>暂时忘我，似乎是件很愉快的事，不再一心一意的想着自己，才有机会扩充对自我的概念。消除自我意思可以带来自我超越，产生一种自我疆界向外扩展的感觉。这种感觉并非幻想，而是跟某种“大我”亲密接触的实质体验；这种互动关系使我们跟那些通常相当遥远的实体，产生极为难得的一体验。在漫长的守夜中，孤单的水手开始觉得船是自我的延伸，循同样的节奏，朝同样的目标前进。小提琴家在努力创造的乐声中载沉载浮，自觉是“和谐天籁”的一部分。登山者全神贯注于岩块上😊的凹凸处，找寻落足点，在手指与岩石，脆弱的人体与石块、天、风的组合中，发展出一种有如血缘般的亲密关系。</p>
<h4 id="超越自我"><a href="#超越自我" class="headerlink" title="超越自我"></a>超越自我</h4><p>在心流中失去自我的感觉，以及之后以更坚强的面貌再度出现，两者之间有一种非常重要、乍看却仿佛矛盾的关系。偶尔放弃自我意识，对建立更强大的自我意识，似乎有其必要性。道理很简单：在心流中，一个人面临做出最佳表现、须不断改善技巧的挑战，在这期间，他没有机会反省这么做对自我有什么意义-如果自我意识能即使恢复，这次体验就不可能太深刻。要等事后，一切活动都告一段落时，自我意识逐渐复苏，而这时的自我已经和经历心流前的自我不一样了：新技巧和新成就使得他变得丰更富。</p>
<h3 id="目标不假外求"><a href="#目标不假外求" class="headerlink" title="目标不假外求"></a>目标不假外求</h3><p>最有体验的一大特色在于它本身就是目标。<strong>自成目标</strong>指的是做一件事不追求未来的报酬，做这件事本身就是最大的回馈。我们所做的事，大多既不是纯粹的自成目标，也不是纯粹的外求目标，而是两者的综合。</p>
<h4 id="从被迫的体验中顿悟"><a href="#从被迫的体验中顿悟" class="headerlink" title="从被迫的体验中顿悟"></a>从被迫的体验中顿悟</h4><h4 id="没有绝对的好"><a href="#没有绝对的好" class="headerlink" title="没有绝对的好"></a>没有绝对的好</h4><p>心流体验跟世间所有的事一样，不可能绝对的好。它的好在于它具有使人生更丰富、更紧凑、更有意义的潜力，在于它能加强自我的力量与复杂性。但心流的结果是好是坏，必须应用于较广泛的社会标准加以讨论和评估。举凡人类的活动，不论是科学、宗教、还是政治，都是如此。一种特定的宗教信仰或许对一个人或一个团队有益，而对其他人或团体而言却是横加压迫。基督教有助于整合罗马帝国治下分奔离析的各民族，却瓦解了它之后接触到的弱势文化。</p>
<hr>
<h2 id="如何在日常生活中寻找心流"><a href="#如何在日常生活中寻找心流" class="headerlink" title="如何在日常生活中寻找心流"></a>如何在日常生活中寻找心流</h2><p>为什么游戏能带来乐趣，而我们日常所做的事-例如工作或坐在家里发呆，却令人觉得无趣呢？为什么有人即使在纳粹集中营ra也能满心欢喜，有人到了度假胜地旅游却感到单调乏味呢？先找到这些问题的答案，就比较容易了解提升自身体验、改善生活品质的方法。本章就要讨论、比较可能产生最优体验的活动，以及有助于进入心流的性格特征。</p>
<h3 id="心流活动"><a href="#心流活动" class="headerlink" title="心流活动"></a>心流活动</h3><p>所有心流活动，不论涉及竞争、投机还是其他形式的体验，都有一个共同点：它带来一种新发现、一种创造感，把当事人带入新的现实。它促使一个人有更好的表现，使意识到达过去连做梦也想不到的境界。简单的说，它把自我变得更加复杂，自我因而成长，这就是心流活动的关键。</p>
<h3 id="心流与社会文化"><a href="#心流与社会文化" class="headerlink" title="心流与社会文化"></a>心流与社会文化</h3><h4 id="文化相对论"><a href="#文化相对论" class="headerlink" title="文化相对论"></a>文化相对论</h4><p>任何跨文化的价值评判，都必然迫使所评判的文化暴露于另一套全然陌生的价值标准下，因此根本无从比较。</p>
<h4 id="文化无所不包"><a href="#文化无所不包" class="headerlink" title="文化无所不包"></a>文化无所不包</h4><p>文化是对混沌的一种防御。文化必须把很多细枝末节的目标和信念排除，因而也局限了发展的可能性。唯有把注意力限制在一组特定的目标与手段上，才能在自行创造的疆域里，进行毫不费力的行动。文化促成心流。</p>
<h4 id="闲暇不等于乐趣"><a href="#闲暇不等于乐趣" class="headerlink" title="闲暇不等于乐趣"></a>闲暇不等于乐趣</h4><p>虽然很多人有充裕的闲暇，可以从事多种休闲活动，但他们并没有因此而经常体验到心流。潜力不见得都能实现，质与量也无法互换。工作时全神贯注，挑战与技巧完全匹配，且有掌控与满足感，体验心流的机会是看电视的4倍。</p>
<h3 id="自得其乐的性格"><a href="#自得其乐的性格" class="headerlink" title="自得其乐的性格"></a>自得其乐的性格</h3><h4 id="享受快乐的心理障碍"><a href="#享受快乐的心理障碍" class="headerlink" title="享受快乐的心理障碍"></a>享受快乐的心理障碍</h4><p><strong>过分的自我意识</strong>是一种不太严重的心流障碍。一个人若时时都在担心别人对自己的看法，害怕给人留下不好的印象，或做出不妥当的事情，就注定与乐趣无缘。过于以自我为中心的人也一样，这种人通常并不是自觉，而是对所有资讯的判断只以它是否有助于实现自己的愿望为标准。“有两个用于社会病理学的名词，在描述使心流难以产生的状况时也适用——“失范”（anomie）与“疏离”（alienation）。“失范”原由法国社会学家迪尔凯姆提出，特指行为规范被扰乱的社会状况。当什么可以或不可以做已混淆不清时，人的行为举止就变得反复无常、没有意义，靠社会规则建立意识秩序的人就会感到焦虑。失范的现象会在经济崩溃或本土文化遭受外来文化摧毁时出现；当经济急速繁荣、注重勤俭的旧的价值观被推翻时，也可能发生。</p>
<h3 id="在困顿中体验快乐"><a href="#在困顿中体验快乐" class="headerlink" title="在困顿中体验快乐"></a>在困顿中体验快乐</h3><p>“自得其乐的性格”最大特征就是，他们能在一般人无法忍受的情况中找到乐趣。不论是在南极迷了路还是被关在牢房里，总有人能把自己的困境改善得还能过得去，甚至成为一场充满乐趣的奋斗；换成其他人，很可能就向艰难困顿俯首称臣了。在钻研了很多人在困难中的自述后，罗根的结论是：他们都因为能把悲惨的客观条件转变成可以控制的主观体验，才得以生存下去；他们正是依心流的蓝图行事。首先，他们密切关注环境中的细节，并从中发掘可以跟他们有限的能力搭配的行动机会；然后制订出一个现实状况所能容许的目标，通过所得到的回馈，密切注意一切进展。只要一实现目标，他们就提高赌注，为自己部署更复杂的挑战。</p>
<h4 id="自力救济找乐趣"><a href="#自力救济找乐趣" class="headerlink" title="自力救济找乐趣"></a>自力救济找乐趣</h4><p>罗根在研究多位劫后余生者的记录后，提供了一个答案。他的研究对象都提到在极度艰苦困顿的情况下力量的来源，罗根认为，幸存者最重要的共同特征就是“一种自我意识不到的个人主义”，或者可说是有方向感、充满自信的目标。拥有这种特质的人，无论处于什么情况下都会全力以赴，而且不会把自己的利益放在第一位。因为这些人的动机在于行动本身，所以不易受到外来威胁的干扰。他们有足够的精神能量，可对周遭环境做客观分析与观察，也比较可能从中发现新的行动契机。如果要为自得其乐的性格选出一个最主要的特征，应该就是这一点了。只想保护自己的自恋者，在面临外在环境的威胁时就会崩溃，接踵而来的惊慌失措，使他们无法把该做的事情做好，因为他们的注意力转向内心，专注于恢复意识的秩序，根本没有余力应付外在的现实。</p>
<hr>
<h2 id="感官之乐"><a href="#感官之乐" class="headerlink" title="感官之乐"></a>感官之乐</h2><ul>
<li>步行</li>
<li>运动</li>
<li>瑜伽</li>
<li>听，用心听</li>
<li>品味吃</li>
</ul>
<p>压抑并不是道德修养的方法。基于恐惧而勉强压抑欲望，人生就会变得暗淡无光。这种人会变得刻板、自卫，自我也停止成长。唯有自发的遵守某些纪律，人生才有乐趣，而仍然保持理智。一个人若能学会发乎本心，控制本能的欲求，就能享受乐趣而不上瘾，不至于成为欲望的奴隶。</p>
<hr>
<h2 id="思维之乐"><a href="#思维之乐" class="headerlink" title="思维之乐"></a>思维之乐</h2><h3 id="身体与心灵相辅相成"><a href="#身体与心灵相辅相成" class="headerlink" title="身体与心灵相辅相成"></a>身体与心灵相辅相成</h3><p>我们很少注意到自己对心灵的控制力竟是那么薄弱，因为习惯已奠定了精神能量的轨迹，仿佛思想会自动衔接，毫无漏洞。一夜安睡，早晨闹钟一响，意识就恢复清醒，接着就到浴室去刷牙。文化分派给我们的社会角色负责塑造我们的心灵，我们通常也任由这套既定规则操纵，直到晚间又盖就寝，失去意识为止。但在独处、无须集中注意力时，心灵没有秩序的原貌就会显现。它无所事事，如脱缰野马，往往停留在令人痛苦或困扰的思绪上。除非一个人知道如何整顿自己的思想，否则注意力一定会被当时最棘手的事件所吸引：它会集中于某种事实或想象的痛苦，最近的不快或长期的挫折中。精神熵是意识的常态-一种既没有任何作用，也不能带来乐趣的状态。<br>为了避免进入这种状态，一般人当然急于用任何能到手的资讯填满心灵，只要能转移注意力，不要沉溺在消极的情绪之中就好。这也说明了为何人们花大量时间看电视，尽管这么做毫无乐趣可言。比起其他的刺激-阅读、与别人交谈、发展嗜好等，电视最能提供持续且易得的资讯，帮助观众整理注意力，而所需的精神能量又非常少。</p>
<h3 id="记忆：科学之母"><a href="#记忆：科学之母" class="headerlink" title="记忆：科学之母"></a>记忆：科学之母</h3><h4 id="记忆有用论"><a href="#记忆有用论" class="headerlink" title="记忆有用论"></a>记忆有用论</h4><p>一个人倘若没什么值得记忆的事，人生就会变得贫乏。20世纪初的教育改革家就完全忽略了这回事，他们研究证明，“机械性的背诵”不是存储与搜集资讯的有效方法。在他们的努力下，背诵式学习被排除在学校之外。</p>
<h4 id="思考带来愉悦"><a href="#思考带来愉悦" class="headerlink" title="思考带来愉悦"></a>思考带来愉悦</h4><h3 id="思维游戏"><a href="#思维游戏" class="headerlink" title="思维游戏"></a>思维游戏</h3><p>塑造心灵活动所需的工具不仅仅是记忆。记住一些事实，若不能把它们归纳成某种模式，建构它们之间的相似性与规律性，仍然没有用。最简单的秩序体系就是为每个事物取名字，我们发明的字眼，便把独立事件纳入宇宙通用的类别。文字的力量无比广大。</p>
<h4 id="思考带来愉悦-1"><a href="#思考带来愉悦-1" class="headerlink" title="思考带来愉悦"></a>思考带来愉悦</h4><p>哲学与科学的兴盛与发展，只因思考带给人愉悦。如果思想家并不能从逻辑或数字创造的意识秩序中找到乐趣，我们现在就不会有数学或物理等学科了。<br>伟大的思想家着重的是思考的乐趣，物质报酬反而在其次。古希腊哲学宗师德谟克利特深受同胞敬重，但他们并不了解他。看见他一连好几天坐着思考，动也不动，他们认为他举止反常，可能是病了，就请请名医希波克拉底前来诊治。希波克拉底不但医术高明，也是一位智者，他跟德谟克利特大谈人生的荒谬，随后就向市民保证，他们的哲学家唯一的毛病就是头脑太清醒了。他没有发疯-他其实只是迷失在思考的心流中。<br>德谟克利特：“思考美的事物或新观念，真有如天神”；“力量与金钱不能带来幸福，幸福存在于正确与多样性之中”；“发现一个真理，胜于拥有整个波斯王国”；认为快乐与自信能使人心无恐惧，因此是最高的善“。</p>
<h3 id="文字的游戏"><a href="#文字的游戏" class="headerlink" title="文字的游戏"></a>文字的游戏</h3><h4 id="谈话的艺术"><a href="#谈话的艺术" class="headerlink" title="谈话的艺术"></a>谈话的艺术</h4><p>口才能使人际关系交往更觉充实，也是一种人人学得会的技巧。</p>
<h4 id="开启一扇心灵的窗"><a href="#开启一扇心灵的窗" class="headerlink" title="开启一扇心灵的窗"></a>开启一扇心灵的窗</h4><p>只要付出一点儿努力与耐心，每个人都能学会把个人的体验整理成诗。把写诗的技巧运用自如，提升生活品质，提升自信。</p>
<h4 id="创造一个文字世界"><a href="#创造一个文字世界" class="headerlink" title="创造一个文字世界"></a>创造一个文字世界</h4><p>若非通过书写时思想缓慢而有机的成长过程，观念根本不可能出现。<br>为写作而写作，不能说是浪费时间，最重要的是，它提供给心灵一种表达途径，让一个人用方便记忆的方式，记录事件与感受，以便在日后重温。它也是一种分析与了解体验的方法，一种建立体验秩序的自我沟通。<br>近年来有很多人指出，诗人与剧作家往往是一群严重沮丧或情绪失调的人，或许他们投身写作这一行，就是因为他们的意识受精神熵干扰的程度远超一般人；写作是在情愫紊乱中塑造秩序的一种治疗法。作家体验心流的唯一方法，很可能就是创造一个可以全心投入的文字世界，把现实的烦恼从心灵中抹去。写作跟其他心流活动一样，可能会上瘾，也可能构成危险：它强迫作者投入一个有限的体验范畴，抹杀了采用其它方式处理事件的可能性。</p>
<h3 id="挖掘历史宝藏"><a href="#挖掘历史宝藏" class="headerlink" title="挖掘历史宝藏"></a>挖掘历史宝藏</h3><p>在某种意义上，每个人都是他个人生命的历史学家。童年记忆的情绪力量，对于我们长大会成为什么样的人、心灵如何运作，具有举足轻重的影响力。心理分析大致上就是帮助病人整理错乱歪曲的童年历史。从往昔中寻找意义的工作，到晚年在此变得很重要。心理学家埃里克森认为，人生周期在最后阶段最求“整合”，也就是把一生中完成的与未完成的事，整理成一则有意义而专属于自己的故事。卡莱尔写道：“历史就是不计其数的个人传记的精髓”。</p>
<h3 id="科学的乐趣"><a href="#科学的乐趣" class="headerlink" title="科学的乐趣"></a>科学的乐趣</h3><p>诺贝尔生物学奖获得者利根川进，则被妻子描述成一个“特立独行的人”。他喜欢摔跤，因为这种运动胜败全在于个人努力，不需要团队合作，跟他的工作很类似。显然，先进的研究设备与庞大的研究队伍的重要性都被过度夸大，科学突破仍依赖个人心灵的才智。</p>
<h4 id="意外的科学成就"><a href="#意外的科学成就" class="headerlink" title="意外的科学成就"></a>意外的科学成就</h4><p>天文学家哥白尼在波兰的劳恩堡教堂任牧师时，完成了星球运动理论。天文学对他的神职事业毫无帮助，他大半生获得的主要报酬是美学上的；他提出的模式有简单之美，远超过托勒密那套烦琐复杂的旧模式。伽利略原本学医，投身越来越危险的实验，无非是因为诸如固体重心位置的推算使他觉得乐在其中。牛顿在取得学士学位后不久，就完成了他的主要发现，因为1665年他自剑桥大学毕业时，正值瘟疫盛行，学校被迫关闭，牛顿下乡暂避，过了两年无聊的生活，只好专心研究万有引力的理论打发时间。<br>拉瓦锡被公认为“现代化学之父”。法国大革命前，他在税务机关工作，参与农业改革和社会计划，但那些已成为化学经典的巧妙实验才是他的最爱。伽伐尼从肌肉与神经如何导电的基本实验中悟出电池的原理，他一辈子行医，至死方已。孟德尔从事神职，他为遗传学奠定基础的实验，其实是源于对园艺的爱好。迈克尔逊是第一位获得诺贝尔奖的美国科学“家，在他去世前不久，有人问他为什么花那么多时间测量光速，他答道：“因为太好玩了。”还有，我们别忘了，爱因斯坦最重要的论文是他在瑞士专利局当小职员时完成的。以上不过是从众多伟大的科学家当中信手拈来的几个例子，他们并不因为自己不是专业人才，没有大量经费撑腰，就让思路受阻，他们只是做自己喜欢做的事情罢了。<br>今天的情况真的大不相同了吗？一个没有博士学位、不在大的研究中心工作的人，真的就没有机会促成科学的进步了吗？或许这不过是所有成功机构都有意无意助长的神话，这些问题很难回答，一部分也因为科学的定义把持在那些从垄断中得到最大利益的机构手中。<br><strong>如果用心流而不用成功、名望来评估科学的价值，它对生活品质的贡献之大，可说超乎我们的想象。</strong></p>
<h3 id="哲学的乐趣"><a href="#哲学的乐趣" class="headerlink" title="哲学的乐趣"></a>哲学的乐趣</h3><p>对于哲学的偏爱很明显时，即使业余者也可以进入专精的门槛。对真实的基本特性感兴趣的人，可能会选择“本体论”，阅读沃尔夫、康德、胡塞尔与海德格尔等人的学说。沉浸于是非之辩的人，会挑中“伦理学”，研究亚里士多德、托马斯·阿奎那、斯宾诺莎与尼采。追求美的人可以比较鲍姆嘉通、克罗齐、桑塔耶纳和柯林伍德的美学理论。</p>
<h4 id="业余者和爱好者"><a href="#业余者和爱好者" class="headerlink" title="业余者和爱好者"></a>业余者和爱好者</h4><p>一个业余科学家，并非为了要跟专业科学家竞争，而是用象征的训练手法扩充心灵的技巧，在意识中创造秩序。在这个层次上，业余学术研究也能自称一家，甚至比专业者还能发挥更大的作用，一旦业余者忘记了这个目标，用知识来支撑自大，或取得物质利益，就变成了学者的拙劣模仿。外行人若缺乏怀疑与互相批评的基本科学训练，怀着偏见，闯入知识领域，可能会变得比腐败的学者更无情、更偏激。</p>
<h4 id="活到老学到老"><a href="#活到老学到老" class="headerlink" title="活到老学到老"></a>活到老学到老</h4><p>很多人一离开校门就不在学习，因为一二十年受外界强迫的学生生涯留下了许多不愉快的回忆。他们长期受老师和教科书操纵，毕业的那天就是他们的自由之日。<br>但放弃运用象征技巧的人永远不可能获得真正的自由。他的思想会被专家学者牵着鼻子走。在理想状况下，强迫教育的结束应该是自动自发追求更高教育的开始。这时，学习的目标不再是分数、文凭或找份好工作，而是了解周遭的事物，从个人经验中发掘意义，建构价值观，思考者会从这里面找到深邃的乐趣。</p>
<hr>
<h2 id="工作之乐"><a href="#工作之乐" class="headerlink" title="工作之乐"></a>工作之乐</h2><h3 id="工作的乐趣"><a href="#工作的乐趣" class="headerlink" title="工作的乐趣"></a>工作的乐趣</h3><p>我们投注在物质目标上的精神熵越多，达到目标的希望就越不可及，我们必须耗费更多心灵与体能的劳动以及自然资源，才能满足不断升高的欲望。历史上，身处所谓“文明”社会里的大多数人，都为实现少数剥削者的梦想放弃了享受生活乐趣的希望。<br>通过工作提升生活品质，需要两项辅助策略。一方面要重新设计工作，使它尽可能接近心流活动-诸如打猎、家庭式纺织、外科手术等。另一方面，还得培养像庖丁那样自得其乐的性格，加强技巧，选择可行的目标。这两项策略单独使用，都不可能使工作乐趣额增加太多，但两者双管齐下，却能产生意想不到的最有体验。</p>
<h3 id="未来属于商用闲暇的人"><a href="#未来属于商用闲暇的人" class="headerlink" title="未来属于商用闲暇的人"></a>未来属于商用闲暇的人</h3><p>不断星起的休闲事业，以用富于乐趣的体验填满空间、时间为宗旨。然而大多数人不但没有善用生理与心理资源体会心流，反而花许多时间，坐在电视机前观赏知名运动好手在大体育场的表演。我们并不创作音乐，而只听身价数百万美元的歌手的白金唱片；我们不从事艺术创作，只会对拍卖会场上喊得最高价的名画赞叹不已；我们也不肯冒险贯彻自己的信念，只会每天花几个小时，看演员在虚拟的情境中，假扮出生入死。<br>未来不仅属于受过教育的人，更属于那些懂得善用闲暇的人。</p>
<hr>
<h2 id="人际之乐"><a href="#人际之乐" class="headerlink" title="人际之乐"></a>人际之乐</h2><p>心流研究一再证实，生活的品质主要由两大因素决定：我们如何体验工作以及我们与他人的互动关系。要知道我们究竟是个什么样的人，最详尽的资讯来自我们交往的人，以及我们完成工作的方式。一个人的自我就由这两者界定，正如弗洛伊德为幸福所开的处方：“爱与工作”。<br>有没有人做伴，对体验品质的影响甚大。我们与生俱来会把别人视为世界上最重要的客体，而他们有能力是生活变得有趣、充实或悲惨，因此我们如何处理与他们的交往关系，对幸福有举足轻重的影响。如何能学会把人际关系塑造的更贴近心流体验，生活的品质就能提升。<br>人际关系就跟其他事情一样，一切顺利，我们就觉得非常愉快；挫折丛生时，我们就感到沮丧。其实人是环境中最有弹性，也最善变的因素。同样一个人，早晨可能使我们快乐无比，晚上则可能变成磨人的恶魔。我们太依赖别人的情爱与认可，以至于完全受制于他们对待我们的方式。<br>任何人际交往的情况都可以借着重新制定规则而改变。人际关系的调适性很强，运用适当的技巧就能改变它的规则。</p>
<p>独处的时候,一般的青少年必然会想到:“我的女朋友在做什么?我是不是长了青春痘?我来得及写完数学作业吗?昨天跟我打架的那群痞子会来报仇吗?”换言之,无所事事的时候,心灵就无法遏制消极念头的来袭.除非学会控制意识,否则成年人也会被类似的情况困扰.有关感情、健康、投资、家人及工作的烦恼,总在注意力周遭徘徊,一有机会就乘虚而入.心灵一准备要放松,虎视眈眈的难题就“咻”的一声扑上前来.<br>正因为如此,电视成了许多人的恩宠.虽然看电视算不得什么积极的体验–很多人说,他们看电视时觉得消极、软弱、易怒,但跳动不已的屏幕至少带给意识某种程度的秩序感.可预测的情节、熟悉的角色,甚至大量的广告,都提供一种令人安心的刺激模式.屏幕使注意力在一个容易处理的小范围之内,心灵跟电视互动,暂时可以不受个人的烦虑打扰.屏幕上掠过的资讯,会把不愉快的念头逐走.但用这种方式逃避沮丧,实在是一种浪费,因为徒然投下许多注意力,却得不到什么收获.<br>不论在肉体还是情绪上伤害自己,都可以确保注意力集中在一件虽然痛苦,但至少控制得住的事情上-因为造成痛苦的是我们自己</p>
<p><strong>学会独处</strong>的习惯越早养成越好,而且永远不嫌太早.前几章已经谈到运用肉体与心灵创造心流的方法,如果一个人能随心所欲进入心流,不受外在条件限制,就已掌握了改变生活品质的钥匙.</p>
<p>熬过孤独唯一的方法就是设法整顿注意力,不让精神熵损害心灵.</p>
<hr>
<h2 id="如何自得其乐"><a href="#如何自得其乐" class="headerlink" title="如何自得其乐"></a>如何自得其乐</h2><ul>
<li><p>确立目标</p>
</li>
<li><p>全神贯注</p>
</li>
<li><p>避免过于自我</p>
</li>
<li><p>从当前体验中寻找乐趣</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/04/tcpdump/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/tcpdump/" itemprop="url">tcpdump常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T17:03:05+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>-A 以ascii的格式输出</li>
<li>-r 读文件</li>
<li>-w 写文件</li>
<li>-c 指定多少个包后退出tcpdump</li>
<li>-D 输出可用的网络接口</li>
<li>-e 可用于输出MAC地址信息</li>
<li>-i 指定接口</li>
<li>-n 不将ip地址和端口转成名称</li>
<li>-t 不输出时间戳</li>
<li>-x 输出数据包的二进制码</li>
<li>-v verbose 输出全部的协议编码</li>
<li>host 指定只抓取某主机数据</li>
<li>port 指定端口</li>
<li>src 指定源</li>
<li>dst 指定目的地</li>
<li>过滤数据 例如：直接将icmp追加到尾部过滤出icmp的数据</li>
</ul>
<p>举个🌰，过滤arp包数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i en0 -c 90 -ent arp &apos;dst 192.168.10.1 and src 192.168.10.121&apos;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/03/七周七语言/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/03/七周七语言/" itemprop="url">七周七语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-03T11:56:08+08:00">
                2019-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h2><ul>
<li>懂语言的类型模式</li>
<li>懂语言的编程范型</li>
<li>怎样和语言交互</li>
<li>语言的判断结构</li>
<li>那些核心特性让这些语言与众不同</li>
</ul>
<h2 id="有趣的鸭子类型。"><a href="#有趣的鸭子类型。" class="headerlink" title="有趣的鸭子类型。"></a>有趣的鸭子类型。</h2><p>如果有一直鸟，走起来像鸭子，游泳起来像鸭子，叫起来也像鸭子，那么这只鸟就可以叫鸭子。鸭子类型能在不使用继承的情况下实现多态。鸭子类型是动态语言类型的一种风格。面向对象是实现鸭子类型的必要不充分条件。鸭子类型指导我们关注对象行为而不是对象本身。</p>
<p>伪代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function caculator(a,b,c) return (a+b)*c;</span><br><span class="line">caculator(1,2,3);</span><br><span class="line">caculator([1,2],[2,3],1);</span><br><span class="line">caculator(&apos;hello&apos;, &apos;world, 1);</span><br></pre></td></tr></table></figure></p>
<p>只要对象支持+和*的方法，以上代码就能正常执行。否则将报错。<br>将以上代码翻译成Python2.7语言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def caculator(a,b,c):</span><br><span class="line">    return (a + b) * c</span><br><span class="line"></span><br><span class="line">print caculator(1,2,3)</span><br><span class="line">print caculator([1,2],[2,3],1)</span><br><span class="line">print caculator(&apos;hello&apos;, &apos;world&apos;, 1)</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">[1, 2, 2, 3]</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="brczo.github.io/2019/04/02/promise解决的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="brczo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="进化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/02/promise解决的问题/" itemprop="url">promise解决的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-02T15:06:53+08:00">
                2019-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="promise是未来值。promise主要用来解决同步和异步共同存在时带来的代码的执行结果不确定问题"><a href="#promise是未来值。promise主要用来解决同步和异步共同存在时带来的代码的执行结果不确定问题" class="headerlink" title="promise是未来值。promise主要用来解决同步和异步共同存在时带来的代码的执行结果不确定问题"></a>promise是未来值。promise主要用来解决同步和异步共同存在时带来的代码的执行结果不确定问题</h2><h2 id="一旦promise决议，它就永远保持这个状态。此时它就变成了不变指（immutable-value），可以按需查看。"><a href="#一旦promise决议，它就永远保持这个状态。此时它就变成了不变指（immutable-value），可以按需查看。" class="headerlink" title="一旦promise决议，它就永远保持这个状态。此时它就变成了不变指（immutable value），可以按需查看。"></a>一旦promise决议，它就永远保持这个状态。此时它就变成了不变指（immutable value），可以按需查看。</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">brczo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">brczo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
