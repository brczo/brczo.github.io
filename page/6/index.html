<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>进化</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="进化">
<meta property="og:url" content="brczo.github.io/page/6/index.html">
<meta property="og:site_name" content="进化">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="进化">
  
    <link rel="alternate" href="/atom.xml" title="进化" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">进化</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="brczo.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-js设计模式与开发实践0306" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/17/js设计模式与开发实践0306/" class="article-date">
  <time datetime="2019-04-17T15:03:49.077Z" itemprop="datePublished">2019-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/17/js设计模式与开发实践0306/">第三章 高阶函数的其他应用 函数柯里化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="curring-函数柯里化"><a href="#curring-函数柯里化" class="headerlink" title="curring 函数柯里化"></a>curring 函数柯里化</h2><p>curring又称部分求值。一个curring的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。<br>编写一个计算每月开销的函数。在每天结束之前，我们都要记录今天花掉了多少钱。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var monthlyCost = 0;</span><br><span class="line">var cost = function(money)&#123;</span><br><span class="line">    monthlyCost += money;</span><br><span class="line">&#125;;</span><br><span class="line">cost(100); //第一天开销</span><br><span class="line">cost(200); //第二天开销</span><br><span class="line">cost(300); //第三天开销</span><br><span class="line">console.log(monthlyCost);// 输出：600</span><br></pre></td></tr></table></figure></p>
<p>上面的代码计算了今天为止花了多少钱。但我们只想知道月底花了多少钱。也就是说，只需在月底计算一次。如果在每个月的前29天，我们都只是保存好当天的开销，知道第30天才进行求值计算。虽然下面的函数还不是currying函数的完整实现，但有助于我们了解其思想：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var cost = (function()&#123;</span><br><span class="line">    var args = [];</span><br><span class="line">    return = function()&#123;</span><br><span class="line">        if(arguments.length === 0)&#123;</span><br><span class="line">            var money = 0;</span><br><span class="line">            for(var i = 0, l = args.length; i &lt; l; i++)&#123;</span><br><span class="line">                money += args[i];</span><br><span class="line">            &#125;</span><br><span class="line">            return money;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            [].push.apply(args, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line">cost(200); //未真正求值</span><br><span class="line">cost(300); //未真正求值</span><br><span class="line">console.log(cost()); //求值并输出：600</span><br></pre></td></tr></table></figure></p>
<p>编写一个通用的currying函数，它接受一个参数，即将要被curring的函数。在这个例子里，这个函数的作用遍历本月每天的开销并求出它们的总和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var curring = function(fn)&#123;</span><br><span class="line">    var args = [];</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(arguments.length === 0)&#123;</span><br><span class="line">            return fn.apply(this, args);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            [].push.apply(args, arguments);</span><br><span class="line">            return arguments.callee;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var cost = (function()&#123;</span><br><span class="line">    var money = 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            money += arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">var cost = currying(cost);  //转化成currying函数</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line">cost(100); //未真正求值</span><br><span class="line"></span><br><span class="line">console.log(cost()); //求值并输出：600</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/17/js设计模式与开发实践0306/" data-id="cjv6d1dgn000x5cjb0yzf6yfb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js设计模式与开发实践0305" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/17/js设计模式与开发实践0305/" class="article-date">
  <time datetime="2019-04-17T00:50:42.261Z" itemprop="datePublished">2019-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/17/js设计模式与开发实践0305/">第三章 高阶函数的概念和应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>高阶函数是至少满足下列条件之一的函数：</p>
<ul>
<li>函数可以作为参数被传递</li>
<li>函数可以作为返回值输出</li>
</ul>
<h2 id="函数最为参数传递"><a href="#函数最为参数传递" class="headerlink" title="函数最为参数传递"></a>函数最为参数传递</h2><p>把函数作为参数传递，这代表我们可以抽离一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个常见的重要的应用场景是常见的回掉函数。</p>
<h2 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h2><h2 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h2><p>AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来后，再通过“动态织入”的方式掺入业务逻辑模块中。这样的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。<br>通常，在js中实现AOP，都是指把一个函数“动态织入”到另一个函数之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before = function(beforefn)&#123;</span><br><span class="line">    var _self = this; //保存原函数的引用</span><br><span class="line">    return function() &#123;</span><br><span class="line">        beforefn.apply(this, arguments); //执行新函数，修正this 防止this丢失</span><br><span class="line">        return _self.apply(this, arguments); // 执行原函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Function.prototype.after = function(afterfn)&#123;</span><br><span class="line">    var _self = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var ret = _self.apply(this, arguments);</span><br><span class="line">        afterfn.apply(this, arguments);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func = function() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func = func.before(function()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;).after(function()&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/17/js设计模式与开发实践0305/" data-id="cjv6d1dgo000z5cjb348d9gj2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js设计模式与开发实践0304" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/js设计模式与开发实践0304/" class="article-date">
  <time datetime="2019-04-16T14:46:48.250Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/js设计模式与开发实践0304/">第三章 闭包与内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>闭包与内存泄漏的关系是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏。但这本省并非必报的问题，也并非js的问题。在IE浏览器中，由于BOM和DOM的对象是使用c++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null 即可。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运 行时，就会删除这些值并回收它们占用的内存。<br>不如，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function handle()&#123;</span><br><span class="line">    var element = document.getElementById(&apos;div&apos;);</span><br><span class="line">    element.onclick = function()&#123;</span><br><span class="line">        console.log(element.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数中给element的onclick属性赋值了一个闭包，闭包要访问element的id属性。闭包在js中也是对象，函数即对象。闭包会持有外部传入的变量，因此闭包持有了element对象，而element对象通过onclick属性持有了闭包，因此两个对象相互持有，造成内存泄漏。</p>
<p>解决方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function handle()&#123;</span><br><span class="line">    var element = document.getElementById(&apos;div&apos;);</span><br><span class="line">    var id = element.id;</span><br><span class="line">    element.onclick = function()&#123;</span><br><span class="line">        console.log(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时element对象持有id，不再是element。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/16/js设计模式与开发实践0304/" data-id="cjv6d1dgm000v5cjbmrjow3ij" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js设计模式与开发实践0303" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/js设计模式与开发实践0303/" class="article-date">
  <time datetime="2019-04-16T14:33:41.195Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/js设计模式与开发实践0303/">第三章 用闭包实现命令模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>命令模式的意思是把请求封装为对象，从而分离请求的发起者和请求的接受者（执行者）之间的耦合关系。在命令执行前，可以预先往命令对象植入命令的接受者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button id=&quot;execute&quot;&gt;点击我执行命令&lt;/button&gt;</span><br><span class="line">        &lt;button id=&quot;undo&quot;&gt;点击我执行命令&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var Tv = &#123;</span><br><span class="line">            open: function()&#123;</span><br><span class="line">                console.log(&apos;打开电视机&apos;);</span><br><span class="line">            &#125;,</span><br><span class="line">            close: function()&#123;</span><br><span class="line">                console.log(&apos;关上电视机&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        var openTvCommand = function(receiver)&#123;</span><br><span class="line">            this.receiver = receiver;</span><br><span class="line">        &#125;;</span><br><span class="line">        openTvCommand.prototype.execute = function()&#123;</span><br><span class="line">            this.receiver.open(); //执行命令， 打开电视机</span><br><span class="line">        &#125;;</span><br><span class="line">        openTvCommand.prototype.undo = function()&#123;</span><br><span class="line">            this.receiver.close();//撤销命令，关闭电视机</span><br><span class="line">        &#125;;</span><br><span class="line">        var setCommand = function(command)&#123;</span><br><span class="line">            document.getElementById(&apos;execute&apos;).onclick = function()&#123;</span><br><span class="line">                command.execute(); //输出：打开电视机</span><br><span class="line">            &#125;;</span><br><span class="line">            document.getElementById(&apos;undo&apos;).onclick = function()&#123;</span><br><span class="line">                command.undo();  //关闭电视机 </span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        setCommand(new openTvCommand(Tv));</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/16/js设计模式与开发实践0303/" data-id="cjv6d1dgl000t5cjbl7o8cx0t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js设计模式与开发实践0302" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/js设计模式与开发实践0302/" class="article-date">
  <time datetime="2019-04-16T14:16:00.138Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/js设计模式与开发实践0302/">第三章 闭包和面向对象设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var extent = function()&#123;</span><br><span class="line">    var value = 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        call: function()&#123;</span><br><span class="line">            value++;</span><br><span class="line">            console.log(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var extent = extent();</span><br><span class="line">extent.call(); //输出 1</span><br><span class="line">extent.call(); //输出 2</span><br></pre></td></tr></table></figure></p>
<p>如果换成面向对象的写法，就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var extent = &#123;</span><br><span class="line">    value: 0,</span><br><span class="line">    call: function()&#123;</span><br><span class="line">        this.value ++;</span><br><span class="line">        console.log(this.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var extent = function()&#123;</span><br><span class="line">    this.value = 0;</span><br><span class="line">&#125;;</span><br><span class="line">extent.prototype.call = function()&#123;</span><br><span class="line">    this.value ++;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">var extent = new extent();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/16/js设计模式与开发实践0302/" data-id="cjv6d1dgj000r5cjb0u0hh4o4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js设计模式与开发实践0301" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/js设计模式与开发实践0301/" class="article-date">
  <time datetime="2019-04-16T07:53:47.892Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/js设计模式与开发实践0301/">第三章 闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>变量有作用域和生存周期，如果函数内的变量在函数执行完后没有被销毁，这就产生了闭包 </p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>变量的作用域指的是变量的有效范围</p>
<h2 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h2><p>全局变量，局部变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function()&#123;</span><br><span class="line">    var a = 1; //退出函数后局部变量a将被销毁</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p>
<p>闭包，函数执行完后变量未被销毁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var func = function()&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        a++;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var f = func();</span><br><span class="line">f(); //输出：2</span><br><span class="line">f(); //输出：3</span><br><span class="line">f(); //输出：4</span><br><span class="line">f(); //输出：</span><br></pre></td></tr></table></figure></p>
<p>经典应用，js的onclick事件是异步的，是在for循环后执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;3&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;4&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var nodes = document.getElementsByTagName(&apos;div&apos;);</span><br><span class="line">        //不使用闭包</span><br><span class="line">        for(var i = 0, len = nodes.length; i &lt; len; i ++)&#123;</span><br><span class="line">            nodes[i].onclick = function()&#123;</span><br><span class="line">                console.log(i); //全部输出5</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用闭包</span><br><span class="line">        for(var i = 0, len = nodes.length; i &lt; len; i ++)&#123;</span><br><span class="line">            (funcion(i)&#123;</span><br><span class="line">                nodes[i].onclick = function()&#123;</span><br><span class="line">                    console.log(i); //全部输出 0,1,2,3,4</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="闭包的更多作用"><a href="#闭包的更多作用" class="headerlink" title="闭包的更多作用"></a>闭包的更多作用</h2><h3 id="封装变量"><a href="#封装变量" class="headerlink" title="封装变量"></a>封装变量</h3><p>闭包可以把一些不需要暴露在全局的变量封装成私有变量，假设有一个计算乘积的简单函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var mult = function()&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; 1; i++)&#123;</span><br><span class="line">        a = a * arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>mult函数接受一些number类型的参数，并返回这些参数类型的乘积。现在我们觉得对于那么相同的参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var cache = &#123;&#125;;</span><br><span class="line">var mult = function()&#123;</span><br><span class="line">    var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">    if(cache[args])&#123;</span><br><span class="line">        return cache[args];</span><br><span class="line">    &#125;</span><br><span class="line">    var a = 1;</span><br><span class="line">    for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">        a = a * arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return cache[args] = a;</span><br><span class="line">&#125;;</span><br><span class="line">alert(mult(1,2,3)); //输出6</span><br><span class="line">alert(mult(1,2,3)); //输出6</span><br></pre></td></tr></table></figure></p>
<p>我们看到这个变量仅仅在mult函数中被使用，我们可以通过使用闭包将变量放到函数内部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var mult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        var a = 1;</span><br><span class="line">        for(var i = 0, l = arguments.length; i &lt; l; i++)&#123;</span><br><span class="line">            a = a * arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>提炼函数是代码重构中的一种常见技巧。如果在一个大函数中，有一些代码能够独立出来，我们常常把这些代码封装在独立的小函数里面。独立出来的小函数有利于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把他们用闭包封闭起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var mult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    var calculate = function()&#123; //封闭calculate函数</span><br><span class="line">        var a = 1;</span><br><span class="line">        for (var i = 0, l = arguments.length; i &lt; l; i ++) &#123;</span><br><span class="line">            a = a * arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = calculate.apply(null, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h3 id="延续局部变量的寿命"><a href="#延续局部变量的寿命" class="headerlink" title="延续局部变量的寿命"></a>延续局部变量的寿命</h3><p>img对象经常用于进行数据上报，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var report = function(src) &#123;</span><br><span class="line">    var img = new Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">&#125;;</span><br><span class="line">report( &apos;http://xxx.com/getUserInfo&apos; );</span><br></pre></td></tr></table></figure></p>
<p>但是有些情况下，report函数并不是每一次都成功发起了http请求。丢失数据的原因是img是report函数的局部变量，当report调用结束后，img局部变量随即被销毁，而此时或许还没来得及发出http请求。现在我们把img变量用闭包封闭起来，便能解决请求丢失的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var report = (function()&#123;</span><br><span class="line">    var imgs = [];</span><br><span class="line">    return function(src)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        imgs.push(img);</span><br><span class="line">        imgs.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/16/js设计模式与开发实践0301/" data-id="cjv6d1dgf000k5cjblxuecmuz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js设计模式与开发实践0203" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/15/js设计模式与开发实践0203/" class="article-date">
  <time datetime="2019-04-15T06:50:03.959Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/js设计模式与开发实践0203/">第二章 call和apply</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h2><p>Function.prototype.call和Function.prototype.apply都是非常常用的方法。它们的作用一模一样，区别在于传入参数形式的不同。<br>apply接受两个参数，第一个指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，zpply方法把这个集合中的元素作为参数传递给被调用函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a, b ,c)&#123;</span><br><span class="line">    alert([a,b,c]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.apply(null, [1,2,3]);</span><br></pre></td></tr></table></figure></p>
<p>call传入的参数不固定，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a,b,c)&#123;</span><br><span class="line">    alert([a,b,c]);</span><br><span class="line">&#125;</span><br><span class="line">func.call(null, 1, 2, 3);</span><br></pre></td></tr></table></figure></p>
<h2 id="call和apply的用途"><a href="#call和apply的用途" class="headerlink" title="call和apply的用途"></a>call和apply的用途</h2><p>熟练使用call和apply是我们真正成为一名js程序员的重要一步</p>
<h3 id="改变this的指向"><a href="#改变this的指向" class="headerlink" title="改变this的指向"></a>改变this的指向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    name: &apos;amme&apos;</span><br><span class="line">&#125;;</span><br><span class="line">window.name = &apos;window&apos;;</span><br><span class="line">var getName = function()&#123;</span><br><span class="line">    alter(this.name);</span><br><span class="line">&#125;</span><br><span class="line">getName(); // 输出window</span><br><span class="line">getName.call(obj1);//输出 jack</span><br><span class="line">getName.call(obj2);//输出 amme</span><br></pre></td></tr></table></figure>
<p>使用call或apply修正this的指向<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">    alert(this.id); //输出 div1</span><br><span class="line">    var func = function()&#123;</span><br><span class="line">        alert(this.id); //输出：undefined</span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在事件内部调用func函数时，func函数体内的this指向了window，而不是我们预期的div，这时候我们要用call或apply修正<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;div1&apos;).onclick = function()&#123;</span><br><span class="line">    alert(this.id); //输出 div1</span><br><span class="line">    var func = function()&#123;</span><br><span class="line">        alert(this.id); //输出：undefined</span><br><span class="line">    &#125;</span><br><span class="line">    func.call(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h3><p>大部分高级浏览器都实现了内置的Function.prototype.bind，用来指定函数内部的this指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context) &#123;</span><br><span class="line">    var self = this; //保存原函数</span><br><span class="line">    return function()&#123; //返回一个新的函数</span><br><span class="line">        return self.apply(context, arguments); //执行新的函数的时候，会把之前传入的context当作新函数体内的this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;jack&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var func = function()&#123;</span><br><span class="line">    alert(this.name); //输出： jack</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p>
<h3 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h3><p>借用构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var A = function(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = function()&#123;</span><br><span class="line">    A.apply(this, arguments);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.prototype.getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var b = new B(&apos;jack&apos;);</span><br><span class="line">console.log(b.getName()); //输出 ‘jack&apos;</span><br></pre></td></tr></table></figure></p>
<p>使用Array.prototype.push.call<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    Array.prototype.push.call(arguments, 3);</span><br><span class="line">    console.log(arguments); //输出 【1, 2, 3]</span><br><span class="line">&#125;)(1,2)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/15/js设计模式与开发实践0203/" data-id="cjv6d1dgi000o5cjb9kis3f5b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js设计模式与开发实践0103" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/15/js设计模式与开发实践0103/" class="article-date">
  <time datetime="2019-04-15T03:26:31.784Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/js设计模式与开发实践0103/">第一章 原型模式与基于原型的继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="原型编程思想"><a href="#原型编程思想" class="headerlink" title="原型编程思想"></a>原型编程思想</h2><p>在以类为中心的面向对象编程语言中，类和对象关系可以想象成铸模与铸件的关系，对象总是从类中创建而来。而在原型编程思想中，类不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。<br>原型模式不单是一种设计模式，也被称为一种编程范型。</p>
<h2 id="使用克隆的原型模式"><a href="#使用克隆的原型模式" class="headerlink" title="使用克隆的原型模式"></a>使用克隆的原型模式</h2><p>ECMAScript5使用了Object.create方法，可以用来克隆对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Plane = function()&#123;</span><br><span class="line">    this.blood = 100;</span><br><span class="line">    this.attackLevel = 1;</span><br><span class="line">    this.defenseLevel = 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var plane = new Plane();</span><br><span class="line">plane.blood = 500;</span><br><span class="line">plane.attackLevel = 10;</span><br><span class="line">plane.defenseLevel = 7;</span><br><span class="line"></span><br><span class="line">var clonePlane = Object.create(plane); //克隆对象</span><br></pre></td></tr></table></figure></p>
<h2 id="克隆是创建对象的手段"><a href="#克隆是创建对象的手段" class="headerlink" title="克隆是创建对象的手段"></a>克隆是创建对象的手段</h2><h2 id="体验io语言"><a href="#体验io语言" class="headerlink" title="体验io语言"></a>体验io语言</h2><p>原型不仅仅是一种设计模式还是一种编程范型。js就是使用原型模式来搭建整个面向对象的系统的。<br>基于根对象，创建一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io&gt; Animal := Object clone;</span><br><span class="line">Animal makeSound := method(&quot;animal makeSound&quot; print);</span><br></pre></td></tr></table></figure></p>
<p>基于Animal对象创建一个Dog对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io&gt; Dog := Animal clone;</span><br><span class="line">Dog eat := method(&quot;dog eat&quot; printf);</span><br></pre></td></tr></table></figure></p>
<p>原型链<br>Object是Animal的原型，而Animal是Dog的原型，他们之间构成一条原型链。</p>
<h2 id="js中的原型继承"><a href="#js中的原型继承" class="headerlink" title="js中的原型继承"></a>js中的原型继承</h2><h3 id="所有数据都是对象"><a href="#所有数据都是对象" class="headerlink" title="所有数据都是对象"></a>所有数据都是对象</h3><p>按照js设计者的本意， 除了undefined之外，js中一切都是对象。js中的根对象是Object.prototype。Object.prototype是一个空对象。我们遇到的每个对象其实都是从Object.prototype对象克隆而来。Object.prototype对象就是他们的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = &#123;&#125;;</span><br><span class="line">console.log(Object.getPrototypeOf(obj1) === Object.prototype ); //输出： true</span><br><span class="line">console.log(Object.getPrototypeOf(obj2) === Object.prototype ); //输出： true</span><br></pre></td></tr></table></figure></p>
<h3 id="要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆"><a href="#要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆" class="headerlink" title="要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆"></a>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = new Person(&quot;jack&quot;);</span><br><span class="line">console.log(a.name); //输出jack</span><br><span class="line">console.log(a.getName); //输出jack</span><br><span class="line">console.log(Object.getPrototypeOf(a) === Person.prototype); //输出：true</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<strong>Person不是类，而是函数构造</strong>，js中的函数既可以作为普通函数使用，也可以作为构造器被调用。用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype对象，在进行额外的操作。</p>
<h3 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h3><p>js给对象提供了一个名为<strong>proto</strong>的隐藏属性，某个对象的<strong>proto</strong>属性默认会指向它的构造器的原型对象。在Chrome中，<strong>proto</strong>会被公开出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = new Object();</span><br><span class="line">console.log(a.__proto__ === Object.prototype); 输出 true</span><br></pre></td></tr></table></figure></p>
<h3 id="如果某个对象无法响应某个请求，它会把这个请求委托给它的构造器的原型"><a href="#如果某个对象无法响应某个请求，它会把这个请求委托给它的构造器的原型" class="headerlink" title="如果某个对象无法响应某个请求，它会把这个请求委托给它的构造器的原型"></a>如果某个对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</h3><p><strong>这条规则是原型继承的精髓</strong>。原型继承方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name: &apos;jack&apos;&#125;;</span><br><span class="line">var A = function()&#123;&#125;;</span><br><span class="line">A.prototype = obj;</span><br><span class="line"></span><br><span class="line">var a = new A();</span><br><span class="line">console.log(a.name); //输出： jack</span><br></pre></td></tr></table></figure></p>
<p>以上代码中，引擎做了哪些：</p>
<ul>
<li>首先尝试遍历对象a中的所有属性，但没有找到name这个属性</li>
<li>查找name属性的这个请求被委托给对象a的构造器的原型，它被a.<strong>proto</strong>记录着，指向A.protype,而A.prototype被设置为对象obj</li>
<li>在obj对象中找到了name属性，并返回它的值。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/15/js设计模式与开发实践0103/" data-id="cjv6d1dgc000f5cjbz50pb6rk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js设计模式与开发实践0102" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/15/js设计模式与开发实践0102/" class="article-date">
  <time datetime="2019-04-15T03:04:50.828Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/js设计模式与开发实践0102/">第一章 封装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>封装的目的是将信息隐藏，包括隐藏数据、实现细节、设计细节以及对象的类型。</p>
<h2 id="封装数据"><a href="#封装数据" class="headerlink" title="封装数据"></a>封装数据</h2><p>js依赖变量的作用域来实现封装特性，而且只能模拟出public和private两种封装性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = (function()&#123;</span><br><span class="line">    let _name = &apos;jack&apos;; // 私有（private）变量</span><br><span class="line">    return &#123;</span><br><span class="line">        getName: function()&#123;  // 公开（public）方法</span><br><span class="line">            return _name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(obj.getName()); //输出：jack</span><br><span class="line">console.log(obj._name); // 输出：undefined</span><br></pre></td></tr></table></figure></p>
<h2 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h2><p>封装实现使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对他自己的行为负责。其他对象或用户不关心它的内部实现。</p>
<h2 id="封装类型"><a href="#封装类型" class="headerlink" title="封装类型"></a>封装类型</h2><p>封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口 来进行的1。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象 的行为。在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生 5 的原因之一。比如工厂方法模式、组合模式等。</p>
<h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>从设计模式 的角度出发，封装在更重要的层面体现为封装变化。设计模式可分为：</p>
<ul>
<li>创建型模式 目的是封装创建对象的变化</li>
<li>结构型模式 封装对象之间的组合关系</li>
<li>行为型模式 封装对象的行为变化</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/15/js设计模式与开发实践0102/" data-id="cjv6d1dg600095cjbe0yu8zp1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构-绪论" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/15/数据结构-绪论/" class="article-date">
  <time datetime="2019-04-15T02:02:22.730Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/数据结构-绪论/">数据结构 绪论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><p>数据：对客观事物符号的表示，在计算机科学中，是指所有能输入到计算机中并被计算机程序处理的符号的总成。<br>数据元素：是数据的几本单位，在计算机中通常作为一个整体进行考虑和处理。有时一个数据元素可由若干个数据项组成。数据项是是数据的不可分割的最小单位。<br>数据对象：是性质相同的数据元素的集合，是数据的一个子集。<br>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<h2 id="算法与算法分析"><a href="#算法与算法分析" class="headerlink" title="算法与算法分析"></a>算法与算法分析</h2><p>算法：是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。<br>算法的5个特性：</p>
<ul>
<li>有穷性 一个算法必须总是在执行有穷步后结束，且每一步都要在有穷时间内完成</li>
<li>确定性 算法的每一条指令必须有确定的含义，读者理解时不会产生二义性。并且，在任何条件下，算法只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</li>
<li>可行性 一个算法是可行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。</li>
<li>输入 一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li>
<li>输出 一个算法有一个或多个的输出，这些输出是同输入有着某些特定关系的两。</li>
</ul>
<p>算法设计的要求</p>
<ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>效率与低存储量需求</li>
</ul>
<p>时间复杂度<br>空间复杂度</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="brczo.github.io/2019/04/15/数据结构-绪论/" data-id="cjv6d1dit003x5cjbhpjxxv1q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CMake/">CMake</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP设计模式/">PHP设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js设计模式与开发实践/">js设计模式与开发实践</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux高性能服务器/">linux高性能服务器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tinyhttpd源码分析/">tinyhttpd源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/优势谈判/">优势谈判</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/原则-Ray-Dalio/">原则 Ray Dalio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/富爸爸穷爸爸/">富爸爸穷爸爸</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小狗钱钱/">小狗钱钱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心流/">心流</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/高效能人士的七个习惯/">高效能人士的七个习惯</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/09/php设计模式10/">享元模式</a>
          </li>
        
          <li>
            <a href="/2019/05/08/php中的坑/">PHP中的坑</a>
          </li>
        
          <li>
            <a href="/2019/05/08/js设计模式与开发实践1203/">第十一章 职责链模式</a>
          </li>
        
          <li>
            <a href="/2019/05/08/js设计模式与开发实践1202/">第十一章 享元模式 文件上传</a>
          </li>
        
          <li>
            <a href="/2019/05/07/js设计模式与开发实践1201/">第十一章 享元模式 基本概念</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 brczo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/scripts/love.js"></script>



  </div>
</body>
</html>